Return-Path: <qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org>
X-Original-To: lists+qemu-devel@lfdr.de
Delivered-To: lists+qemu-devel@lfdr.de
Received: from lists.gnu.org (lists.gnu.org [209.51.188.17])
	by mail.lfdr.de (Postfix) with ESMTPS id 6E0E7BB9D4
	for <lists+qemu-devel@lfdr.de>; Mon, 23 Sep 2019 18:45:06 +0200 (CEST)
Received: from localhost ([::1]:59586 helo=lists1p.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.90_1)
	(envelope-from <qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org>)
	id 1iCRST-00083O-2S
	for lists+qemu-devel@lfdr.de; Mon, 23 Sep 2019 12:45:05 -0400
Received: from eggs.gnu.org ([2001:470:142:3::10]:57396)
 by lists.gnu.org with esmtp (Exim 4.90_1)
 (envelope-from <vsementsov@virtuozzo.com>) id 1iCQxa-0002c8-HH
 for qemu-devel@nongnu.org; Mon, 23 Sep 2019 12:13:22 -0400
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
 (envelope-from <vsementsov@virtuozzo.com>) id 1iCQxP-0003mq-Rz
 for qemu-devel@nongnu.org; Mon, 23 Sep 2019 12:13:10 -0400
Received: from relay.sw.ru ([185.231.240.75]:39494)
 by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
 (Exim 4.71) (envelope-from <vsementsov@virtuozzo.com>)
 id 1iCQxM-0003a6-H4; Mon, 23 Sep 2019 12:12:59 -0400
Received: from [10.94.3.0] (helo=kvm.qa.sw.ru)
 by relay.sw.ru with esmtp (Exim 4.92.2)
 (envelope-from <vsementsov@virtuozzo.com>)
 id 1iCQx0-0001Fp-SR; Mon, 23 Sep 2019 19:12:35 +0300
From: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
To: qemu-devel@nongnu.org
Subject: [RFC v2 7/9] Use auto-propagated errp
Date: Mon, 23 Sep 2019 19:12:29 +0300
Message-Id: <20190923161231.22028-8-vsementsov@virtuozzo.com>
X-Mailer: git-send-email 2.21.0
In-Reply-To: <20190923161231.22028-1-vsementsov@virtuozzo.com>
References: <20190923161231.22028-1-vsementsov@virtuozzo.com>
MIME-Version: 1.0
Content-Transfer-Encoding: 8bit
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 3.x
X-Received-From: 185.231.240.75
X-Mailman-Approved-At: Mon, 23 Sep 2019 12:26:10 -0400
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.23
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <https://lists.nongnu.org/archive/html/qemu-devel>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: stefanha@redhat.com, codyprime@gmail.com, jan.kiszka@siemens.com,
 berto@igalia.com, zhang.zhanghailiang@huawei.com, qemu-block@nongnu.org,
 arikalo@wavecomp.com, pasic@linux.ibm.com, hpoussin@reactos.org,
 anthony.perard@citrix.com, samuel.thibault@ens-lyon.org, philmd@redhat.com,
 green@moxielogic.com, lvivier@redhat.com, ehabkost@redhat.com,
 xiechanglong.d@gmail.com, pl@kamp.de, dgilbert@redhat.com, b.galvani@gmail.com,
 eric.auger@redhat.com, alex.williamson@redhat.com, ronniesahlberg@gmail.com,
 jsnow@redhat.com, rth@twiddle.net, kwolf@redhat.com, vsementsov@virtuozzo.com,
 andrew@aj.id.au, crwulff@gmail.com, sundeep.lkml@gmail.com, michael@walle.cc,
 qemu-ppc@nongnu.org, kbastian@mail.uni-paderborn.de, imammedo@redhat.com,
 fam@euphon.net, peter.maydell@linaro.org, sheepdog@lists.wpkg.org,
 david@redhat.com, palmer@sifive.com, thuth@redhat.com, jcmvbkbc@gmail.com,
 den@openvz.org, hare@suse.com, sstabellini@kernel.org, arei.gonglei@huawei.com,
 namei.unix@gmail.com, atar4qemu@gmail.com, farman@linux.ibm.com,
 amit@kernel.org, sw@weilnetz.de, groug@kaod.org, qemu-s390x@nongnu.org,
 qemu-arm@nongnu.org, peter.chubb@nicta.com.au, clg@kaod.org, shorne@gmail.com,
 qemu-riscv@nongnu.org, cohuck@redhat.com, amarkovic@wavecomp.com,
 aurelien@aurel32.net, pburton@wavecomp.com, sagark@eecs.berkeley.edu,
 jasowang@redhat.com, kraxel@redhat.com, edgar.iglesias@gmail.com,
 gxt@mprc.pku.edu.cn, ari@tuxera.com, quintela@redhat.com,
 mdroth@linux.vnet.ibm.com, lersek@redhat.com, borntraeger@de.ibm.com,
 antonynpavlov@gmail.com, dillaman@redhat.com, joel@jms.id.au,
 xen-devel@lists.xenproject.org, integration@gluster.org, rjones@redhat.com,
 Andrew.Baumann@microsoft.com, mreitz@redhat.com, walling@linux.ibm.com,
 mst@redhat.com, mark.cave-ayland@ilande.co.uk, v.maffione@gmail.com,
 marex@denx.de, armbru@redhat.com, marcandre.lureau@redhat.com,
 alistair@alistair23.me, paul.durrant@citrix.com, pavel.dovgaluk@ispras.ru,
 g.lettieri@iet.unipi.it, rizzo@iet.unipi.it, david@gibson.dropbear.id.au,
 akrowiak@linux.ibm.com, berrange@redhat.com, xiaoguangrong.eric@gmail.com,
 pmorel@linux.ibm.com, wencongyang2@huawei.com, jcd@tribudubois.net,
 pbonzini@redhat.com, stefanb@linux.ibm.com
Errors-To: qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org>

This commit is generated by command

git grep -l 'Error \*\*errp' | while read f; \
do spatch --sp-file \
scripts/coccinelle/auto-propagated-errp.cocci --in-place $f; done

Signed-off-by: Vladimir Sementsov-Ogievskiy <vsementsov@virtuozzo.com>
---
 include/hw/pci-host/spapr.h         |   2 +
 target/ppc/kvm_ppc.h                |   1 +
 target/s390x/cpu_models.h           |   2 +
 audio/audio.c                       |  12 +-
 authz/pamacct.c                     |   1 +
 backends/cryptodev-vhost-user.c     |   9 +-
 backends/cryptodev.c                |  19 +--
 backends/hostmem-file.c             |  19 +--
 backends/hostmem-memfd.c            |  17 +--
 backends/hostmem.c                  |  38 ++---
 backends/rng.c                      |   6 +-
 block.c                             | 208 ++++++++++----------------
 block/blkdebug.c                    |  33 ++---
 block/blklogwrites.c                |  21 +--
 block/blkreplay.c                   |   6 +-
 block/blkverify.c                   |  16 +-
 block/block-backend.c               |  17 +--
 block/commit.c                      |   6 +-
 block/crypto.c                      |  12 +-
 block/curl.c                        |   6 +-
 block/file-posix.c                  |  71 ++++-----
 block/file-win32.c                  |  27 ++--
 block/gluster.c                     |  64 ++++----
 block/io.c                          |  11 +-
 block/iscsi.c                       |  33 ++---
 block/mirror.c                      |  17 +--
 block/nbd.c                         |  44 +++---
 block/nfs.c                         |   6 +-
 block/nvme.c                        |  17 +--
 block/parallels.c                   |  28 ++--
 block/qapi.c                        |  23 +--
 block/qcow.c                        |  15 +-
 block/qcow2-bitmap.c                |   6 +-
 block/qcow2.c                       |  90 +++++-------
 block/qed.c                         |  16 +-
 block/quorum.c                      |  22 ++-
 block/raw-format.c                  |   6 +-
 block/rbd.c                         |  25 +---
 block/replication.c                 |  36 ++---
 block/sheepdog.c                    |  66 ++++-----
 block/snapshot.c                    |  14 +-
 block/ssh.c                         |  11 +-
 block/throttle-groups.c             |  22 ++-
 block/throttle.c                    |   6 +-
 block/vdi.c                         |  12 +-
 block/vhdx.c                        |  20 +--
 block/vmdk.c                        |  36 ++---
 block/vpc.c                         |  25 ++--
 block/vvfat.c                       |  11 +-
 block/vxhs.c                        |  22 ++-
 blockdev.c                          | 220 ++++++++++------------------
 blockjob.c                          |   7 +-
 bootdevice.c                        |  29 ++--
 chardev/char-socket.c               |   6 +-
 chardev/char.c                      |  18 +--
 crypto/block-luks.c                 |  31 ++--
 crypto/secret.c                     |  16 +-
 crypto/tlssession.c                 |   6 +-
 dump/dump.c                         | 142 +++++++-----------
 dump/win_dump.c                     |  27 ++--
 exec.c                              |  12 +-
 hw/9pfs/9p-local.c                  |   7 +-
 hw/acpi/core.c                      |  17 +--
 hw/acpi/ich9.c                      |  27 ++--
 hw/acpi/memory_hotplug.c            |   6 +-
 hw/arm/allwinner-a10.c              |  26 ++--
 hw/arm/armv7m.c                     |  51 +++----
 hw/arm/bcm2835_peripherals.c        |  84 +++++------
 hw/arm/bcm2836.c                    |  40 ++---
 hw/arm/digic.c                      |  21 +--
 hw/arm/fsl-imx25.c                  |  61 +++-----
 hw/arm/fsl-imx31.c                  |  56 +++----
 hw/arm/fsl-imx6.c                   |  80 ++++------
 hw/arm/integratorcp.c               |   6 +-
 hw/arm/msf2-soc.c                   |  21 +--
 hw/arm/nrf51_soc.c                  |  46 +++---
 hw/arm/smmu-common.c                |   6 +-
 hw/arm/smmuv3.c                     |   6 +-
 hw/arm/stm32f205_soc.c              |  38 ++---
 hw/arm/tosa.c                       |   1 +
 hw/arm/xlnx-versal-virt.c           |   6 +-
 hw/arm/xlnx-zynqmp.c                |  84 +++++------
 hw/audio/intel-hda.c                |  12 +-
 hw/block/dataplane/xen-block.c      |  16 +-
 hw/block/fdc.c                      |  17 +--
 hw/block/onenand.c                  |   6 +-
 hw/block/pflash_cfi01.c             |   6 +-
 hw/block/pflash_cfi02.c             |   6 +-
 hw/block/vhost-user-blk.c           |   5 +-
 hw/block/virtio-blk.c               |   6 +-
 hw/block/xen-block.c                | 114 ++++++--------
 hw/char/debugcon.c                  |   6 +-
 hw/char/serial-pci-multi.c          |   6 +-
 hw/char/serial-pci.c                |   6 +-
 hw/char/virtio-serial-bus.c         |   6 +-
 hw/core/bus.c                       |  14 +-
 hw/core/machine.c                   |  18 +--
 hw/core/numa.c                      |  48 +++---
 hw/core/qdev-properties-system.c    |  24 +--
 hw/core/qdev-properties.c           |  78 ++++------
 hw/core/qdev.c                      |  36 ++---
 hw/core/sysbus.c                    |   1 +
 hw/cpu/a15mpcore.c                  |   6 +-
 hw/cpu/a9mpcore.c                   |  26 ++--
 hw/cpu/arm11mpcore.c                |  21 +--
 hw/cpu/core.c                       |  12 +-
 hw/cpu/realview_mpcore.c            |  11 +-
 hw/display/bcm2835_fb.c             |   5 +-
 hw/display/qxl.c                    |   6 +-
 hw/display/virtio-gpu-base.c        |   6 +-
 hw/display/virtio-gpu-pci.c         |   6 +-
 hw/display/virtio-vga.c             |   6 +-
 hw/dma/bcm2835_dma.c                |   5 +-
 hw/dma/xilinx_axidma.c              |  14 +-
 hw/gpio/aspeed_gpio.c               |   6 +-
 hw/gpio/bcm2835_gpio.c              |   9 +-
 hw/i386/kvm/apic.c                  |   1 +
 hw/i386/pc.c                        | 109 +++++---------
 hw/ide/qdev.c                       |  15 +-
 hw/input/virtio-input.c             |  12 +-
 hw/intc/apic_common.c               |   6 +-
 hw/intc/arm_gic.c                   |   6 +-
 hw/intc/arm_gic_kvm.c               |  11 +-
 hw/intc/arm_gicv3.c                 |  11 +-
 hw/intc/arm_gicv3_its_kvm.c         |   6 +-
 hw/intc/arm_gicv3_kvm.c             |  16 +-
 hw/intc/armv7m_nvic.c               |  11 +-
 hw/intc/nios2_iic.c                 |   5 +-
 hw/intc/pnv_xive.c                  |  14 +-
 hw/intc/realview_gic.c              |   6 +-
 hw/intc/s390_flic_kvm.c             |  10 +-
 hw/intc/spapr_xive.c                |  11 +-
 hw/intc/spapr_xive_kvm.c            |  49 +++----
 hw/intc/xics.c                      |  31 ++--
 hw/intc/xics_kvm.c                  |  28 ++--
 hw/intc/xics_pnv.c                  |   6 +-
 hw/intc/xive.c                      |  23 +--
 hw/ipack/ipack.c                    |   4 +-
 hw/isa/pc87312.c                    |   6 +-
 hw/mem/memory-device.c              |  19 +--
 hw/mem/nvdimm.c                     |  23 ++-
 hw/mem/pc-dimm.c                    |  21 +--
 hw/microblaze/xlnx-zynqmp-pmu.c     |  11 +-
 hw/mips/cps.c                       |  45 +++---
 hw/misc/arm11scu.c                  |   1 +
 hw/misc/bcm2835_mbox.c              |   5 +-
 hw/misc/bcm2835_property.c          |   9 +-
 hw/misc/ivshmem.c                   |  33 ++---
 hw/misc/macio/macio.c               |  65 ++++----
 hw/misc/mps2-scc.c                  |   1 +
 hw/misc/tmp105.c                    |   6 +-
 hw/misc/tmp421.c                    |   6 +-
 hw/net/dp8393x.c                    |   6 +-
 hw/net/eepro100.c                   |   6 +-
 hw/net/ne2000-isa.c                 |  16 +-
 hw/net/xilinx_axienet.c             |  14 +-
 hw/nvram/fw_cfg.c                   |  12 +-
 hw/nvram/nrf51_nvm.c                |   6 +-
 hw/pci-bridge/dec.c                 |   1 +
 hw/pci-bridge/gen_pcie_root_port.c  |   6 +-
 hw/pci-bridge/pci_bridge_dev.c      |  12 +-
 hw/pci-bridge/pci_expander_bridge.c |   6 +-
 hw/pci-bridge/pcie_pci_bridge.c     |   7 +-
 hw/pci-host/piix.c                  |   6 +-
 hw/pci/pci.c                        |  17 +--
 hw/pci/pcie.c                       |   6 +-
 hw/pci/shpc.c                       |  12 +-
 hw/ppc/e500.c                       |   6 +-
 hw/ppc/pnv.c                        |  92 +++++-------
 hw/ppc/pnv_core.c                   |  21 +--
 hw/ppc/pnv_lpc.c                    |  22 +--
 hw/ppc/pnv_occ.c                    |   4 +-
 hw/ppc/pnv_psi.c                    |  21 +--
 hw/ppc/spapr.c                      | 121 +++++++--------
 hw/ppc/spapr_caps.c                 |  50 +++----
 hw/ppc/spapr_cpu_core.c             |  30 ++--
 hw/ppc/spapr_drc.c                  |  44 ++----
 hw/ppc/spapr_irq.c                  |  95 +++++-------
 hw/ppc/spapr_pci.c                  |  88 +++++------
 hw/ppc/spapr_vio.c                  |  11 +-
 hw/riscv/riscv_hart.c               |   7 +-
 hw/riscv/sifive_e.c                 |   6 +-
 hw/riscv/sifive_u.c                 |  10 +-
 hw/s390x/3270-ccw.c                 |  12 +-
 hw/s390x/css-bridge.c               |   6 +-
 hw/s390x/css.c                      |   6 +-
 hw/s390x/ipl.c                      |  23 ++-
 hw/s390x/s390-ccw.c                 |  14 +-
 hw/s390x/s390-pci-bus.c             |  34 ++---
 hw/s390x/s390-skeys.c               |   6 +-
 hw/s390x/s390-virtio-ccw.c          |  10 +-
 hw/s390x/sclp.c                     |  14 +-
 hw/s390x/tod-kvm.c                  |  13 +-
 hw/s390x/virtio-ccw-crypto.c        |   6 +-
 hw/s390x/virtio-ccw-rng.c           |   6 +-
 hw/s390x/virtio-ccw.c               |  12 +-
 hw/scsi/esp-pci.c                   |   6 +-
 hw/scsi/megasas.c                   |  10 +-
 hw/scsi/mptsas.c                    |  12 +-
 hw/scsi/scsi-bus.c                  |  22 +--
 hw/scsi/scsi-disk.c                 |   6 +-
 hw/scsi/vhost-scsi.c                |  11 +-
 hw/scsi/vhost-user-scsi.c           |   6 +-
 hw/scsi/virtio-scsi.c               |   6 +-
 hw/sd/milkymist-memcard.c           |  10 +-
 hw/sd/sdhci-pci.c                   |   6 +-
 hw/sd/sdhci.c                       |  20 +--
 hw/sd/ssi-sd.c                      |  13 +-
 hw/smbios/smbios.c                  |  41 ++----
 hw/sparc/sun4m.c                    |  18 +--
 hw/sparc64/sun4u.c                  |   6 +-
 hw/timer/aspeed_timer.c             |   6 +-
 hw/tpm/tpm_util.c                   |   6 +-
 hw/usb/bus.c                        |  33 ++---
 hw/usb/dev-serial.c                 |   6 +-
 hw/usb/dev-smartcard-reader.c       |  12 +-
 hw/usb/dev-storage.c                |  16 +-
 hw/usb/hcd-ohci-pci.c               |   6 +-
 hw/usb/hcd-ohci.c                   |  12 +-
 hw/usb/hcd-uhci.c                   |   6 +-
 hw/usb/hcd-xhci.c                   |  12 +-
 hw/vfio/ap.c                        |   6 +-
 hw/vfio/ccw.c                       |  20 ++-
 hw/vfio/pci-quirks.c                |   6 +-
 hw/vfio/pci.c                       |  36 ++---
 hw/virtio/virtio-balloon.c          |  33 ++---
 hw/virtio/virtio-bus.c              |  16 +-
 hw/virtio/virtio-rng-pci.c          |   6 +-
 hw/virtio/virtio-rng.c              |   6 +-
 hw/virtio/virtio.c                  |  17 +--
 hw/watchdog/wdt_aspeed.c            |   4 +-
 hw/xen/xen-backend.c                |   6 +-
 hw/xen/xen-bus.c                    |  85 +++++------
 hw/xen/xen-host-pci-device.c        |  26 ++--
 hw/xen/xen_pt.c                     |  24 ++-
 hw/xen/xen_pt_config_init.c         |  19 ++-
 io/dns-resolver.c                   |   6 +-
 io/net-listener.c                   |   6 +-
 iothread.c                          |  25 ++--
 job.c                               |   6 +-
 memory.c                            |  54 +++----
 memory_mapping.c                    |   6 +-
 migration/colo.c                    |  33 ++---
 migration/migration.c               |  35 ++---
 migration/ram.c                     |  12 +-
 migration/rdma.c                    |  11 +-
 migration/socket.c                  |  16 +-
 monitor/misc.c                      |   8 +-
 monitor/qmp-cmds.c                  |   6 +-
 net/can/can_host.c                  |   6 +-
 net/dump.c                          |  14 +-
 net/filter-buffer.c                 |  14 +-
 net/filter.c                        |   6 +-
 net/net.c                           |  38 ++---
 net/netmap.c                        |   6 +-
 net/slirp.c                         |   6 +-
 net/tap-bsd.c                       |   1 +
 net/tap-solaris.c                   |   1 +
 net/tap-stub.c                      |   1 +
 net/tap.c                           |  44 ++----
 qapi/opts-visitor.c                 |   1 +
 qapi/qapi-dealloc-visitor.c         |   7 +
 qapi/qapi-visit-core.c              |  53 ++-----
 qapi/qmp-dispatch.c                 |   6 +-
 qapi/string-input-visitor.c         |   6 +-
 qdev-monitor.c                      |  37 ++---
 qga/commands-posix.c                | 197 ++++++++++---------------
 qga/commands-win32.c                | 127 ++++++----------
 qom/object.c                        | 187 +++++++++--------------
 qom/object_interfaces.c             |  26 ++--
 qom/qom-qobject.c                   |   6 +-
 replication.c                       |  24 +--
 scsi/pr-manager-helper.c            |   6 +-
 stubs/xen-hvm.c                     |   2 +
 target/alpha/cpu.c                  |   6 +-
 target/arm/cpu.c                    |   6 +-
 target/arm/cpu64.c                  |  10 +-
 target/cris/cpu.c                   |   6 +-
 target/hppa/cpu.c                   |   6 +-
 target/i386/cpu.c                   | 107 ++++++--------
 target/lm32/cpu.c                   |   6 +-
 target/m68k/cpu.c                   |   6 +-
 target/microblaze/cpu.c             |   6 +-
 target/mips/cpu.c                   |   6 +-
 target/moxie/cpu.c                  |   6 +-
 target/nios2/cpu.c                  |   6 +-
 target/openrisc/cpu.c               |   6 +-
 target/ppc/compat.c                 |  18 +--
 target/ppc/kvm.c                    |   6 +-
 target/ppc/translate_init.inc.c     |  23 +--
 target/riscv/cpu.c                  |   6 +-
 target/s390x/cpu.c                  |  25 ++--
 target/s390x/kvm-stub.c             |   1 +
 target/sh4/cpu.c                    |   6 +-
 target/sparc/cpu.c                  |  12 +-
 target/tilegx/cpu.c                 |   6 +-
 target/tricore/cpu.c                |   6 +-
 target/unicore32/cpu.c              |   6 +-
 target/xtensa/cpu.c                 |   6 +-
 tests/test-image-locking.c          |   6 +-
 tests/test-qmp-cmds.c               |   7 +
 tpm.c                               |   6 +-
 trace/qmp.c                         |  12 +-
 ui/input-barrier.c                  |   6 +-
 ui/input.c                          |  12 +-
 ui/vnc.c                            |  17 +--
 util/main-loop.c                    |   4 +-
 util/oslib-posix.c                  |   5 +-
 util/qemu-config.c                  |  27 ++--
 util/qemu-option.c                  |  50 +++----
 util/qemu-sockets.c                 |  25 +---
 vl.c                                |  13 +-
 312 files changed, 2551 insertions(+), 4199 deletions(-)

diff --git a/include/hw/pci-host/spapr.h b/include/hw/pci-host/spapr.h
index abd87605b2..3498635302 100644
--- a/include/hw/pci-host/spapr.h
+++ b/include/hw/pci-host/spapr.h
@@ -193,6 +193,7 @@ static inline void spapr_phb_vfio_reset(DeviceState *qdev)
 }
 static inline void spapr_phb_nvgpu_setup(SpaprPhbState *sphb, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 static inline void spapr_phb_nvgpu_free(SpaprPhbState *sphb)
 {
@@ -200,6 +201,7 @@ static inline void spapr_phb_nvgpu_free(SpaprPhbState *sphb)
 static inline void spapr_phb_nvgpu_populate_dt(SpaprPhbState *sphb, void *fdt,
                                                int bus_off, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 static inline void spapr_phb_nvgpu_ram_populate_dt(SpaprPhbState *sphb,
                                                    void *fdt)
diff --git a/target/ppc/kvm_ppc.h b/target/ppc/kvm_ppc.h
index 98bd7d5da6..807c245e90 100644
--- a/target/ppc/kvm_ppc.h
+++ b/target/ppc/kvm_ppc.h
@@ -254,6 +254,7 @@ static inline bool kvmppc_hpt_needs_host_contiguous_pages(void)
 
 static inline void kvm_check_mmu(PowerPCCPU *cpu, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static inline bool kvmppc_has_cap_spapr_vfio(void)
diff --git a/target/s390x/cpu_models.h b/target/s390x/cpu_models.h
index 88bd01a616..5329045a71 100644
--- a/target/s390x/cpu_models.h
+++ b/target/s390x/cpu_models.h
@@ -114,10 +114,12 @@ void kvm_s390_apply_cpu_model(const S390CPUModel *model,  Error **errp);
 static inline void kvm_s390_get_host_cpu_model(S390CPUModel *model,
                                                Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 static inline void kvm_s390_apply_cpu_model(const S390CPUModel *model,
                                             Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 static inline bool kvm_s390_cpu_models_supported(void)
 {
diff --git a/audio/audio.c b/audio/audio.c
index e99fcd0694..bc5dd86522 100644
--- a/audio/audio.c
+++ b/audio/audio.c
@@ -1739,19 +1739,15 @@ static void audio_validate_per_direction_opts(
 
 static void audio_validate_opts(Audiodev *dev, Error **errp)
 {
-    Error *err = NULL;
-
     audio_create_pdos(dev);
 
-    audio_validate_per_direction_opts(audio_get_pdo_in(dev), &err);
-    if (err) {
-        error_propagate(errp, err);
+    audio_validate_per_direction_opts(audio_get_pdo_in(dev), errp);
+    if (*errp) {
         return;
     }
 
-    audio_validate_per_direction_opts(audio_get_pdo_out(dev), &err);
-    if (err) {
-        error_propagate(errp, err);
+    audio_validate_per_direction_opts(audio_get_pdo_out(dev), errp);
+    if (*errp) {
         return;
     }
 
diff --git a/authz/pamacct.c b/authz/pamacct.c
index a8ad25b6c7..bf903b6736 100644
--- a/authz/pamacct.c
+++ b/authz/pamacct.c
@@ -84,6 +84,7 @@ qauthz_pam_prop_get_service(Object *obj,
 static void
 qauthz_pam_complete(UserCreatable *uc, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 
diff --git a/backends/cryptodev-vhost-user.c b/backends/cryptodev-vhost-user.c
index b344283940..db32391df0 100644
--- a/backends/cryptodev-vhost-user.c
+++ b/backends/cryptodev-vhost-user.c
@@ -179,15 +179,13 @@ static void cryptodev_vhost_user_init(
 {
     int queues = backend->conf.peers.queues;
     size_t i;
-    Error *local_err = NULL;
     Chardev *chr;
     CryptoDevBackendClient *cc;
     CryptoDevBackendVhostUser *s =
                       CRYPTODEV_BACKEND_VHOST_USER(backend);
 
-    chr = cryptodev_vhost_claim_chardev(s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    chr = cryptodev_vhost_claim_chardev(s, errp);
+    if (*errp) {
         return;
     }
 
@@ -204,8 +202,7 @@ static void cryptodev_vhost_user_init(
         backend->conf.peers.ccs[i] = cc;
 
         if (i == 0) {
-            if (!qemu_chr_fe_init(&s->chr, chr, &local_err)) {
-                error_propagate(errp, local_err);
+            if (!qemu_chr_fe_init(&s->chr, chr, errp)) {
                 return;
             }
         }
diff --git a/backends/cryptodev.c b/backends/cryptodev.c
index 3c071eab95..dcdb8481b2 100644
--- a/backends/cryptodev.c
+++ b/backends/cryptodev.c
@@ -154,21 +154,18 @@ cryptodev_backend_set_queues(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
 {
     CryptoDevBackend *backend = CRYPTODEV_BACKEND(obj);
-    Error *local_err = NULL;
     uint32_t value;
 
-    visit_type_uint32(v, name, &value, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_uint32(v, name, &value, errp);
+    if (*errp) {
+        return;
     }
     if (!value) {
-        error_setg(&local_err, "Property '%s.%s' doesn't take value '%"
+        error_setg(errp, "Property '%s.%s' doesn't take value '%"
                    PRIu32 "'", object_get_typename(obj), name, value);
-        goto out;
+        return;
     }
     backend->conf.peers.queues = value;
-out:
-    error_propagate(errp, local_err);
 }
 
 static void
@@ -176,11 +173,10 @@ cryptodev_backend_complete(UserCreatable *uc, Error **errp)
 {
     CryptoDevBackend *backend = CRYPTODEV_BACKEND(uc);
     CryptoDevBackendClass *bc = CRYPTODEV_BACKEND_GET_CLASS(uc);
-    Error *local_err = NULL;
 
     if (bc->init) {
-        bc->init(backend, &local_err);
-        if (local_err) {
+        bc->init(backend, errp);
+        if (*errp) {
             goto out;
         }
     }
@@ -188,7 +184,6 @@ cryptodev_backend_complete(UserCreatable *uc, Error **errp)
     return;
 
 out:
-    error_propagate(errp, local_err);
 }
 
 void cryptodev_backend_set_used(CryptoDevBackend *backend, bool used)
diff --git a/backends/hostmem-file.c b/backends/hostmem-file.c
index be64020746..c59c92a031 100644
--- a/backends/hostmem-file.c
+++ b/backends/hostmem-file.c
@@ -118,23 +118,19 @@ static void file_memory_backend_set_align(Object *o, Visitor *v,
 {
     HostMemoryBackend *backend = MEMORY_BACKEND(o);
     HostMemoryBackendFile *fb = MEMORY_BACKEND_FILE(o);
-    Error *local_err = NULL;
     uint64_t val;
 
     if (host_memory_backend_mr_inited(backend)) {
-        error_setg(&local_err, "cannot change property '%s' of %s",
+        error_setg(errp, "cannot change property '%s' of %s",
                    name, object_get_typename(o));
-        goto out;
+        return;
     }
 
-    visit_type_size(v, name, &val, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_size(v, name, &val, errp);
+    if (*errp) {
+        return;
     }
     fb->align = val;
-
- out:
-    error_propagate(errp, local_err);
 }
 
 static bool file_memory_backend_get_pmem(Object *o, Error **errp)
@@ -156,13 +152,10 @@ static void file_memory_backend_set_pmem(Object *o, bool value, Error **errp)
 
 #ifndef CONFIG_LIBPMEM
     if (value) {
-        Error *local_err = NULL;
-
-        error_setg(&local_err,
+        error_setg(errp,
                    "Lack of libpmem support while setting the 'pmem=on'"
                    " of %s. We can't ensure data persistence.",
                    object_get_typename(o));
-        error_propagate(errp, local_err);
         return;
     }
 #endif
diff --git a/backends/hostmem-memfd.c b/backends/hostmem-memfd.c
index 26070b425e..2de7e8687b 100644
--- a/backends/hostmem-memfd.c
+++ b/backends/hostmem-memfd.c
@@ -78,26 +78,23 @@ memfd_backend_set_hugetlbsize(Object *obj, Visitor *v, const char *name,
                               void *opaque, Error **errp)
 {
     HostMemoryBackendMemfd *m = MEMORY_BACKEND_MEMFD(obj);
-    Error *local_err = NULL;
     uint64_t value;
 
     if (host_memory_backend_mr_inited(MEMORY_BACKEND(obj))) {
-        error_setg(&local_err, "cannot change property value");
-        goto out;
+        error_setg(errp, "cannot change property value");
+        return;
     }
 
-    visit_type_size(v, name, &value, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_size(v, name, &value, errp);
+    if (*errp) {
+        return;
     }
     if (!value) {
-        error_setg(&local_err, "Property '%s.%s' doesn't take value '%"
+        error_setg(errp, "Property '%s.%s' doesn't take value '%"
                    PRIu64 "'", object_get_typename(obj), name, value);
-        goto out;
+        return;
     }
     m->hugetlbsize = value;
-out:
-    error_propagate(errp, local_err);
 }
 
 static void
diff --git a/backends/hostmem.c b/backends/hostmem.c
index 6d333dc23c..47ff08e770 100644
--- a/backends/hostmem.c
+++ b/backends/hostmem.c
@@ -54,28 +54,25 @@ host_memory_backend_set_size(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
 {
     HostMemoryBackend *backend = MEMORY_BACKEND(obj);
-    Error *local_err = NULL;
     uint64_t value;
 
     if (host_memory_backend_mr_inited(backend)) {
-        error_setg(&local_err, "cannot change property %s of %s ",
+        error_setg(errp, "cannot change property %s of %s ",
                    name, object_get_typename(obj));
-        goto out;
+        return;
     }
 
-    visit_type_size(v, name, &value, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_size(v, name, &value, errp);
+    if (*errp) {
+        return;
     }
     if (!value) {
-        error_setg(&local_err,
+        error_setg(errp,
                    "property '%s' of %s doesn't take value '%" PRIu64 "'",
                    name, object_get_typename(obj), value);
-        goto out;
+        return;
     }
     backend->size = value;
-out:
-    error_propagate(errp, local_err);
 }
 
 static void
@@ -221,7 +218,6 @@ static bool host_memory_backend_get_prealloc(Object *obj, Error **errp)
 static void host_memory_backend_set_prealloc(Object *obj, bool value,
                                              Error **errp)
 {
-    Error *local_err = NULL;
     HostMemoryBackend *backend = MEMORY_BACKEND(obj);
     MachineState *ms = MACHINE(qdev_get_machine());
 
@@ -243,9 +239,8 @@ static void host_memory_backend_set_prealloc(Object *obj, bool value,
         void *ptr = memory_region_get_ram_ptr(&backend->mr);
         uint64_t sz = memory_region_size(&backend->mr);
 
-        os_mem_prealloc(fd, ptr, sz, ms->smp.cpus, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        os_mem_prealloc(fd, ptr, sz, ms->smp.cpus, errp);
+        if (*errp) {
             return;
         }
         backend->prealloc = true;
@@ -314,14 +309,13 @@ host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
     HostMemoryBackend *backend = MEMORY_BACKEND(uc);
     HostMemoryBackendClass *bc = MEMORY_BACKEND_GET_CLASS(uc);
     MachineState *ms = MACHINE(qdev_get_machine());
-    Error *local_err = NULL;
     void *ptr;
     uint64_t sz;
 
     if (bc->alloc) {
-        bc->alloc(backend, &local_err);
-        if (local_err) {
-            goto out;
+        bc->alloc(backend, errp);
+        if (*errp) {
+            return;
         }
 
         ptr = memory_region_get_ram_ptr(&backend->mr);
@@ -378,14 +372,12 @@ host_memory_backend_memory_complete(UserCreatable *uc, Error **errp)
          */
         if (backend->prealloc) {
             os_mem_prealloc(memory_region_get_fd(&backend->mr), ptr, sz,
-                            ms->smp.cpus, &local_err);
-            if (local_err) {
-                goto out;
+                            ms->smp.cpus, errp);
+            if (*errp) {
+                return;
             }
         }
     }
-out:
-    error_propagate(errp, local_err);
 }
 
 static bool
diff --git a/backends/rng.c b/backends/rng.c
index 391888b8b3..76e8097a66 100644
--- a/backends/rng.c
+++ b/backends/rng.c
@@ -55,7 +55,6 @@ static void rng_backend_prop_set_opened(Object *obj, bool value, Error **errp)
 {
     RngBackend *s = RNG_BACKEND(obj);
     RngBackendClass *k = RNG_BACKEND_GET_CLASS(s);
-    Error *local_err = NULL;
 
     if (value == s->opened) {
         return;
@@ -67,9 +66,8 @@ static void rng_backend_prop_set_opened(Object *obj, bool value, Error **errp)
     }
 
     if (k->opened) {
-        k->opened(s, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        k->opened(s, errp);
+        if (*errp) {
             return;
         }
     }
diff --git a/block.c b/block.c
index 5944124845..f29fd6c128 100644
--- a/block.c
+++ b/block.c
@@ -535,7 +535,6 @@ out:
 int bdrv_create_file(const char *filename, QemuOpts *opts, Error **errp)
 {
     BlockDriver *drv;
-    Error *local_err = NULL;
     int ret;
 
     drv = bdrv_find_protocol(filename, true, errp);
@@ -543,8 +542,7 @@ int bdrv_create_file(const char *filename, QemuOpts *opts, Error **errp)
         return -ENOENT;
     }
 
-    ret = bdrv_create(drv, filename, opts, &local_err);
-    error_propagate(errp, local_err);
+    ret = bdrv_create(drv, filename, opts, errp);
     return ret;
 }
 
@@ -824,14 +822,12 @@ static BlockdevDetectZeroesOptions bdrv_parse_detect_zeroes(QemuOpts *opts,
                                                             int open_flags,
                                                             Error **errp)
 {
-    Error *local_err = NULL;
     char *value = qemu_opt_get_del(opts, "detect-zeroes");
     BlockdevDetectZeroesOptions detect_zeroes =
         qapi_enum_parse(&BlockdevDetectZeroesOptions_lookup, value,
-                        BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF, &local_err);
+                        BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF, errp);
     g_free(value);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return detect_zeroes;
     }
 
@@ -1275,12 +1271,10 @@ static int bdrv_open_driver(BlockDriverState *bs, BlockDriver *drv,
                             const char *node_name, QDict *options,
                             int open_flags, Error **errp)
 {
-    Error *local_err = NULL;
     int i, ret;
 
-    bdrv_assign_node_name(bs, node_name, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    bdrv_assign_node_name(bs, node_name, errp);
+    if (*errp) {
         return -EINVAL;
     }
 
@@ -1290,16 +1284,15 @@ static int bdrv_open_driver(BlockDriverState *bs, BlockDriver *drv,
 
     if (drv->bdrv_file_open) {
         assert(!drv->bdrv_needs_filename || bs->filename[0]);
-        ret = drv->bdrv_file_open(bs, options, open_flags, &local_err);
+        ret = drv->bdrv_file_open(bs, options, open_flags, errp);
     } else if (drv->bdrv_open) {
-        ret = drv->bdrv_open(bs, options, open_flags, &local_err);
+        ret = drv->bdrv_open(bs, options, open_flags, errp);
     } else {
         ret = 0;
     }
 
     if (ret < 0) {
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
         } else if (bs->filename[0]) {
             error_setg_errno(errp, -ret, "Could not open '%s'", bs->filename);
         } else {
@@ -1314,9 +1307,8 @@ static int bdrv_open_driver(BlockDriverState *bs, BlockDriver *drv,
         return ret;
     }
 
-    bdrv_refresh_limits(bs, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    bdrv_refresh_limits(bs, errp);
+    if (*errp) {
         return -EINVAL;
     }
 
@@ -1437,15 +1429,13 @@ static int bdrv_open_common(BlockDriverState *bs, BlockBackend *file,
     const char *discard;
     QemuOpts *opts;
     BlockDriver *drv;
-    Error *local_err = NULL;
 
     assert(bs->file == NULL);
     assert(options != NULL && bs->options != options);
 
     opts = qemu_opts_create(&bdrv_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail_opts;
     }
@@ -1531,9 +1521,8 @@ static int bdrv_open_common(BlockDriverState *bs, BlockBackend *file,
     }
 
     bs->detect_zeroes =
-        bdrv_parse_detect_zeroes(opts, bs->open_flags, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+        bdrv_parse_detect_zeroes(opts, bs->open_flags, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail_opts;
     }
@@ -1594,16 +1583,14 @@ static void parse_json_protocol(QDict *options, const char **pfilename,
                                 Error **errp)
 {
     QDict *json_options;
-    Error *local_err = NULL;
 
     /* Parse json: pseudo-protocol */
     if (!*pfilename || !g_str_has_prefix(*pfilename, "json:")) {
         return;
     }
 
-    json_options = parse_json_filename(*pfilename, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    json_options = parse_json_filename(*pfilename, errp);
+    if (*errp) {
         return;
     }
 
@@ -1627,7 +1614,6 @@ static int bdrv_fill_options(QDict **options, const char *filename,
     bool protocol = *flags & BDRV_O_PROTOCOL;
     bool parse_filename = false;
     BlockDriver *drv = NULL;
-    Error *local_err = NULL;
 
     /*
      * Caution: while qdict_get_try_str() is fine, getting non-string
@@ -1692,9 +1678,8 @@ static int bdrv_fill_options(QDict **options, const char *filename,
 
     /* Driver-specific filename parsing */
     if (drv && drv->bdrv_parse_filename && parse_filename) {
-        drv->bdrv_parse_filename(filename, *options, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        drv->bdrv_parse_filename(filename, *options, errp);
+        if (*errp) {
             return -EINVAL;
         }
 
@@ -2123,16 +2108,14 @@ static void bdrv_child_abort_perm_update(BdrvChild *c)
 int bdrv_child_try_set_perm(BdrvChild *c, uint64_t perm, uint64_t shared,
                             Error **errp)
 {
-    Error *local_err = NULL;
     int ret;
     bool tighten_restrictions;
 
     ret = bdrv_child_check_perm(c, NULL, perm, shared, NULL,
-                                &tighten_restrictions, &local_err);
+                                &tighten_restrictions, errp);
     if (ret < 0) {
         bdrv_child_abort_perm_update(c);
         if (tighten_restrictions) {
-            error_propagate(errp, local_err);
         } else {
             /*
              * Our caller may intend to only loosen restrictions and
@@ -2140,7 +2123,7 @@ int bdrv_child_try_set_perm(BdrvChild *c, uint64_t perm, uint64_t shared,
              * fatal in such a case, so we can just hide them from our
              * caller.
              */
-            error_free(local_err);
+            error_free_errp(errp);
             ret = 0;
         }
         return ret;
@@ -2367,7 +2350,6 @@ BdrvChild *bdrv_root_attach_child(BlockDriverState *child_bs,
                                   void *opaque, Error **errp)
 {
     BdrvChild *child;
-    Error *local_err = NULL;
     int ret;
 
     ret = bdrv_check_update_perm(child_bs, NULL, perm, shared_perm, NULL, NULL,
@@ -2392,12 +2374,12 @@ BdrvChild *bdrv_root_attach_child(BlockDriverState *child_bs,
      * child_bs into the AioContext of the new parent. If this doesn't work,
      * try moving the parent into the AioContext of child_bs instead. */
     if (bdrv_get_aio_context(child_bs) != ctx) {
-        ret = bdrv_try_set_aio_context(child_bs, ctx, &local_err);
+        ret = bdrv_try_set_aio_context(child_bs, ctx, errp);
         if (ret < 0 && child_role->can_set_aio_ctx) {
             GSList *ignore = g_slist_prepend(NULL, child);;
             ctx = bdrv_get_aio_context(child_bs);
             if (child_role->can_set_aio_ctx(child, ctx, &ignore, NULL)) {
-                error_free(local_err);
+                error_free_errp(errp);
                 ret = 0;
                 g_slist_free(ignore);
                 ignore = g_slist_prepend(NULL, child);;
@@ -2406,7 +2388,6 @@ BdrvChild *bdrv_root_attach_child(BlockDriverState *child_bs,
             g_slist_free(ignore);
         }
         if (ret < 0) {
-            error_propagate(errp, local_err);
             g_free(child);
             bdrv_abort_perm_update(child_bs);
             return NULL;
@@ -2600,7 +2581,6 @@ int bdrv_open_backing_file(BlockDriverState *bs, QDict *parent_options,
     BlockDriverState *backing_hd;
     QDict *options;
     QDict *tmp_parent_options = NULL;
-    Error *local_err = NULL;
 
     if (bs->backing != NULL) {
         goto free_exit;
@@ -2642,10 +2622,9 @@ int bdrv_open_backing_file(BlockDriverState *bs, QDict *parent_options,
             implicit_backing = !strcmp(bs->auto_backing_file, bs->backing_file);
         }
 
-        backing_filename = bdrv_get_full_backing_filename(bs, &local_err);
-        if (local_err) {
+        backing_filename = bdrv_get_full_backing_filename(bs, errp);
+        if (*errp) {
             ret = -EINVAL;
-            error_propagate(errp, local_err);
             qobject_unref(options);
             goto free_exit;
         }
@@ -2680,10 +2659,9 @@ int bdrv_open_backing_file(BlockDriverState *bs, QDict *parent_options,
 
     /* Hook up the backing file link; drop our reference, bs owns the
      * backing_hd reference now */
-    bdrv_set_backing_hd(bs, backing_hd, &local_err);
+    bdrv_set_backing_hd(bs, backing_hd, errp);
     bdrv_unref(backing_hd);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto free_exit;
     }
@@ -2776,7 +2754,6 @@ BdrvChild *bdrv_open_child(const char *filename,
 BlockDriverState *bdrv_open_blockdev_ref(BlockdevRef *ref, Error **errp)
 {
     BlockDriverState *bs = NULL;
-    Error *local_err = NULL;
     QObject *obj = NULL;
     QDict *qdict = NULL;
     const char *reference = NULL;
@@ -2789,9 +2766,8 @@ BlockDriverState *bdrv_open_blockdev_ref(BlockdevRef *ref, Error **errp)
         assert(ref->type == QTYPE_QDICT);
 
         v = qobject_output_visitor_new(&obj);
-        visit_type_BlockdevOptions(v, NULL, &options, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        visit_type_BlockdevOptions(v, NULL, &options, errp);
+        if (*errp) {
             goto fail;
         }
         visit_complete(v, &obj);
@@ -2828,7 +2804,6 @@ static BlockDriverState *bdrv_append_temp_snapshot(BlockDriverState *bs,
     int64_t total_size;
     QemuOpts *opts = NULL;
     BlockDriverState *bs_snapshot = NULL;
-    Error *local_err = NULL;
     int ret;
 
     /* if snapshot, we create a temporary backing file and open it
@@ -2875,9 +2850,8 @@ static BlockDriverState *bdrv_append_temp_snapshot(BlockDriverState *bs,
      * order to be able to return one, we have to increase
      * bs_snapshot's refcount here */
     bdrv_ref(bs_snapshot);
-    bdrv_append(bs_snapshot, bs, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    bdrv_append(bs_snapshot, bs, errp);
+    if (*errp) {
         bs_snapshot = NULL;
         goto out;
     }
@@ -2917,7 +2891,6 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
     BdrvChild *child;
     const char *drvname;
     const char *backing;
-    Error *local_err = NULL;
     QDict *snapshot_options = NULL;
     int snapshot_flags = 0;
 
@@ -2951,8 +2924,8 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
     }
 
     /* json: syntax counts as explicit options, as if in the QDict */
-    parse_json_protocol(options, &filename, &local_err);
-    if (local_err) {
+    parse_json_protocol(options, &filename, errp);
+    if (*errp) {
         goto fail;
     }
 
@@ -2964,8 +2937,8 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
                                     parent->open_flags, parent->options);
     }
 
-    ret = bdrv_fill_options(&options, filename, &flags, &local_err);
-    if (local_err) {
+    ret = bdrv_fill_options(&options, filename, &flags, errp);
+    if (*errp) {
         goto fail;
     }
 
@@ -3029,8 +3002,8 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
         BlockDriverState *file_bs;
 
         file_bs = bdrv_open_child_bs(filename, options, "file", bs,
-                                     &child_file, true, &local_err);
-        if (local_err) {
+                                     &child_file, true, errp);
+        if (*errp) {
             goto fail;
         }
         if (file_bs != NULL) {
@@ -3038,9 +3011,9 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
              * looking at the header to guess the image format. This works even
              * in cases where a guest would not see a consistent state. */
             file = blk_new(bdrv_get_aio_context(file_bs), 0, BLK_PERM_ALL);
-            blk_insert_bs(file, file_bs, &local_err);
+            blk_insert_bs(file, file_bs, errp);
             bdrv_unref(file_bs);
-            if (local_err) {
+            if (*errp) {
                 goto fail;
             }
 
@@ -3051,7 +3024,7 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
     /* Image format probing */
     bs->probed = !drv;
     if (!drv && file) {
-        ret = find_image_format(file, filename, &drv, &local_err);
+        ret = find_image_format(file, filename, &drv, errp);
         if (ret < 0) {
             goto fail;
         }
@@ -3080,7 +3053,7 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
     assert(!(flags & BDRV_O_PROTOCOL) || !file);
 
     /* Open the image */
-    ret = bdrv_open_common(bs, file, options, &local_err);
+    ret = bdrv_open_common(bs, file, options, errp);
     if (ret < 0) {
         goto fail;
     }
@@ -3092,7 +3065,7 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
 
     /* If there is a backing file, use it */
     if ((flags & BDRV_O_NO_BACKING) == 0) {
-        ret = bdrv_open_backing_file(bs, options, "backing", &local_err);
+        ret = bdrv_open_backing_file(bs, options, "backing", errp);
         if (ret < 0) {
             goto close_and_fail;
         }
@@ -3135,9 +3108,9 @@ static BlockDriverState *bdrv_open_inherit(const char *filename,
     if (snapshot_flags) {
         BlockDriverState *snapshot_bs;
         snapshot_bs = bdrv_append_temp_snapshot(bs, snapshot_flags,
-                                                snapshot_options, &local_err);
+                                                snapshot_options, errp);
         snapshot_options = NULL;
-        if (local_err) {
+        if (*errp) {
             goto close_and_fail;
         }
         /* We are not going to return bs but the overlay on top of it
@@ -3159,14 +3132,12 @@ fail:
     bs->options = NULL;
     bs->explicit_options = NULL;
     bdrv_unref(bs);
-    error_propagate(errp, local_err);
     return NULL;
 
 close_and_fail:
     bdrv_unref(bs);
     qobject_unref(snapshot_options);
     qobject_unref(options);
-    error_propagate(errp, local_err);
     return NULL;
 }
 
@@ -3711,7 +3682,6 @@ int bdrv_reopen_prepare(BDRVReopenState *reopen_state, BlockReopenQueue *queue,
 {
     int ret = -1;
     int old_flags;
-    Error *local_err = NULL;
     BlockDriver *drv;
     QemuOpts *opts;
     QDict *orig_reopen_opts;
@@ -3730,9 +3700,8 @@ int bdrv_reopen_prepare(BDRVReopenState *reopen_state, BlockReopenQueue *queue,
 
     /* Process generic block layer options */
     opts = qemu_opts_create(&bdrv_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, reopen_state->options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, reopen_state->options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto error;
     }
@@ -3754,9 +3723,8 @@ int bdrv_reopen_prepare(BDRVReopenState *reopen_state, BlockReopenQueue *queue,
     }
 
     reopen_state->detect_zeroes =
-        bdrv_parse_detect_zeroes(opts, reopen_state->flags, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+        bdrv_parse_detect_zeroes(opts, reopen_state->flags, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto error;
     }
@@ -3770,9 +3738,8 @@ int bdrv_reopen_prepare(BDRVReopenState *reopen_state, BlockReopenQueue *queue,
      * to r/w. Attempting to set to r/w may fail if either BDRV_O_ALLOW_RDWR is
      * not set, or if the BDS still has copy_on_read enabled */
     read_only = !(reopen_state->flags & BDRV_O_RDWR);
-    ret = bdrv_can_set_read_only(reopen_state->bs, read_only, true, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ret = bdrv_can_set_read_only(reopen_state->bs, read_only, true, errp);
+    if (*errp) {
         goto error;
     }
 
@@ -3798,10 +3765,9 @@ int bdrv_reopen_prepare(BDRVReopenState *reopen_state, BlockReopenQueue *queue,
             goto error;
         }
 
-        ret = drv->bdrv_reopen_prepare(reopen_state, queue, &local_err);
+        ret = drv->bdrv_reopen_prepare(reopen_state, queue, errp);
         if (ret) {
-            if (local_err != NULL) {
-                error_propagate(errp, local_err);
+            if (*errp != NULL) {
             } else {
                 bdrv_refresh_filename(reopen_state->bs);
                 error_setg(errp, "failed while preparing to reopen image '%s'",
@@ -4238,17 +4204,13 @@ out:
 void bdrv_append(BlockDriverState *bs_new, BlockDriverState *bs_top,
                  Error **errp)
 {
-    Error *local_err = NULL;
-
-    bdrv_set_backing_hd(bs_new, bs_top, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    bdrv_set_backing_hd(bs_new, bs_top, errp);
+    if (*errp) {
         goto out;
     }
 
-    bdrv_replace_node(bs_top, bs_new, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    bdrv_replace_node(bs_top, bs_new, errp);
+    if (*errp) {
         bdrv_set_backing_hd(bs_new, NULL, &error_abort);
         goto out;
     }
@@ -5311,7 +5273,6 @@ static void coroutine_fn bdrv_co_invalidate_cache(BlockDriverState *bs,
 {
     BdrvChild *child, *parent;
     uint64_t perm, shared_perm;
-    Error *local_err = NULL;
     int ret;
     BdrvDirtyBitmap *bm;
 
@@ -5324,9 +5285,8 @@ static void coroutine_fn bdrv_co_invalidate_cache(BlockDriverState *bs,
     }
 
     QLIST_FOREACH(child, &bs->children, next) {
-        bdrv_co_invalidate_cache(child->bs, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        bdrv_co_invalidate_cache(child->bs, errp);
+        if (*errp) {
             return;
         }
     }
@@ -5346,19 +5306,17 @@ static void coroutine_fn bdrv_co_invalidate_cache(BlockDriverState *bs,
      */
     bs->open_flags &= ~BDRV_O_INACTIVE;
     bdrv_get_cumulative_perm(bs, &perm, &shared_perm);
-    ret = bdrv_check_perm(bs, NULL, perm, shared_perm, NULL, NULL, &local_err);
+    ret = bdrv_check_perm(bs, NULL, perm, shared_perm, NULL, NULL, errp);
     if (ret < 0) {
         bs->open_flags |= BDRV_O_INACTIVE;
-        error_propagate(errp, local_err);
         return;
     }
     bdrv_set_perm(bs, perm, shared_perm);
 
     if (bs->drv->bdrv_co_invalidate_cache) {
-        bs->drv->bdrv_co_invalidate_cache(bs, &local_err);
-        if (local_err) {
+        bs->drv->bdrv_co_invalidate_cache(bs, errp);
+        if (*errp) {
             bs->open_flags |= BDRV_O_INACTIVE;
-            error_propagate(errp, local_err);
             return;
         }
     }
@@ -5378,10 +5336,9 @@ static void coroutine_fn bdrv_co_invalidate_cache(BlockDriverState *bs,
 
     QLIST_FOREACH(parent, &bs->parents, next_parent) {
         if (parent->role->activate) {
-            parent->role->activate(parent, &local_err);
-            if (local_err) {
+            parent->role->activate(parent, errp);
+            if (*errp) {
                 bs->open_flags |= BDRV_O_INACTIVE;
-                error_propagate(errp, local_err);
                 return;
             }
         }
@@ -5424,17 +5381,15 @@ void bdrv_invalidate_cache(BlockDriverState *bs, Error **errp)
 void bdrv_invalidate_cache_all(Error **errp)
 {
     BlockDriverState *bs;
-    Error *local_err = NULL;
     BdrvNextIterator it;
 
     for (bs = bdrv_first(&it); bs; bs = bdrv_next(&it)) {
         AioContext *aio_context = bdrv_get_aio_context(bs);
 
         aio_context_acquire(aio_context);
-        bdrv_invalidate_cache(bs, &local_err);
+        bdrv_invalidate_cache(bs, errp);
         aio_context_release(aio_context);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             bdrv_next_cleanup(&it);
             return;
         }
@@ -5710,7 +5665,6 @@ void bdrv_img_create(const char *filename, const char *fmt,
     const char *backing_fmt, *backing_file;
     int64_t size;
     BlockDriver *drv, *proto_drv;
-    Error *local_err = NULL;
     int ret = 0;
 
     /* Find driver and parse its options */
@@ -5746,15 +5700,15 @@ void bdrv_img_create(const char *filename, const char *fmt,
 
     /* Parse -o options */
     if (options) {
-        qemu_opts_do_parse(opts, options, NULL, &local_err);
-        if (local_err) {
+        qemu_opts_do_parse(opts, options, NULL, errp);
+        if (*errp) {
             goto out;
         }
     }
 
     if (base_filename) {
-        qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename, &local_err);
-        if (local_err) {
+        qemu_opt_set(opts, BLOCK_OPT_BACKING_FILE, base_filename, errp);
+        if (*errp) {
             error_setg(errp, "Backing file not supported for file format '%s'",
                        fmt);
             goto out;
@@ -5762,8 +5716,8 @@ void bdrv_img_create(const char *filename, const char *fmt,
     }
 
     if (base_fmt) {
-        qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt, &local_err);
-        if (local_err) {
+        qemu_opt_set(opts, BLOCK_OPT_BACKING_FMT, base_fmt, errp);
+        if (*errp) {
             error_setg(errp, "Backing file format not supported for file "
                              "format '%s'", fmt);
             goto out;
@@ -5792,8 +5746,8 @@ void bdrv_img_create(const char *filename, const char *fmt,
 
         full_backing =
             bdrv_get_full_backing_filename_from_filename(filename, backing_file,
-                                                         &local_err);
-        if (local_err) {
+                                                         errp);
+        if (*errp) {
             goto out;
         }
         assert(full_backing);
@@ -5809,17 +5763,17 @@ void bdrv_img_create(const char *filename, const char *fmt,
         qdict_put_bool(backing_options, BDRV_OPT_FORCE_SHARE, true);
 
         bs = bdrv_open(full_backing, NULL, backing_options, back_flags,
-                       &local_err);
+                       errp);
         g_free(full_backing);
         if (!bs && size != -1) {
             /* Couldn't open BS, but we have a size, so it's nonfatal */
-            warn_reportf_err(local_err,
-                            "Could not verify backing image. "
-                            "This may become an error in future versions.\n");
-            local_err = NULL;
+            warn_reportf_err(*errp,
+                             "Could not verify backing image. "
+                             "This may become an error in future versions.\n");
+            *errp = NULL;
         } else if (!bs) {
             /* Couldn't open bs, do not have size */
-            error_append_hint(&local_err,
+            error_append_hint(errp,
                               "Could not open backing image to determine size.\n");
             goto out;
         } else {
@@ -5849,7 +5803,7 @@ void bdrv_img_create(const char *filename, const char *fmt,
         puts("");
     }
 
-    ret = bdrv_create(drv, filename, opts, &local_err);
+    ret = bdrv_create(drv, filename, opts, errp);
 
     if (ret == -EFBIG) {
         /* This is generally a better message than whatever the driver would
@@ -5861,14 +5815,12 @@ void bdrv_img_create(const char *filename, const char *fmt,
         }
         error_setg(errp, "The image size is too large for file format '%s'"
                    "%s", fmt, cluster_size_hint);
-        error_free(local_err);
-        local_err = NULL;
+        error_free_errp(errp);
     }
 
 out:
     qemu_opts_del(opts);
     qemu_opts_free(create_opts);
-    error_propagate(errp, local_err);
 }
 
 AioContext *bdrv_get_aio_context(BlockDriverState *bs)
diff --git a/block/blkdebug.c b/block/blkdebug.c
index 5ae96c52b0..918ccf5704 100644
--- a/block/blkdebug.c
+++ b/block/blkdebug.c
@@ -171,7 +171,6 @@ static int add_rule(void *opaque, QemuOpts *opts, Error **errp)
     struct BlkdebugRule *rule;
     int64_t sector;
     BlkdebugIOType iotype;
-    Error *local_error = NULL;
 
     /* Find the right event for the rule */
     event_name = qemu_opt_get(opts, "event");
@@ -205,9 +204,8 @@ static int add_rule(void *opaque, QemuOpts *opts, Error **errp)
 
         iotype = qapi_enum_parse(&BlkdebugIOType_lookup,
                                  qemu_opt_get(opts, "iotype"),
-                                 BLKDEBUG_IO_TYPE__MAX, &local_error);
-        if (local_error) {
-            error_propagate(errp, local_error);
+                                 BLKDEBUG_IO_TYPE__MAX, errp);
+        if (*errp) {
             return -1;
         }
         if (iotype != BLKDEBUG_IO_TYPE__MAX) {
@@ -262,7 +260,6 @@ static int read_config(BDRVBlkdebugState *s, const char *filename,
     FILE *f = NULL;
     int ret;
     struct add_rule_data d;
-    Error *local_err = NULL;
 
     if (filename) {
         f = fopen(filename, "r");
@@ -278,26 +275,23 @@ static int read_config(BDRVBlkdebugState *s, const char *filename,
         }
     }
 
-    qemu_config_parse_qdict(options, config_groups, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_config_parse_qdict(options, config_groups, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
 
     d.s = s;
     d.action = ACTION_INJECT_ERROR;
-    qemu_opts_foreach(&inject_error_opts, add_rule, &d, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_foreach(&inject_error_opts, add_rule, &d, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
 
     d.action = ACTION_SET_STATE;
-    qemu_opts_foreach(&set_state_opts, add_rule, &d, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_foreach(&set_state_opts, add_rule, &d, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -397,14 +391,12 @@ static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,
 {
     BDRVBlkdebugState *s = bs->opaque;
     QemuOpts *opts;
-    Error *local_err = NULL;
     int ret;
     uint64_t align;
 
     opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto out;
     }
@@ -421,10 +413,9 @@ static int blkdebug_open(BlockDriverState *bs, QDict *options, int flags,
 
     /* Open the image file */
     bs->file = bdrv_open_child(qemu_opt_get(opts, "x-image"), options, "image",
-                               bs, &child_file, false, &local_err);
-    if (local_err) {
+                               bs, &child_file, false, errp);
+    if (*errp) {
         ret = -EINVAL;
-        error_propagate(errp, local_err);
         goto out;
     }
 
diff --git a/block/blklogwrites.c b/block/blklogwrites.c
index 04d8b33607..62455dc684 100644
--- a/block/blklogwrites.c
+++ b/block/blklogwrites.c
@@ -143,34 +143,30 @@ static int blk_log_writes_open(BlockDriverState *bs, QDict *options, int flags,
 {
     BDRVBlkLogWritesState *s = bs->opaque;
     QemuOpts *opts;
-    Error *local_err = NULL;
     int ret;
     uint64_t log_sector_size;
     bool log_append;
 
     opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
     /* Open the file */
     bs->file = bdrv_open_child(NULL, options, "file", bs, &child_file, false,
-                               &local_err);
-    if (local_err) {
+                               errp);
+    if (*errp) {
         ret = -EINVAL;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
     /* Open the log file */
     s->log_file = bdrv_open_child(NULL, options, "log", bs, &child_file, false,
-                                  &local_err);
-    if (local_err) {
+                                  errp);
+    if (*errp) {
         ret = -EINVAL;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
@@ -220,10 +216,9 @@ static int blk_log_writes_open(BlockDriverState *bs, QDict *options, int flags,
         if (blk_log_writes_sector_size_valid(log_sector_size)) {
             s->cur_log_sector =
                 blk_log_writes_find_cur_log_sector(s->log_file, log_sector_size,
-                                    le64_to_cpu(log_sb.nr_entries), &local_err);
-            if (local_err) {
+                                    le64_to_cpu(log_sb.nr_entries), errp);
+            if (*errp) {
                 ret = -EINVAL;
-                error_propagate(errp, local_err);
                 goto fail_log;
             }
 
diff --git a/block/blkreplay.c b/block/blkreplay.c
index 2b7931b940..74d2ba7f9b 100644
--- a/block/blkreplay.c
+++ b/block/blkreplay.c
@@ -23,15 +23,13 @@ typedef struct Request {
 static int blkreplay_open(BlockDriverState *bs, QDict *options, int flags,
                           Error **errp)
 {
-    Error *local_err = NULL;
     int ret;
 
     /* Open the image file */
     bs->file = bdrv_open_child(NULL, options, "image",
-                               bs, &child_file, false, &local_err);
-    if (local_err) {
+                               bs, &child_file, false, errp);
+    if (*errp) {
         ret = -EINVAL;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
diff --git a/block/blkverify.c b/block/blkverify.c
index 304b0a1368..0fddf94f0f 100644
--- a/block/blkverify.c
+++ b/block/blkverify.c
@@ -112,33 +112,29 @@ static int blkverify_open(BlockDriverState *bs, QDict *options, int flags,
 {
     BDRVBlkverifyState *s = bs->opaque;
     QemuOpts *opts;
-    Error *local_err = NULL;
     int ret;
 
     opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
 
     /* Open the raw file */
     bs->file = bdrv_open_child(qemu_opt_get(opts, "x-raw"), options, "raw",
-                               bs, &child_file, false, &local_err);
-    if (local_err) {
+                               bs, &child_file, false, errp);
+    if (*errp) {
         ret = -EINVAL;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
     /* Open the test file */
     s->test_file = bdrv_open_child(qemu_opt_get(opts, "x-image"), options,
                                    "test", bs, &child_format, false,
-                                   &local_err);
-    if (local_err) {
+                                   errp);
+    if (*errp) {
         ret = -EINVAL;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
diff --git a/block/block-backend.c b/block/block-backend.c
index 1c605d5444..371efeb1c8 100644
--- a/block/block-backend.c
+++ b/block/block-backend.c
@@ -187,7 +187,6 @@ static void blk_vm_state_changed(void *opaque, int running, RunState state)
 static void blk_root_activate(BdrvChild *child, Error **errp)
 {
     BlockBackend *blk = child->opaque;
-    Error *local_err = NULL;
 
     if (!blk->disable_perm) {
         return;
@@ -195,9 +194,8 @@ static void blk_root_activate(BdrvChild *child, Error **errp)
 
     blk->disable_perm = false;
 
-    blk_set_perm(blk, blk->perm, BLK_PERM_ALL, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    blk_set_perm(blk, blk->perm, BLK_PERM_ALL, errp);
+    if (*errp) {
         blk->disable_perm = true;
         return;
     }
@@ -213,9 +211,8 @@ static void blk_root_activate(BdrvChild *child, Error **errp)
         return;
     }
 
-    blk_set_perm(blk, blk->perm, blk->shared_perm, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    blk_set_perm(blk, blk->perm, blk->shared_perm, errp);
+    if (*errp) {
         blk->disable_perm = true;
         return;
     }
@@ -963,13 +960,11 @@ void blk_dev_change_media_cb(BlockBackend *blk, bool load, Error **errp)
 {
     if (blk->dev_ops && blk->dev_ops->change_media_cb) {
         bool tray_was_open, tray_is_open;
-        Error *local_err = NULL;
 
         tray_was_open = blk_dev_is_tray_open(blk);
-        blk->dev_ops->change_media_cb(blk->dev_opaque, load, &local_err);
-        if (local_err) {
+        blk->dev_ops->change_media_cb(blk->dev_opaque, load, errp);
+        if (*errp) {
             assert(load == true);
-            error_propagate(errp, local_err);
             return;
         }
         tray_is_open = blk_dev_is_tray_open(blk);
diff --git a/block/commit.c b/block/commit.c
index bc8454463d..aa5541ecf1 100644
--- a/block/commit.c
+++ b/block/commit.c
@@ -264,7 +264,6 @@ void commit_start(const char *job_id, BlockDriverState *bs,
     CommitBlockJob *s;
     BlockDriverState *iter;
     BlockDriverState *commit_top_bs = NULL;
-    Error *local_err = NULL;
     int ret;
 
     assert(top != bs);
@@ -303,10 +302,9 @@ void commit_start(const char *job_id, BlockDriverState *bs,
 
     commit_top_bs->total_sectors = top->total_sectors;
 
-    bdrv_append(commit_top_bs, top, &local_err);
-    if (local_err) {
+    bdrv_append(commit_top_bs, top, errp);
+    if (*errp) {
         commit_top_bs = NULL;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
diff --git a/block/crypto.c b/block/crypto.c
index 7eb698774e..38995f7490 100644
--- a/block/crypto.c
+++ b/block/crypto.c
@@ -194,7 +194,6 @@ static int block_crypto_open_generic(QCryptoBlockFormat format,
 {
     BlockCrypto *crypto = bs->opaque;
     QemuOpts *opts = NULL;
-    Error *local_err = NULL;
     int ret = -EINVAL;
     QCryptoBlockOpenOptions *open_opts = NULL;
     unsigned int cflags = 0;
@@ -210,9 +209,8 @@ static int block_crypto_open_generic(QCryptoBlockFormat format,
         bs->file->bs->supported_write_flags;
 
     opts = qemu_opts_create(opts_spec, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         goto cleanup;
     }
 
@@ -550,17 +548,15 @@ static int coroutine_fn block_crypto_co_create_opts_luks(const char *filename,
     char *buf = NULL;
     int64_t size;
     int ret;
-    Error *local_err = NULL;
 
     /* Parse options */
     size = qemu_opt_get_size_del(opts, BLOCK_OPT_SIZE, 0);
 
     buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);
     prealloc = qapi_enum_parse(&PreallocMode_lookup, buf,
-                               PREALLOC_MODE_OFF, &local_err);
+                               PREALLOC_MODE_OFF, errp);
     g_free(buf);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return -EINVAL;
     }
 
diff --git a/block/curl.c b/block/curl.c
index f86299378e..73c7006096 100644
--- a/block/curl.c
+++ b/block/curl.c
@@ -645,7 +645,6 @@ static int curl_open(BlockDriverState *bs, QDict *options, int flags,
     BDRVCURLState *s = bs->opaque;
     CURLState *state = NULL;
     QemuOpts *opts;
-    Error *local_err = NULL;
     const char *file;
     const char *cookie;
     const char *cookie_secret;
@@ -671,9 +670,8 @@ static int curl_open(BlockDriverState *bs, QDict *options, int flags,
 
     qemu_mutex_init(&s->mutex);
     opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         goto out_noclean;
     }
 
diff --git a/block/file-posix.c b/block/file-posix.c
index f12c06de2d..ff3465af24 100644
--- a/block/file-posix.c
+++ b/block/file-posix.c
@@ -475,7 +475,6 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
 {
     BDRVRawState *s = bs->opaque;
     QemuOpts *opts;
-    Error *local_err = NULL;
     const char *filename = NULL;
     const char *str;
     BlockdevAioOptions aio, aio_default;
@@ -484,9 +483,8 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
     OnOffAuto locking;
 
     opts = qemu_opts_create(&raw_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -503,9 +501,8 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
                   : BLOCKDEV_AIO_OPTIONS_THREADS;
     aio = qapi_enum_parse(&BlockdevAioOptions_lookup,
                           qemu_opt_get(opts, "aio"),
-                          aio_default, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                          aio_default, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -513,9 +510,8 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
 
     locking = qapi_enum_parse(&OnOffAuto_lookup,
                               qemu_opt_get(opts, "locking"),
-                              ON_OFF_AUTO_AUTO, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                              ON_OFF_AUTO_AUTO, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -541,9 +537,8 @@ static int raw_open_common(BlockDriverState *bs, QDict *options,
 
     str = qemu_opt_get(opts, "pr-manager");
     if (str) {
-        s->pr_mgr = pr_manager_lookup(str, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        s->pr_mgr = pr_manager_lookup(str, errp);
+        if (*errp) {
             ret = -EINVAL;
             goto fail;
         }
@@ -819,7 +814,6 @@ static int raw_handle_perm_lock(BlockDriverState *bs,
 {
     BDRVRawState *s = bs->opaque;
     int ret = 0;
-    Error *local_err = NULL;
 
     if (!s->use_lock) {
         return 0;
@@ -859,22 +853,22 @@ static int raw_handle_perm_lock(BlockDriverState *bs,
         /* fall through to unlock bytes. */
     case RAW_PL_ABORT:
         raw_apply_lock_bytes(s, s->fd, s->perm, ~s->shared_perm,
-                             true, &local_err);
-        if (local_err) {
+                             true, errp);
+        if (*errp) {
             /* Theoretically the above call only unlocks bytes and it cannot
              * fail. Something weird happened, report it.
              */
-            warn_report_err(local_err);
+            warn_report_errp(errp);
         }
         break;
     case RAW_PL_COMMIT:
         raw_apply_lock_bytes(s, s->fd, new_perm, ~new_shared,
-                             true, &local_err);
-        if (local_err) {
+                             true, errp);
+        if (*errp) {
             /* Theoretically the above call only unlocks bytes and it cannot
              * fail. Something weird happened, report it.
              */
-            warn_report_err(local_err);
+            warn_report_errp(errp);
         }
         break;
     }
@@ -952,7 +946,6 @@ static int raw_reopen_prepare(BDRVReopenState *state,
     BDRVRawReopenState *rs;
     QemuOpts *opts;
     int ret;
-    Error *local_err = NULL;
 
     assert(state != NULL);
     assert(state->bs != NULL);
@@ -964,9 +957,8 @@ static int raw_reopen_prepare(BDRVReopenState *state,
 
     /* Handle options changes */
     opts = qemu_opts_create(&raw_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, state->options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, state->options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto out;
     }
@@ -981,9 +973,8 @@ static int raw_reopen_prepare(BDRVReopenState *state,
     qemu_opts_to_qdict(opts, state->options);
 
     rs->fd = raw_reconfigure_getfd(state->bs, state->flags, &rs->open_flags,
-                                   state->perm, true, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                   state->perm, true, errp);
+    if (*errp) {
         ret = -1;
         goto out;
     }
@@ -991,9 +982,8 @@ static int raw_reopen_prepare(BDRVReopenState *state,
     /* Fail already reopen_prepare() if we can't get a working O_DIRECT
      * alignment with the new fd. */
     if (rs->fd != -1) {
-        raw_probe_alignment(state->bs, rs->fd, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        raw_probe_alignment(state->bs, rs->fd, errp);
+        if (*errp) {
             ret = -EINVAL;
             goto out_fd;
         }
@@ -2233,7 +2223,6 @@ static int coroutine_fn
 raw_co_create(BlockdevCreateOptions *options, Error **errp)
 {
     BlockdevCreateOptionsFile *file_opts;
-    Error *local_err = NULL;
     int fd;
     uint64_t perm, shared;
     int result = 0;
@@ -2315,13 +2304,13 @@ raw_co_create(BlockdevCreateOptions *options, Error **errp)
     }
 
 out_unlock:
-    raw_apply_lock_bytes(NULL, fd, 0, 0, true, &local_err);
-    if (local_err) {
+    raw_apply_lock_bytes(NULL, fd, 0, 0, true, errp);
+    if (*errp) {
         /* The above call should not fail, and if it does, that does
          * not mean the whole creation operation has failed.  So
          * report it the user for their convenience, but do not report
          * it to the caller. */
-        warn_report_err(local_err);
+        warn_report_errp(errp);
     }
 
 out_close:
@@ -2341,7 +2330,6 @@ static int coroutine_fn raw_co_create_opts(const char *filename, QemuOpts *opts,
     bool nocow = false;
     PreallocMode prealloc;
     char *buf = NULL;
-    Error *local_err = NULL;
 
     /* Skip file: protocol prefix */
     strstart(filename, "file:", &filename);
@@ -2352,10 +2340,9 @@ static int coroutine_fn raw_co_create_opts(const char *filename, QemuOpts *opts,
     nocow = qemu_opt_get_bool(opts, BLOCK_OPT_NOCOW, false);
     buf = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);
     prealloc = qapi_enum_parse(&PreallocMode_lookup, buf,
-                               PREALLOC_MODE_OFF, &local_err);
+                               PREALLOC_MODE_OFF, errp);
     g_free(buf);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return -EINVAL;
     }
 
@@ -3156,7 +3143,6 @@ static int hdev_open(BlockDriverState *bs, QDict *options, int flags,
                      Error **errp)
 {
     BDRVRawState *s = bs->opaque;
-    Error *local_err = NULL;
     int ret;
 
 #if defined(__APPLE__) && defined(__MACH__)
@@ -3221,9 +3207,8 @@ hdev_open_Mac_error:
 
     s->type = FTYPE_FILE;
 
-    ret = raw_open_common(bs, options, flags, 0, true, &local_err);
+    ret = raw_open_common(bs, options, flags, 0, true, errp);
     if (ret < 0) {
-        error_propagate(errp, local_err);
 #if defined(__APPLE__) && defined(__MACH__)
         if (*bsd_path) {
             filename = bsd_path;
@@ -3558,14 +3543,12 @@ static int cdrom_open(BlockDriverState *bs, QDict *options, int flags,
                       Error **errp)
 {
     BDRVRawState *s = bs->opaque;
-    Error *local_err = NULL;
     int ret;
 
     s->type = FTYPE_CD;
 
-    ret = raw_open_common(bs, options, flags, 0, true, &local_err);
+    ret = raw_open_common(bs, options, flags, 0, true, errp);
     if (ret) {
-        error_propagate(errp, local_err);
         return ret;
     }
 
diff --git a/block/file-win32.c b/block/file-win32.c
index 41f55dfece..26ae0f114c 100644
--- a/block/file-win32.c
+++ b/block/file-win32.c
@@ -330,7 +330,6 @@ static int raw_open(BlockDriverState *bs, QDict *options, int flags,
     int access_flags;
     DWORD overlapped;
     QemuOpts *opts;
-    Error *local_err = NULL;
     const char *filename;
     bool use_aio;
     int ret;
@@ -338,9 +337,8 @@ static int raw_open(BlockDriverState *bs, QDict *options, int flags,
     s->type = FTYPE_FILE;
 
     opts = qemu_opts_create(&raw_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -353,9 +351,8 @@ static int raw_open(BlockDriverState *bs, QDict *options, int flags,
 
     filename = qemu_opt_get(opts, "filename");
 
-    use_aio = get_aio_option(opts, flags, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    use_aio = get_aio_option(opts, flags, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -727,28 +724,24 @@ static int hdev_open(BlockDriverState *bs, QDict *options, int flags,
     int ret = 0;
     DWORD overlapped;
     char device_name[64];
-
-    Error *local_err = NULL;
     const char *filename;
     bool use_aio;
 
     QemuOpts *opts = qemu_opts_create(&raw_runtime_opts, NULL, 0,
                                       &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto done;
     }
 
     filename = qemu_opt_get(opts, "filename");
 
-    use_aio = get_aio_option(opts, flags, &local_err);
-    if (!local_err && use_aio) {
-        error_setg(&local_err, "AIO is not supported on Windows host devices");
+    use_aio = get_aio_option(opts, flags, errp);
+    if (!*errp && use_aio) {
+        error_setg(errp, "AIO is not supported on Windows host devices");
     }
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto done;
     }
diff --git a/block/gluster.c b/block/gluster.c
index 64028b2cba..f3d74d9cd2 100644
--- a/block/gluster.c
+++ b/block/gluster.c
@@ -516,34 +516,33 @@ static int qemu_gluster_parse_json(BlockdevOptionsGluster *gconf,
     SocketAddress *gsconf = NULL;
     SocketAddressList *curr = NULL;
     QDict *backing_options = NULL;
-    Error *local_err = NULL;
     char *str = NULL;
     const char *ptr;
     int i, type, num_servers;
 
     /* create opts info from runtime_json_opts list */
     opts = qemu_opts_create(&runtime_json_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         goto out;
     }
 
     num_servers = qdict_array_entries(options, GLUSTER_OPT_SERVER_PATTERN);
     if (num_servers < 1) {
-        error_setg(&local_err, QERR_MISSING_PARAMETER, "server");
+        error_setg(errp, QERR_MISSING_PARAMETER, "server");
         goto out;
     }
 
     ptr = qemu_opt_get(opts, GLUSTER_OPT_VOLUME);
     if (!ptr) {
-        error_setg(&local_err, QERR_MISSING_PARAMETER, GLUSTER_OPT_VOLUME);
+        error_setg(errp, QERR_MISSING_PARAMETER, GLUSTER_OPT_VOLUME);
         goto out;
     }
     gconf->volume = g_strdup(ptr);
 
     ptr = qemu_opt_get(opts, GLUSTER_OPT_PATH);
     if (!ptr) {
-        error_setg(&local_err, QERR_MISSING_PARAMETER, GLUSTER_OPT_PATH);
+        error_setg(errp, QERR_MISSING_PARAMETER, GLUSTER_OPT_PATH);
         goto out;
     }
     gconf->path = g_strdup(ptr);
@@ -555,15 +554,15 @@ static int qemu_gluster_parse_json(BlockdevOptionsGluster *gconf,
 
         /* create opts info from runtime_type_opts list */
         opts = qemu_opts_create(&runtime_type_opts, NULL, 0, &error_abort);
-        qemu_opts_absorb_qdict(opts, backing_options, &local_err);
-        if (local_err) {
+        qemu_opts_absorb_qdict(opts, backing_options, errp);
+        if (*errp) {
             goto out;
         }
 
         ptr = qemu_opt_get(opts, GLUSTER_OPT_TYPE);
         if (!ptr) {
-            error_setg(&local_err, QERR_MISSING_PARAMETER, GLUSTER_OPT_TYPE);
-            error_append_hint(&local_err, GERR_INDEX_HINT, i);
+            error_setg(errp, QERR_MISSING_PARAMETER, GLUSTER_OPT_TYPE);
+            error_append_hint(errp, GERR_INDEX_HINT, i);
             goto out;
 
         }
@@ -574,10 +573,10 @@ static int qemu_gluster_parse_json(BlockdevOptionsGluster *gconf,
         type = qapi_enum_parse(&SocketAddressType_lookup, ptr, -1, NULL);
         if (type != SOCKET_ADDRESS_TYPE_INET
             && type != SOCKET_ADDRESS_TYPE_UNIX) {
-            error_setg(&local_err,
+            error_setg(errp,
                        "Parameter '%s' may be 'inet' or 'unix'",
                        GLUSTER_OPT_TYPE);
-            error_append_hint(&local_err, GERR_INDEX_HINT, i);
+            error_append_hint(errp, GERR_INDEX_HINT, i);
             goto out;
         }
         gsconf->type = type;
@@ -586,24 +585,24 @@ static int qemu_gluster_parse_json(BlockdevOptionsGluster *gconf,
         if (gsconf->type == SOCKET_ADDRESS_TYPE_INET) {
             /* create opts info from runtime_inet_opts list */
             opts = qemu_opts_create(&runtime_inet_opts, NULL, 0, &error_abort);
-            qemu_opts_absorb_qdict(opts, backing_options, &local_err);
-            if (local_err) {
+            qemu_opts_absorb_qdict(opts, backing_options, errp);
+            if (*errp) {
                 goto out;
             }
 
             ptr = qemu_opt_get(opts, GLUSTER_OPT_HOST);
             if (!ptr) {
-                error_setg(&local_err, QERR_MISSING_PARAMETER,
+                error_setg(errp, QERR_MISSING_PARAMETER,
                            GLUSTER_OPT_HOST);
-                error_append_hint(&local_err, GERR_INDEX_HINT, i);
+                error_append_hint(errp, GERR_INDEX_HINT, i);
                 goto out;
             }
             gsconf->u.inet.host = g_strdup(ptr);
             ptr = qemu_opt_get(opts, GLUSTER_OPT_PORT);
             if (!ptr) {
-                error_setg(&local_err, QERR_MISSING_PARAMETER,
+                error_setg(errp, QERR_MISSING_PARAMETER,
                            GLUSTER_OPT_PORT);
-                error_append_hint(&local_err, GERR_INDEX_HINT, i);
+                error_append_hint(errp, GERR_INDEX_HINT, i);
                 goto out;
             }
             gsconf->u.inet.port = g_strdup(ptr);
@@ -624,19 +623,19 @@ static int qemu_gluster_parse_json(BlockdevOptionsGluster *gconf,
                 gsconf->u.inet.has_ipv6 = true;
             }
             if (gsconf->u.inet.has_to) {
-                error_setg(&local_err, "Parameter 'to' not supported");
+                error_setg(errp, "Parameter 'to' not supported");
                 goto out;
             }
             if (gsconf->u.inet.has_ipv4 || gsconf->u.inet.has_ipv6) {
-                error_setg(&local_err, "Parameters 'ipv4/ipv6' not supported");
+                error_setg(errp, "Parameters 'ipv4/ipv6' not supported");
                 goto out;
             }
             qemu_opts_del(opts);
         } else {
             /* create opts info from runtime_unix_opts list */
             opts = qemu_opts_create(&runtime_unix_opts, NULL, 0, &error_abort);
-            qemu_opts_absorb_qdict(opts, backing_options, &local_err);
-            if (local_err) {
+            qemu_opts_absorb_qdict(opts, backing_options, errp);
+            if (*errp) {
                 goto out;
             }
 
@@ -644,15 +643,15 @@ static int qemu_gluster_parse_json(BlockdevOptionsGluster *gconf,
             if (!ptr) {
                 ptr = qemu_opt_get(opts, GLUSTER_OPT_SOCKET);
             } else if (qemu_opt_get(opts, GLUSTER_OPT_SOCKET)) {
-                error_setg(&local_err,
+                error_setg(errp,
                            "Conflicting parameters 'path' and 'socket'");
-                error_append_hint(&local_err, GERR_INDEX_HINT, i);
+                error_append_hint(errp, GERR_INDEX_HINT, i);
                 goto out;
             }
             if (!ptr) {
-                error_setg(&local_err, QERR_MISSING_PARAMETER,
+                error_setg(errp, QERR_MISSING_PARAMETER,
                            GLUSTER_OPT_PATH);
-                error_append_hint(&local_err, GERR_INDEX_HINT, i);
+                error_append_hint(errp, GERR_INDEX_HINT, i);
                 goto out;
             }
             gsconf->u.q_unix.path = g_strdup(ptr);
@@ -679,7 +678,6 @@ static int qemu_gluster_parse_json(BlockdevOptionsGluster *gconf,
     return 0;
 
 out:
-    error_propagate(errp, local_err);
     qapi_free_SocketAddress(gsconf);
     qemu_opts_del(opts);
     g_free(str);
@@ -815,13 +813,11 @@ static int qemu_gluster_open(BlockDriverState *bs,  QDict *options,
     int ret = 0;
     BlockdevOptionsGluster *gconf = NULL;
     QemuOpts *opts;
-    Error *local_err = NULL;
     const char *filename, *logfile;
 
     opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto out;
     }
@@ -1138,7 +1134,6 @@ static int coroutine_fn qemu_gluster_co_create_opts(const char *filename,
     BlockdevCreateOptionsGluster *gopts;
     BlockdevOptionsGluster *gconf;
     char *tmp = NULL;
-    Error *local_err = NULL;
     int ret;
 
     options = g_new0(BlockdevCreateOptions, 1);
@@ -1153,10 +1148,9 @@ static int coroutine_fn qemu_gluster_co_create_opts(const char *filename,
 
     tmp = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);
     gopts->preallocation = qapi_enum_parse(&PreallocMode_lookup, tmp,
-                                           PREALLOC_MODE_OFF, &local_err);
+                                           PREALLOC_MODE_OFF, errp);
     g_free(tmp);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
diff --git a/block/io.c b/block/io.c
index f8c3596131..cebf76bed5 100644
--- a/block/io.c
+++ b/block/io.c
@@ -136,7 +136,6 @@ static void bdrv_merge_limits(BlockLimits *dst, const BlockLimits *src)
 void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)
 {
     BlockDriver *drv = bs->drv;
-    Error *local_err = NULL;
 
     memset(&bs->bl, 0, sizeof(bs->bl));
 
@@ -151,9 +150,8 @@ void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)
 
     /* Take some limits from the children as a default */
     if (bs->file) {
-        bdrv_refresh_limits(bs->file->bs, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        bdrv_refresh_limits(bs->file->bs, errp);
+        if (*errp) {
             return;
         }
         bdrv_merge_limits(&bs->bl, &bs->file->bs->bl);
@@ -166,9 +164,8 @@ void bdrv_refresh_limits(BlockDriverState *bs, Error **errp)
     }
 
     if (bs->backing) {
-        bdrv_refresh_limits(bs->backing->bs, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        bdrv_refresh_limits(bs->backing->bs, errp);
+        if (*errp) {
             return;
         }
         bdrv_merge_limits(&bs->bl, &bs->backing->bs->bl);
diff --git a/block/iscsi.c b/block/iscsi.c
index 506bf5f875..f150550501 100644
--- a/block/iscsi.c
+++ b/block/iscsi.c
@@ -1786,7 +1786,6 @@ static int iscsi_open(BlockDriverState *bs, QDict *options, int flags,
     struct scsi_inquiry_supported_pages *inq_vpd;
     char *initiator_name = NULL;
     QemuOpts *opts;
-    Error *local_err = NULL;
     const char *transport_name, *portal, *target;
 #if LIBISCSI_API_VERSION >= (20160603)
     enum iscsi_transport_type transport;
@@ -1794,9 +1793,8 @@ static int iscsi_open(BlockDriverState *bs, QDict *options, int flags,
     int i, ret = 0, timeout = 0, lun;
 
     opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto out;
     }
@@ -1850,9 +1848,8 @@ static int iscsi_open(BlockDriverState *bs, QDict *options, int flags,
     }
 
     /* check if we got CHAP username/password via the options */
-    apply_chap(iscsi, opts, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    apply_chap(iscsi, opts, errp);
+    if (*errp != NULL) {
         ret = -EINVAL;
         goto out;
     }
@@ -1864,9 +1861,8 @@ static int iscsi_open(BlockDriverState *bs, QDict *options, int flags,
     }
 
     /* check if we got HEADER_DIGEST via the options */
-    apply_header_digest(iscsi, opts, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    apply_header_digest(iscsi, opts, errp);
+    if (*errp != NULL) {
         ret = -EINVAL;
         goto out;
     }
@@ -1918,9 +1914,8 @@ static int iscsi_open(BlockDriverState *bs, QDict *options, int flags,
         flags &= ~BDRV_O_RDWR;
     }
 
-    iscsi_readcapacity_sync(iscsilun, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    iscsi_readcapacity_sync(iscsilun, errp);
+    if (*errp != NULL) {
         ret = -EINVAL;
         goto out;
     }
@@ -2125,7 +2120,6 @@ static int coroutine_fn iscsi_co_truncate(BlockDriverState *bs, int64_t offset,
                                           PreallocMode prealloc, Error **errp)
 {
     IscsiLun *iscsilun = bs->opaque;
-    Error *local_err = NULL;
 
     if (prealloc != PREALLOC_MODE_OFF) {
         error_setg(errp, "Unsupported preallocation mode '%s'",
@@ -2138,9 +2132,8 @@ static int coroutine_fn iscsi_co_truncate(BlockDriverState *bs, int64_t offset,
         return -ENOTSUP;
     }
 
-    iscsi_readcapacity_sync(iscsilun, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    iscsi_readcapacity_sync(iscsilun, errp);
+    if (*errp != NULL) {
         return -EIO;
     }
 
@@ -2164,7 +2157,6 @@ static int coroutine_fn iscsi_co_create_opts(const char *filename, QemuOpts *opt
     BlockDriverState *bs;
     IscsiLun *iscsilun = NULL;
     QDict *bs_options;
-    Error *local_err = NULL;
 
     bs = bdrv_new();
 
@@ -2175,9 +2167,8 @@ static int coroutine_fn iscsi_co_create_opts(const char *filename, QemuOpts *opt
     iscsilun = bs->opaque;
 
     bs_options = qdict_new();
-    iscsi_parse_filename(filename, bs_options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    iscsi_parse_filename(filename, bs_options, errp);
+    if (*errp) {
         ret = -EINVAL;
     } else {
         ret = iscsi_open(bs, bs_options, 0, NULL);
diff --git a/block/mirror.c b/block/mirror.c
index fe984efb90..c1beaf9f8a 100644
--- a/block/mirror.c
+++ b/block/mirror.c
@@ -1512,7 +1512,6 @@ static BlockJob *mirror_start_job(
     BlockDriverState *mirror_top_bs;
     bool target_graph_mod;
     bool target_is_backing;
-    Error *local_err = NULL;
     int ret;
 
     if (granularity == 0) {
@@ -1561,12 +1560,11 @@ static BlockJob *mirror_start_job(
      * it alive until block_job_create() succeeds even if bs has no parent. */
     bdrv_ref(mirror_top_bs);
     bdrv_drained_begin(bs);
-    bdrv_append(mirror_top_bs, bs, &local_err);
+    bdrv_append(mirror_top_bs, bs, errp);
     bdrv_drained_end(bs);
 
-    if (local_err) {
+    if (*errp) {
         bdrv_unref(mirror_top_bs);
-        error_propagate(errp, local_err);
         return NULL;
     }
 
@@ -1647,9 +1645,8 @@ static BlockJob *mirror_start_job(
      * (We start tracking writes as of the following
      * bdrv_create_dirty_bitmap() call.)
      */
-    bdrv_refresh_limits(mirror_top_bs, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    bdrv_refresh_limits(mirror_top_bs, errp);
+    if (*errp) {
         goto fail;
     }
 
@@ -1761,7 +1758,6 @@ BlockJob *commit_active_start(const char *job_id, BlockDriverState *bs,
                               bool auto_complete, Error **errp)
 {
     bool base_read_only;
-    Error *local_err = NULL;
     BlockJob *ret;
 
     base_read_only = bdrv_is_read_only(base);
@@ -1778,9 +1774,8 @@ BlockJob *commit_active_start(const char *job_id, BlockDriverState *bs,
                      on_error, on_error, true, cb, opaque,
                      &commit_active_job_driver, false, base, auto_complete,
                      filter_node_name, false, MIRROR_COPY_MODE_BACKGROUND,
-                     &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                     errp);
+    if (*errp) {
         goto error_restore_flags;
     }
 
diff --git a/block/nbd.c b/block/nbd.c
index 813c40d8f0..1eca0a0850 100644
--- a/block/nbd.c
+++ b/block/nbd.c
@@ -808,7 +808,6 @@ static int nbd_co_receive_cmdread_reply(BDRVNBDState *s, uint64_t handle,
     NBDReplyChunkIter iter;
     NBDReply reply;
     void *payload = NULL;
-    Error *local_err = NULL;
 
     NBD_FOREACH_REPLY_CHUNK(s, iter, handle, s->info.structured_reply,
                             qiov, &reply, &payload)
@@ -827,20 +826,20 @@ static int nbd_co_receive_cmdread_reply(BDRVNBDState *s, uint64_t handle,
             break;
         case NBD_REPLY_TYPE_OFFSET_HOLE:
             ret = nbd_parse_offset_hole_payload(s, &reply.structured, payload,
-                                                offset, qiov, &local_err);
+                                                offset, qiov, errp);
             if (ret < 0) {
                 nbd_channel_error(s, ret);
-                nbd_iter_channel_error(&iter, ret, &local_err);
+                nbd_iter_channel_error(&iter, ret, errp);
             }
             break;
         default:
             if (!nbd_reply_type_is_error(chunk->type)) {
                 /* not allowed reply type */
                 nbd_channel_error(s, -EINVAL);
-                error_setg(&local_err,
+                error_setg(errp,
                            "Unexpected reply type: %d (%s) for CMD_READ",
                            chunk->type, nbd_reply_type_lookup(chunk->type));
-                nbd_iter_channel_error(&iter, -EINVAL, &local_err);
+                nbd_iter_channel_error(&iter, -EINVAL, errp);
             }
         }
 
@@ -861,7 +860,6 @@ static int nbd_co_receive_blockstatus_reply(BDRVNBDState *s,
     NBDReplyChunkIter iter;
     NBDReply reply;
     void *payload = NULL;
-    Error *local_err = NULL;
     bool received = false;
 
     assert(!extent->length);
@@ -875,27 +873,27 @@ static int nbd_co_receive_blockstatus_reply(BDRVNBDState *s,
         case NBD_REPLY_TYPE_BLOCK_STATUS:
             if (received) {
                 nbd_channel_error(s, -EINVAL);
-                error_setg(&local_err, "Several BLOCK_STATUS chunks in reply");
-                nbd_iter_channel_error(&iter, -EINVAL, &local_err);
+                error_setg(errp, "Several BLOCK_STATUS chunks in reply");
+                nbd_iter_channel_error(&iter, -EINVAL, errp);
             }
             received = true;
 
             ret = nbd_parse_blockstatus_payload(s, &reply.structured,
                                                 payload, length, extent,
-                                                &local_err);
+                                                errp);
             if (ret < 0) {
                 nbd_channel_error(s, ret);
-                nbd_iter_channel_error(&iter, ret, &local_err);
+                nbd_iter_channel_error(&iter, ret, errp);
             }
             break;
         default:
             if (!nbd_reply_type_is_error(chunk->type)) {
                 nbd_channel_error(s, -EINVAL);
-                error_setg(&local_err,
+                error_setg(errp,
                            "Unexpected reply type: %d (%s) "
                            "for CMD_BLOCK_STATUS",
                            chunk->type, nbd_reply_type_lookup(chunk->type));
-                nbd_iter_channel_error(&iter, -EINVAL, &local_err);
+                nbd_iter_channel_error(&iter, -EINVAL, errp);
             }
         }
 
@@ -904,8 +902,8 @@ static int nbd_co_receive_blockstatus_reply(BDRVNBDState *s,
     }
 
     if (!extent->length && !iter.request_ret) {
-        error_setg(&local_err, "Server did not reply with any status extents");
-        nbd_iter_channel_error(&iter, -EIO, &local_err);
+        error_setg(errp, "Server did not reply with any status extents");
+        nbd_iter_channel_error(&iter, -EIO, errp);
     }
 
     error_propagate(errp, iter.err);
@@ -1174,15 +1172,13 @@ static QIOChannelSocket *nbd_establish_connection(SocketAddress *saddr,
                                                   Error **errp)
 {
     QIOChannelSocket *sioc;
-    Error *local_err = NULL;
 
     sioc = qio_channel_socket_new();
     qio_channel_set_name(QIO_CHANNEL(sioc), "nbd-client");
 
-    qio_channel_socket_connect_sync(sioc, saddr, &local_err);
-    if (local_err) {
+    qio_channel_socket_connect_sync(sioc, saddr, errp);
+    if (*errp) {
         object_unref(OBJECT(sioc));
-        error_propagate(errp, local_err);
         return NULL;
     }
 
@@ -1489,7 +1485,6 @@ static SocketAddress *nbd_config(BDRVNBDState *s, QDict *options,
     SocketAddress *saddr = NULL;
     QDict *addr = NULL;
     Visitor *iv = NULL;
-    Error *local_err = NULL;
 
     qdict_extract_subqdict(options, &addr, "server.");
     if (!qdict_size(addr)) {
@@ -1502,9 +1497,8 @@ static SocketAddress *nbd_config(BDRVNBDState *s, QDict *options,
         goto done;
     }
 
-    visit_type_SocketAddress(iv, NULL, &saddr, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_SocketAddress(iv, NULL, &saddr, errp);
+    if (*errp) {
         goto done;
     }
 
@@ -1599,13 +1593,11 @@ static int nbd_process_options(BlockDriverState *bs, QDict *options,
 {
     BDRVNBDState *s = bs->opaque;
     QemuOpts *opts;
-    Error *local_err = NULL;
     int ret = -EINVAL;
 
     opts = qemu_opts_create(&nbd_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         goto error;
     }
 
diff --git a/block/nfs.c b/block/nfs.c
index f39acfdb28..d1c41625de 100644
--- a/block/nfs.c
+++ b/block/nfs.c
@@ -564,18 +564,16 @@ static BlockdevOptionsNfs *nfs_options_qdict_to_qapi(QDict *options,
     BlockdevOptionsNfs *opts = NULL;
     Visitor *v;
     const QDictEntry *e;
-    Error *local_err = NULL;
 
     v = qobject_input_visitor_new_flat_confused(options, errp);
     if (!v) {
         return NULL;
     }
 
-    visit_type_BlockdevOptionsNfs(v, NULL, &opts, &local_err);
+    visit_type_BlockdevOptionsNfs(v, NULL, &opts, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return NULL;
     }
 
diff --git a/block/nvme.c b/block/nvme.c
index 5be3a39b63..1b55d640ef 100644
--- a/block/nvme.c
+++ b/block/nvme.c
@@ -189,7 +189,6 @@ static NVMeQueuePair *nvme_create_queue_pair(BlockDriverState *bs,
 {
     int i, r;
     BDRVNVMeState *s = bs->opaque;
-    Error *local_err = NULL;
     NVMeQueuePair *q = g_new0(NVMeQueuePair, 1);
     uint64_t prp_list_iova;
 
@@ -209,16 +208,14 @@ static NVMeQueuePair *nvme_create_queue_pair(BlockDriverState *bs,
         req->prp_list_page = q->prp_list_pages + i * s->page_size;
         req->prp_list_iova = prp_list_iova + i * s->page_size;
     }
-    nvme_init_queue(bs, &q->sq, size, NVME_SQ_ENTRY_BYTES, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    nvme_init_queue(bs, &q->sq, size, NVME_SQ_ENTRY_BYTES, errp);
+    if (*errp) {
         goto fail;
     }
     q->sq.doorbell = &s->regs->doorbells[idx * 2 * s->doorbell_scale];
 
-    nvme_init_queue(bs, &q->cq, size, NVME_CQ_ENTRY_BYTES, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    nvme_init_queue(bs, &q->cq, size, NVME_CQ_ENTRY_BYTES, errp);
+    if (*errp) {
         goto fail;
     }
     q->cq.doorbell = &s->regs->doorbells[(idx * 2 + 1) * s->doorbell_scale];
@@ -574,7 +571,6 @@ static int nvme_init(BlockDriverState *bs, const char *device, int namespace,
     uint64_t cap;
     uint64_t timeout_ms;
     uint64_t deadline, now;
-    Error *local_err = NULL;
 
     qemu_co_mutex_init(&s->dma_map_lock);
     qemu_co_queue_init(&s->dma_flush_queue);
@@ -666,9 +662,8 @@ static int nvme_init(BlockDriverState *bs, const char *device, int namespace,
     aio_set_event_notifier(bdrv_get_aio_context(bs), &s->irq_notifier,
                            false, nvme_handle_event, nvme_poll_cb);
 
-    nvme_identify(bs, namespace, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    nvme_identify(bs, namespace, errp);
+    if (*errp) {
         ret = -EIO;
         goto out;
     }
diff --git a/block/parallels.c b/block/parallels.c
index 7cd2714b69..c32ac09391 100644
--- a/block/parallels.c
+++ b/block/parallels.c
@@ -614,7 +614,6 @@ static int coroutine_fn parallels_co_create_opts(const char *filename,
                                                  Error **errp)
 {
     BlockdevCreateOptions *create_options = NULL;
-    Error *local_err = NULL;
     BlockDriverState *bs = NULL;
     QDict *qdict;
     Visitor *v;
@@ -635,9 +634,8 @@ static int coroutine_fn parallels_co_create_opts(const char *filename,
     }
 
     /* Create and open the file (protocol layer) */
-    ret = bdrv_create_file(filename, opts, &local_err);
+    ret = bdrv_create_file(filename, opts, errp);
     if (ret < 0) {
-        error_propagate(errp, local_err);
         goto done;
     }
 
@@ -658,11 +656,10 @@ static int coroutine_fn parallels_co_create_opts(const char *filename,
         goto done;
     }
 
-    visit_type_BlockdevCreateOptions(v, NULL, &create_options, &local_err);
+    visit_type_BlockdevCreateOptions(v, NULL, &create_options, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto done;
     }
@@ -725,7 +722,6 @@ static int parallels_open(BlockDriverState *bs, QDict *options, int flags,
     ParallelsHeader ph;
     int ret, size, i;
     QemuOpts *opts = NULL;
-    Error *local_err = NULL;
     char *buf;
 
     bs->file = bdrv_open_child(NULL, options, "file", bs, &child_file,
@@ -813,13 +809,13 @@ static int parallels_open(BlockDriverState *bs, QDict *options, int flags,
         }
     }
 
-    opts = qemu_opts_create(&parallels_runtime_opts, NULL, 0, &local_err);
-    if (local_err != NULL) {
+    opts = qemu_opts_create(&parallels_runtime_opts, NULL, 0, errp);
+    if (*errp != NULL) {
         goto fail_options;
     }
 
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err != NULL) {
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp != NULL) {
         goto fail_options;
     }
 
@@ -829,9 +825,9 @@ static int parallels_open(BlockDriverState *bs, QDict *options, int flags,
     buf = qemu_opt_get_del(opts, PARALLELS_OPT_PREALLOC_MODE);
     s->prealloc_mode = qapi_enum_parse(&prealloc_mode_lookup, buf,
                                        PRL_PREALLOC_MODE_FALLOCATE,
-                                       &local_err);
+                                       errp);
     g_free(buf);
-    if (local_err != NULL) {
+    if (*errp != NULL) {
         goto fail_options;
     }
 
@@ -855,9 +851,8 @@ static int parallels_open(BlockDriverState *bs, QDict *options, int flags,
     error_setg(&s->migration_blocker, "The Parallels format used by node '%s' "
                "does not support live migration",
                bdrv_get_device_or_node_name(bs));
-    ret = migrate_add_blocker(s->migration_blocker, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ret = migrate_add_blocker(s->migration_blocker, errp);
+    if (*errp) {
         error_free(s->migration_blocker);
         goto fail;
     }
@@ -872,7 +867,6 @@ fail:
     return ret;
 
 fail_options:
-    error_propagate(errp, local_err);
     ret = -EINVAL;
     goto fail;
 }
diff --git a/block/qapi.c b/block/qapi.c
index 15f1030264..30898c60b7 100644
--- a/block/qapi.c
+++ b/block/qapi.c
@@ -148,10 +148,8 @@ BlockDeviceInfo *bdrv_block_device_info(BlockBackend *blk,
     p_image_info = &info->image;
     info->backing_file_depth = 0;
     while (1) {
-        Error *local_err = NULL;
-        bdrv_query_image_info(bs0, p_image_info, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        bdrv_query_image_info(bs0, p_image_info, errp);
+        if (*errp) {
             qapi_free_BlockDeviceInfo(info);
             return NULL;
         }
@@ -261,7 +259,6 @@ void bdrv_query_image_info(BlockDriverState *bs,
     const char *backing_filename;
     BlockDriverInfo bdi;
     int ret;
-    Error *err = NULL;
     ImageInfo *info;
 
     aio_context_acquire(bdrv_get_aio_context(bs));
@@ -293,9 +290,8 @@ void bdrv_query_image_info(BlockDriverState *bs,
         info->dirty_flag = bdi.is_dirty;
         info->has_dirty_flag = true;
     }
-    info->format_specific = bdrv_get_specific_info(bs, &err);
-    if (err) {
-        error_propagate(errp, err);
+    info->format_specific = bdrv_get_specific_info(bs, errp);
+    if (*errp) {
         qapi_free_ImageInfo(info);
         goto out;
     }
@@ -322,7 +318,7 @@ void bdrv_query_image_info(BlockDriverState *bs,
         g_free(backing_filename2);
     }
 
-    ret = bdrv_query_snapshot_info_list(bs, &info->snapshots, &err);
+    ret = bdrv_query_snapshot_info_list(bs, &info->snapshots, errp);
     switch (ret) {
     case 0:
         if (info->snapshots) {
@@ -332,10 +328,9 @@ void bdrv_query_image_info(BlockDriverState *bs,
     /* recoverable error */
     case -ENOMEDIUM:
     case -ENOTSUP:
-        error_free(err);
+        error_free_errp(errp);
         break;
     default:
-        error_propagate(errp, err);
         qapi_free_ImageInfo(info);
         goto out;
     }
@@ -554,7 +549,6 @@ BlockInfoList *qmp_query_block(Error **errp)
 {
     BlockInfoList *head = NULL, **p_next = &head;
     BlockBackend *blk;
-    Error *local_err = NULL;
 
     for (blk = blk_all_next(NULL); blk; blk = blk_all_next(blk)) {
         BlockInfoList *info;
@@ -564,9 +558,8 @@ BlockInfoList *qmp_query_block(Error **errp)
         }
 
         info = g_malloc0(sizeof(*info));
-        bdrv_query_info(blk, &info->value, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        bdrv_query_info(blk, &info->value, errp);
+        if (*errp) {
             g_free(info);
             qapi_free_BlockInfoList(head);
             return NULL;
diff --git a/block/qcow.c b/block/qcow.c
index 5bdf72ba33..fcf1fb0812 100644
--- a/block/qcow.c
+++ b/block/qcow.c
@@ -121,7 +121,6 @@ static int qcow_open(BlockDriverState *bs, QDict *options, int flags,
     unsigned int len, i, shift;
     int ret;
     QCowHeader header;
-    Error *local_err = NULL;
     QCryptoBlockOpenOptions *crypto_opts = NULL;
     unsigned int cflags = 0;
     QDict *encryptopts = NULL;
@@ -314,9 +313,8 @@ static int qcow_open(BlockDriverState *bs, QDict *options, int flags,
     error_setg(&s->migration_blocker, "The qcow format used by node '%s' "
                "does not support live migration",
                bdrv_get_device_or_node_name(bs));
-    ret = migrate_add_blocker(s->migration_blocker, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ret = migrate_add_blocker(s->migration_blocker, errp);
+    if (*errp) {
         error_free(s->migration_blocker);
         goto fail;
     }
@@ -947,7 +945,6 @@ static int coroutine_fn qcow_co_create_opts(const char *filename,
     QDict *qdict;
     Visitor *v;
     const char *val;
-    Error *local_err = NULL;
     int ret;
 
     static const QDictRenames opt_renames[] = {
@@ -977,9 +974,8 @@ static int coroutine_fn qcow_co_create_opts(const char *filename,
     }
 
     /* Create and open the file (protocol layer) */
-    ret = bdrv_create_file(filename, opts, &local_err);
+    ret = bdrv_create_file(filename, opts, errp);
     if (ret < 0) {
-        error_propagate(errp, local_err);
         goto fail;
     }
 
@@ -1000,11 +996,10 @@ static int coroutine_fn qcow_co_create_opts(const char *filename,
         goto fail;
     }
 
-    visit_type_BlockdevCreateOptions(v, NULL, &create_options, &local_err);
+    visit_type_BlockdevCreateOptions(v, NULL, &create_options, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
diff --git a/block/qcow2-bitmap.c b/block/qcow2-bitmap.c
index b2487101ed..902345a8e3 100644
--- a/block/qcow2-bitmap.c
+++ b/block/qcow2-bitmap.c
@@ -1594,11 +1594,9 @@ fail:
 int qcow2_reopen_bitmaps_ro(BlockDriverState *bs, Error **errp)
 {
     BdrvDirtyBitmap *bitmap;
-    Error *local_err = NULL;
 
-    qcow2_store_persistent_dirty_bitmaps(bs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    qcow2_store_persistent_dirty_bitmaps(bs, errp);
+    if (*errp != NULL) {
         return -EINVAL;
     }
 
diff --git a/block/qcow2.c b/block/qcow2.c
index 4d16393e61..21c32e4f66 100644
--- a/block/qcow2.c
+++ b/block/qcow2.c
@@ -931,25 +931,22 @@ static int qcow2_update_options_prepare(BlockDriverState *bs,
     int i;
     const char *encryptfmt;
     QDict *encryptopts = NULL;
-    Error *local_err = NULL;
     int ret;
 
     qdict_extract_subqdict(options, &encryptopts, "encrypt.");
     encryptfmt = qdict_get_try_str(encryptopts, "format");
 
     opts = qemu_opts_create(&qcow2_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
 
     /* get L2 table/refcount block cache size from command line options */
     read_cache_sizes(bs, opts, &l2_cache_size, &l2_cache_entry_size,
-                     &refcount_cache_size, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                     &refcount_cache_size, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -1211,7 +1208,6 @@ static int coroutine_fn qcow2_do_open(BlockDriverState *bs, QDict *options,
     unsigned int len, i;
     int ret = 0;
     QCowHeader header;
-    Error *local_err = NULL;
     uint64_t ext_end;
     uint64_t l1_vm_state_index;
     bool update_header = false;
@@ -1486,17 +1482,15 @@ static int coroutine_fn qcow2_do_open(BlockDriverState *bs, QDict *options,
 
     /* read qcow2 extensions */
     if (qcow2_read_extensions(bs, header.header_length, ext_end, NULL,
-                              flags, &update_header, &local_err)) {
-        error_propagate(errp, local_err);
+                              flags, &update_header, errp)) {
         ret = -EINVAL;
         goto fail;
     }
 
     /* Open external data file */
     s->data_file = bdrv_open_child(NULL, options, "data-file", bs, &child_file,
-                                   true, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                   true, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -1657,12 +1651,11 @@ static int coroutine_fn qcow2_do_open(BlockDriverState *bs, QDict *options,
 
     if (!(bdrv_get_flags(bs) & BDRV_O_INACTIVE)) {
         /* It's case 1, 2 or 3.2. Or 3.1 which is BUG in management layer. */
-        bool header_updated = qcow2_load_dirty_bitmaps(bs, &local_err);
+        bool header_updated = qcow2_load_dirty_bitmaps(bs, errp);
 
         update_header = update_header && !header_updated;
     }
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    if (*errp != NULL) {
         ret = -EINVAL;
         goto fail;
     }
@@ -2428,7 +2421,6 @@ static void coroutine_fn qcow2_co_invalidate_cache(BlockDriverState *bs,
     int flags = s->flags;
     QCryptoBlock *crypto = NULL;
     QDict *options;
-    Error *local_err = NULL;
     int ret;
 
     /*
@@ -2446,11 +2438,11 @@ static void coroutine_fn qcow2_co_invalidate_cache(BlockDriverState *bs,
 
     flags &= ~BDRV_O_INACTIVE;
     qemu_co_mutex_lock(&s->lock);
-    ret = qcow2_do_open(bs, options, flags, &local_err);
+    ret = qcow2_do_open(bs, options, flags, errp);
     qemu_co_mutex_unlock(&s->lock);
     qobject_unref(options);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "Could not reopen qcow2 layer: ");
         bs->drv = NULL;
         return;
@@ -3059,7 +3051,6 @@ qcow2_co_create(BlockdevCreateOptions *create_options, Error **errp)
     int version;
     int refcount_order;
     uint64_t* refcount_table;
-    Error *local_err = NULL;
     int ret;
 
     assert(create_options->driver == BLOCKDEV_DRIVER_QCOW2);
@@ -3258,9 +3249,8 @@ qcow2_co_create(BlockdevCreateOptions *create_options, Error **errp)
     }
     blk = blk_new_open(NULL, NULL, options,
                        BDRV_O_RDWR | BDRV_O_RESIZE | BDRV_O_NO_FLUSH,
-                       &local_err);
+                       errp);
     if (blk == NULL) {
-        error_propagate(errp, local_err);
         ret = -EIO;
         goto out;
     }
@@ -3339,9 +3329,8 @@ qcow2_co_create(BlockdevCreateOptions *create_options, Error **errp)
     }
     blk = blk_new_open(NULL, NULL, options,
                        BDRV_O_RDWR | BDRV_O_NO_BACKING | BDRV_O_NO_IO,
-                       &local_err);
+                       errp);
     if (blk == NULL) {
-        error_propagate(errp, local_err);
         ret = -EIO;
         goto out;
     }
@@ -3362,7 +3351,6 @@ static int coroutine_fn qcow2_co_create_opts(const char *filename, QemuOpts *opt
     Visitor *v;
     BlockDriverState *bs = NULL;
     BlockDriverState *data_bs = NULL;
-    Error *local_err = NULL;
     const char *val;
     int ret;
 
@@ -3457,11 +3445,10 @@ static int coroutine_fn qcow2_co_create_opts(const char *filename, QemuOpts *opt
         goto finish;
     }
 
-    visit_type_BlockdevCreateOptions(v, NULL, &create_options, &local_err);
+    visit_type_BlockdevCreateOptions(v, NULL, &create_options, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto finish;
     }
@@ -3824,12 +3811,10 @@ static int coroutine_fn qcow2_co_truncate(BlockDriverState *bs, int64_t offset,
             goto fail;
         }
         if ((last_cluster + 1) * s->cluster_size < old_file_size) {
-            Error *local_err = NULL;
-
             bdrv_co_truncate(bs->file, (last_cluster + 1) * s->cluster_size,
-                             PREALLOC_MODE_OFF, &local_err);
-            if (local_err) {
-                warn_reportf_err(local_err,
+                             PREALLOC_MODE_OFF, errp);
+            if (*errp) {
+                warn_reportf_err(*errp,
                                  "Failed to truncate the tail of the image: ");
             }
         }
@@ -4405,7 +4390,6 @@ static bool qcow2_measure_luks_headerlen(QemuOpts *opts, size_t *len,
 static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,
                                        Error **errp)
 {
-    Error *local_err = NULL;
     BlockMeasureInfo *info;
     uint64_t required = 0; /* bytes that contribute to required size */
     uint64_t virtual_size; /* disk size as seen by guest */
@@ -4420,26 +4404,26 @@ static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,
     bool has_luks;
 
     /* Parse image creation options */
-    cluster_size = qcow2_opt_get_cluster_size_del(opts, &local_err);
-    if (local_err) {
+    cluster_size = qcow2_opt_get_cluster_size_del(opts, errp);
+    if (*errp) {
         goto err;
     }
 
-    version = qcow2_opt_get_version_del(opts, &local_err);
-    if (local_err) {
+    version = qcow2_opt_get_version_del(opts, errp);
+    if (*errp) {
         goto err;
     }
 
-    refcount_bits = qcow2_opt_get_refcount_bits_del(opts, version, &local_err);
-    if (local_err) {
+    refcount_bits = qcow2_opt_get_refcount_bits_del(opts, version, errp);
+    if (*errp) {
         goto err;
     }
 
     optstr = qemu_opt_get_del(opts, BLOCK_OPT_PREALLOC);
     prealloc = qapi_enum_parse(&PreallocMode_lookup, optstr,
-                               PREALLOC_MODE_OFF, &local_err);
+                               PREALLOC_MODE_OFF, errp);
     g_free(optstr);
-    if (local_err) {
+    if (*errp) {
         goto err;
     }
 
@@ -4454,7 +4438,7 @@ static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,
     if (has_luks) {
         size_t headerlen;
 
-        if (!qcow2_measure_luks_headerlen(opts, &headerlen, &local_err)) {
+        if (!qcow2_measure_luks_headerlen(opts, &headerlen, errp)) {
             goto err;
         }
 
@@ -4468,7 +4452,7 @@ static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,
     l2_tables = DIV_ROUND_UP(virtual_size / cluster_size,
                              cluster_size / sizeof(uint64_t));
     if (l2_tables * sizeof(uint64_t) > QCOW_MAX_L1_SIZE) {
-        error_setg(&local_err, "The image size is too large "
+        error_setg(errp, "The image size is too large "
                                "(try using a larger cluster size)");
         goto err;
     }
@@ -4477,7 +4461,7 @@ static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,
     if (in_bs) {
         int64_t ssize = bdrv_getlength(in_bs);
         if (ssize < 0) {
-            error_setg_errno(&local_err, -ssize,
+            error_setg_errno(errp, -ssize,
                              "Unable to get image virtual_size");
             goto err;
         }
@@ -4502,7 +4486,7 @@ static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,
                                               ssize - offset, &pnum, NULL,
                                               NULL);
                 if (ret < 0) {
-                    error_setg_errno(&local_err, -ret,
+                    error_setg_errno(errp, -ret,
                                      "Unable to get block status");
                     goto err;
                 }
@@ -4541,7 +4525,6 @@ static BlockMeasureInfo *qcow2_measure(QemuOpts *opts, BlockDriverState *in_bs,
     return info;
 
 err:
-    error_propagate(errp, local_err);
     return NULL;
 }
 
@@ -4560,12 +4543,10 @@ static ImageInfoSpecific *qcow2_get_specific_info(BlockDriverState *bs,
     BDRVQcow2State *s = bs->opaque;
     ImageInfoSpecific *spec_info;
     QCryptoBlockInfo *encrypt_info = NULL;
-    Error *local_err = NULL;
 
     if (s->crypto != NULL) {
-        encrypt_info = qcrypto_block_get_info(s->crypto, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        encrypt_info = qcrypto_block_get_info(s->crypto, errp);
+        if (*errp) {
             return NULL;
         }
     }
@@ -4582,9 +4563,8 @@ static ImageInfoSpecific *qcow2_get_specific_info(BlockDriverState *bs,
         };
     } else if (s->qcow_version == 3) {
         Qcow2BitmapInfoList *bitmaps;
-        bitmaps = qcow2_get_bitmap_info_list(bs, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        bitmaps = qcow2_get_bitmap_info_list(bs, errp);
+        if (*errp) {
             qapi_free_ImageInfoSpecific(spec_info);
             return NULL;
         }
diff --git a/block/qed.c b/block/qed.c
index 0d8fd507aa..7697dd0f4c 100644
--- a/block/qed.c
+++ b/block/qed.c
@@ -725,7 +725,6 @@ static int coroutine_fn bdrv_qed_co_create_opts(const char *filename,
     QDict *qdict;
     Visitor *v;
     BlockDriverState *bs = NULL;
-    Error *local_err = NULL;
     int ret;
 
     static const QDictRenames opt_renames[] = {
@@ -745,9 +744,8 @@ static int coroutine_fn bdrv_qed_co_create_opts(const char *filename,
     }
 
     /* Create and open the file (protocol layer) */
-    ret = bdrv_create_file(filename, opts, &local_err);
+    ret = bdrv_create_file(filename, opts, errp);
     if (ret < 0) {
-        error_propagate(errp, local_err);
         goto fail;
     }
 
@@ -768,11 +766,10 @@ static int coroutine_fn bdrv_qed_co_create_opts(const char *filename,
         goto fail;
     }
 
-    visit_type_BlockdevCreateOptions(v, NULL, &create_options, &local_err);
+    visit_type_BlockdevCreateOptions(v, NULL, &create_options, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -1588,17 +1585,16 @@ static void coroutine_fn bdrv_qed_co_invalidate_cache(BlockDriverState *bs,
                                                       Error **errp)
 {
     BDRVQEDState *s = bs->opaque;
-    Error *local_err = NULL;
     int ret;
 
     bdrv_qed_close(bs);
 
     bdrv_qed_init_state(bs);
     qemu_co_mutex_lock(&s->table_lock);
-    ret = bdrv_qed_do_open(bs, NULL, bs->open_flags, &local_err);
+    ret = bdrv_qed_do_open(bs, NULL, bs->open_flags, errp);
     qemu_co_mutex_unlock(&s->table_lock);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "Could not reopen qed layer: ");
         return;
     } else if (ret < 0) {
diff --git a/block/quorum.c b/block/quorum.c
index df68adcfaa..0b6b09afc7 100644
--- a/block/quorum.c
+++ b/block/quorum.c
@@ -862,7 +862,6 @@ static int quorum_open(BlockDriverState *bs, QDict *options, int flags,
                        Error **errp)
 {
     BDRVQuorumState *s = bs->opaque;
-    Error *local_err = NULL;
     QemuOpts *opts = NULL;
     const char *pattern_str;
     bool *opened;
@@ -874,27 +873,27 @@ static int quorum_open(BlockDriverState *bs, QDict *options, int flags,
     /* count how many different children are present */
     s->num_children = qdict_array_entries(options, "children.");
     if (s->num_children < 0) {
-        error_setg(&local_err, "Option children is not a valid array");
+        error_setg(errp, "Option children is not a valid array");
         ret = -EINVAL;
         goto exit;
     }
     if (s->num_children < 1) {
-        error_setg(&local_err,
+        error_setg(errp,
                    "Number of provided children must be 1 or more");
         ret = -EINVAL;
         goto exit;
     }
 
     opts = qemu_opts_create(&quorum_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto exit;
     }
 
     s->threshold = qemu_opt_get_number(opts, QUORUM_OPT_VOTE_THRESHOLD, 0);
     /* and validate it against s->num_children */
-    ret = quorum_valid_threshold(s->threshold, s->num_children, &local_err);
+    ret = quorum_valid_threshold(s->threshold, s->num_children, errp);
     if (ret < 0) {
         goto exit;
     }
@@ -907,7 +906,7 @@ static int quorum_open(BlockDriverState *bs, QDict *options, int flags,
                               -EINVAL, NULL);
     }
     if (ret < 0) {
-        error_setg(&local_err, "Please set read-pattern as fifo or quorum");
+        error_setg(errp, "Please set read-pattern as fifo or quorum");
         goto exit;
     }
     s->read_pattern = ret;
@@ -915,7 +914,7 @@ static int quorum_open(BlockDriverState *bs, QDict *options, int flags,
     if (s->read_pattern == QUORUM_READ_PATTERN_QUORUM) {
         s->is_blkverify = qemu_opt_get_bool(opts, QUORUM_OPT_BLKVERIFY, false);
         if (s->is_blkverify && (s->num_children != 2 || s->threshold != 2)) {
-            error_setg(&local_err, "blkverify=on can only be set if there are "
+            error_setg(errp, "blkverify=on can only be set if there are "
                        "exactly two files and vote-threshold is 2");
             ret = -EINVAL;
             goto exit;
@@ -924,7 +923,7 @@ static int quorum_open(BlockDriverState *bs, QDict *options, int flags,
         s->rewrite_corrupted = qemu_opt_get_bool(opts, QUORUM_OPT_REWRITE,
                                                  false);
         if (s->rewrite_corrupted && s->is_blkverify) {
-            error_setg(&local_err,
+            error_setg(errp,
                        "rewrite-corrupted=on cannot be used with blkverify=on");
             ret = -EINVAL;
             goto exit;
@@ -941,8 +940,8 @@ static int quorum_open(BlockDriverState *bs, QDict *options, int flags,
         assert(ret < 32);
 
         s->children[i] = bdrv_open_child(NULL, options, indexstr, bs,
-                                         &child_format, false, &local_err);
-        if (local_err) {
+                                         &child_format, false, errp);
+        if (*errp) {
             ret = -EINVAL;
             goto close_exit;
         }
@@ -969,7 +968,6 @@ close_exit:
 exit:
     qemu_opts_del(opts);
     /* propagate error */
-    error_propagate(errp, local_err);
     return ret;
 }
 
diff --git a/block/raw-format.c b/block/raw-format.c
index 42c28cc29a..e83a30c3b5 100644
--- a/block/raw-format.c
+++ b/block/raw-format.c
@@ -74,7 +74,6 @@ static QemuOptsList raw_create_opts = {
 static int raw_read_options(QDict *options, BlockDriverState *bs,
     BDRVRawState *s, Error **errp)
 {
-    Error *local_err = NULL;
     QemuOpts *opts = NULL;
     int64_t real_size = 0;
     int ret;
@@ -86,9 +85,8 @@ static int raw_read_options(QDict *options, BlockDriverState *bs,
     }
 
     opts = qemu_opts_create(&raw_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto end;
     }
diff --git a/block/rbd.c b/block/rbd.c
index 057af43d48..ae4dd9e705 100644
--- a/block/rbd.c
+++ b/block/rbd.c
@@ -431,7 +431,6 @@ static int coroutine_fn qemu_rbd_co_create_opts(const char *filename,
     BlockdevCreateOptions *create_options;
     BlockdevCreateOptionsRbd *rbd_opts;
     BlockdevOptionsRbd *loc;
-    Error *local_err = NULL;
     const char *keypairs, *password_secret;
     QDict *options = NULL;
     int ret = 0;
@@ -452,10 +451,9 @@ static int coroutine_fn qemu_rbd_co_create_opts(const char *filename,
     rbd_opts->has_cluster_size = (rbd_opts->cluster_size != 0);
 
     options = qdict_new();
-    qemu_rbd_parse_filename(filename, options, &local_err);
-    if (local_err) {
+    qemu_rbd_parse_filename(filename, options, errp);
+    if (*errp) {
         ret = -EINVAL;
-        error_propagate(errp, local_err);
         goto exit;
     }
 
@@ -573,7 +571,6 @@ static int qemu_rbd_connect(rados_t *cluster, rados_ioctx_t *io_ctx,
                             Error **errp)
 {
     char *mon_host = NULL;
-    Error *local_err = NULL;
     int r;
 
     if (secretid) {
@@ -586,9 +583,8 @@ static int qemu_rbd_connect(rados_t *cluster, rados_ioctx_t *io_ctx,
         opts->has_key_secret = true;
     }
 
-    mon_host = qemu_rbd_mon_host(opts, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    mon_host = qemu_rbd_mon_host(opts, errp);
+    if (*errp) {
         r = -EINVAL;
         goto failed_opts;
     }
@@ -661,7 +657,6 @@ static int qemu_rbd_convert_options(QDict *options, BlockdevOptionsRbd **opts,
                                     Error **errp)
 {
     Visitor *v;
-    Error *local_err = NULL;
 
     /* Convert the remaining options into a QAPI object */
     v = qobject_input_visitor_new_flat_confused(options, errp);
@@ -669,11 +664,10 @@ static int qemu_rbd_convert_options(QDict *options, BlockdevOptionsRbd **opts,
         return -EINVAL;
     }
 
-    visit_type_BlockdevOptionsRbd(v, NULL, opts, &local_err);
+    visit_type_BlockdevOptionsRbd(v, NULL, opts, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return -EINVAL;
     }
 
@@ -713,7 +707,6 @@ static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags,
     BDRVRBDState *s = bs->opaque;
     BlockdevOptionsRbd *opts = NULL;
     const QDictEntry *e;
-    Error *local_err = NULL;
     char *keypairs, *secretid;
     int r;
 
@@ -727,13 +720,12 @@ static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags,
         qdict_del(options, "password-secret");
     }
 
-    r = qemu_rbd_convert_options(options, &opts, &local_err);
-    if (local_err) {
+    r = qemu_rbd_convert_options(options, &opts, errp);
+    if (*errp) {
         /* If keypairs are present, that means some options are present in
          * the modern option format.  Don't attempt to parse legacy option
          * formats, as we won't support mixed usage. */
         if (keypairs) {
-            error_propagate(errp, local_err);
             goto out;
         }
 
@@ -746,7 +738,6 @@ static int qemu_rbd_open(BlockDriverState *bs, QDict *options, int flags,
         if (r < 0) {
             /* Propagate the original error, not the legacy parsing fallback
              * error, as the latter was just a best-effort attempt. */
-            error_propagate(errp, local_err);
             goto out;
         }
         /* Take care whenever deciding to actually deprecate; once this ability
diff --git a/block/replication.c b/block/replication.c
index 936b2f8b5a..22ae1067ec 100644
--- a/block/replication.c
+++ b/block/replication.c
@@ -85,7 +85,6 @@ static int replication_open(BlockDriverState *bs, QDict *options,
 {
     int ret;
     BDRVReplicationState *s = bs->opaque;
-    Error *local_err = NULL;
     QemuOpts *opts = NULL;
     const char *mode;
     const char *top_id;
@@ -98,14 +97,14 @@ static int replication_open(BlockDriverState *bs, QDict *options,
 
     ret = -EINVAL;
     opts = qemu_opts_create(&replication_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         goto fail;
     }
 
     mode = qemu_opt_get(opts, REPLICATION_MODE);
     if (!mode) {
-        error_setg(&local_err, "Missing the option mode");
+        error_setg(errp, "Missing the option mode");
         goto fail;
     }
 
@@ -113,7 +112,8 @@ static int replication_open(BlockDriverState *bs, QDict *options,
         s->mode = REPLICATION_MODE_PRIMARY;
         top_id = qemu_opt_get(opts, REPLICATION_TOP_ID);
         if (top_id) {
-            error_setg(&local_err, "The primary side does not support option top-id");
+            error_setg(errp,
+                       "The primary side does not support option top-id");
             goto fail;
         }
     } else if (!strcmp(mode, "secondary")) {
@@ -121,11 +121,11 @@ static int replication_open(BlockDriverState *bs, QDict *options,
         top_id = qemu_opt_get(opts, REPLICATION_TOP_ID);
         s->top_id = g_strdup(top_id);
         if (!s->top_id) {
-            error_setg(&local_err, "Missing the option top-id");
+            error_setg(errp, "Missing the option top-id");
             goto fail;
         }
     } else {
-        error_setg(&local_err,
+        error_setg(errp,
                    "The option mode's value should be primary or secondary");
         goto fail;
     }
@@ -136,7 +136,6 @@ static int replication_open(BlockDriverState *bs, QDict *options,
 
 fail:
     qemu_opts_del(opts);
-    error_propagate(errp, local_err);
 
     return ret;
 }
@@ -314,7 +313,6 @@ static bool replication_recurse_is_first_non_filter(BlockDriverState *bs,
 
 static void secondary_do_checkpoint(BDRVReplicationState *s, Error **errp)
 {
-    Error *local_err = NULL;
     int ret;
 
     if (!s->backup_job) {
@@ -322,9 +320,8 @@ static void secondary_do_checkpoint(BDRVReplicationState *s, Error **errp)
         return;
     }
 
-    backup_do_checkpoint(s->backup_job, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    backup_do_checkpoint(s->backup_job, errp);
+    if (*errp) {
         return;
     }
 
@@ -363,7 +360,6 @@ static void reopen_backing_file(BlockDriverState *bs, bool writable,
 {
     BDRVReplicationState *s = bs->opaque;
     BlockReopenQueue *reopen_queue = NULL;
-    Error *local_err = NULL;
 
     if (writable) {
         s->orig_hidden_read_only = bdrv_is_read_only(s->hidden_disk->bs);
@@ -388,8 +384,7 @@ static void reopen_backing_file(BlockDriverState *bs, bool writable,
     }
 
     if (reopen_queue) {
-        bdrv_reopen_multiple(reopen_queue, &local_err);
-        error_propagate(errp, local_err);
+        bdrv_reopen_multiple(reopen_queue, errp);
     }
 
     bdrv_subtree_drained_end(s->hidden_disk->bs);
@@ -450,7 +445,6 @@ static void replication_start(ReplicationState *rs, ReplicationMode mode,
     BlockDriverState *top_bs;
     int64_t active_length, hidden_length, disk_length;
     AioContext *aio_context;
-    Error *local_err = NULL;
 
     aio_context = bdrv_get_aio_context(bs);
     aio_context_acquire(aio_context);
@@ -519,9 +513,8 @@ static void replication_start(ReplicationState *rs, ReplicationMode mode,
         }
 
         /* reopen the backing file in r/w mode */
-        reopen_backing_file(bs, true, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        reopen_backing_file(bs, true, errp);
+        if (*errp) {
             aio_context_release(aio_context);
             return;
         }
@@ -546,9 +539,8 @@ static void replication_start(ReplicationState *rs, ReplicationMode mode,
                                 0, MIRROR_SYNC_MODE_NONE, NULL, 0, false,
                                 BLOCKDEV_ON_ERROR_REPORT,
                                 BLOCKDEV_ON_ERROR_REPORT, JOB_INTERNAL,
-                                backup_job_completed, bs, NULL, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                                backup_job_completed, bs, NULL, errp);
+        if (*errp) {
             backup_job_cleanup(bs);
             aio_context_release(aio_context);
             return;
diff --git a/block/sheepdog.c b/block/sheepdog.c
index 773dfc6ab1..086194f975 100644
--- a/block/sheepdog.c
+++ b/block/sheepdog.c
@@ -532,7 +532,6 @@ static SocketAddress *sd_server_config(QDict *options, Error **errp)
     QDict *server = NULL;
     Visitor *iv = NULL;
     SocketAddress *saddr = NULL;
-    Error *local_err = NULL;
 
     qdict_extract_subqdict(options, &server, "server.");
 
@@ -541,9 +540,8 @@ static SocketAddress *sd_server_config(QDict *options, Error **errp)
         goto done;
     }
 
-    visit_type_SocketAddress(iv, NULL, &saddr, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_SocketAddress(iv, NULL, &saddr, errp);
+    if (*errp) {
         goto done;
     }
 
@@ -1008,7 +1006,6 @@ static void sd_config_done(SheepdogConfig *cfg)
 static void sd_parse_uri(SheepdogConfig *cfg, const char *filename,
                          Error **errp)
 {
-    Error *err = NULL;
     QueryParams *qp = NULL;
     bool is_unix;
     URI *uri;
@@ -1017,7 +1014,7 @@ static void sd_parse_uri(SheepdogConfig *cfg, const char *filename,
 
     cfg->uri = uri = uri_parse(filename);
     if (!uri) {
-        error_setg(&err, "invalid URI '%s'", filename);
+        error_setg(errp, "invalid URI '%s'", filename);
         goto out;
     }
 
@@ -1029,18 +1026,18 @@ static void sd_parse_uri(SheepdogConfig *cfg, const char *filename,
     } else if (!g_strcmp0(uri->scheme, "sheepdog+unix")) {
         is_unix = true;
     } else {
-        error_setg(&err, "URI scheme must be 'sheepdog', 'sheepdog+tcp',"
+        error_setg(errp, "URI scheme must be 'sheepdog', 'sheepdog+tcp',"
                    " or 'sheepdog+unix'");
         goto out;
     }
 
     if (uri->path == NULL || !strcmp(uri->path, "/")) {
-        error_setg(&err, "missing file path in URI");
+        error_setg(errp, "missing file path in URI");
         goto out;
     }
     if (g_strlcpy(cfg->vdi, uri->path + 1, SD_MAX_VDI_LEN)
         >= SD_MAX_VDI_LEN) {
-        error_setg(&err, "VDI name is too long");
+        error_setg(errp, "VDI name is too long");
         goto out;
     }
 
@@ -1049,25 +1046,25 @@ static void sd_parse_uri(SheepdogConfig *cfg, const char *filename,
     if (is_unix) {
         /* sheepdog+unix:///vdiname?socket=path */
         if (uri->server || uri->port) {
-            error_setg(&err, "URI scheme %s doesn't accept a server address",
+            error_setg(errp, "URI scheme %s doesn't accept a server address",
                        uri->scheme);
             goto out;
         }
         if (!qp->n) {
-            error_setg(&err,
+            error_setg(errp,
                        "URI scheme %s requires query parameter 'socket'",
                        uri->scheme);
             goto out;
         }
         if (qp->n != 1 || strcmp(qp->p[0].name, "socket")) {
-            error_setg(&err, "unexpected query parameters");
+            error_setg(errp, "unexpected query parameters");
             goto out;
         }
         cfg->path = qp->p[0].value;
     } else {
         /* sheepdog[+tcp]://[host:port]/vdiname */
         if (qp->n) {
-            error_setg(&err, "unexpected query parameters");
+            error_setg(errp, "unexpected query parameters");
             goto out;
         }
         cfg->host = uri->server;
@@ -1078,7 +1075,7 @@ static void sd_parse_uri(SheepdogConfig *cfg, const char *filename,
     if (uri->fragment) {
         if (!sd_parse_snapid_or_tag(uri->fragment,
                                     &cfg->snap_id, cfg->tag)) {
-            error_setg(&err, "'%s' is not a valid snapshot ID",
+            error_setg(errp, "'%s' is not a valid snapshot ID",
                        uri->fragment);
             goto out;
         }
@@ -1087,8 +1084,7 @@ static void sd_parse_uri(SheepdogConfig *cfg, const char *filename,
     }
 
 out:
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         sd_config_done(cfg);
     }
 }
@@ -1113,7 +1109,6 @@ out:
 static void parse_vdiname(SheepdogConfig *cfg, const char *filename,
                           Error **errp)
 {
-    Error *err = NULL;
     char *p, *q, *uri;
     const char *host_spec, *vdi_spec;
     int nr_sep;
@@ -1155,14 +1150,14 @@ static void parse_vdiname(SheepdogConfig *cfg, const char *filename,
      * FIXME We to escape URI meta-characters, e.g. "x?y=z"
      * produces "sheepdog://x?y=z".  Because of that ...
      */
-    sd_parse_uri(cfg, uri, &err);
-    if (err) {
+    sd_parse_uri(cfg, uri, errp);
+    if (*errp) {
         /*
          * ... this can fail, but the error message is misleading.
          * Replace it by the traditional useless one until the
          * escaping is fixed.
          */
-        error_free(err);
+        error_free_errp(errp);
         error_setg(errp, "Can't parse filename");
     }
 
@@ -1173,17 +1168,15 @@ static void parse_vdiname(SheepdogConfig *cfg, const char *filename,
 static void sd_parse_filename(const char *filename, QDict *options,
                               Error **errp)
 {
-    Error *err = NULL;
     SheepdogConfig cfg;
     char buf[32];
 
     if (strstr(filename, "://")) {
-        sd_parse_uri(&cfg, filename, &err);
+        sd_parse_uri(&cfg, filename, errp);
     } else {
-        parse_vdiname(&cfg, filename, &err);
+        parse_vdiname(&cfg, filename, errp);
     }
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         return;
     }
 
@@ -1550,15 +1543,13 @@ static int sd_open(BlockDriverState *bs, QDict *options, int flags,
     uint64_t snap_id;
     char *buf = NULL;
     QemuOpts *opts;
-    Error *local_err = NULL;
 
     s->bs = bs;
     s->aio_context = bdrv_get_aio_context(bs);
 
     opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto err_no_fd;
     }
@@ -1854,15 +1845,13 @@ static int sd_create_prealloc(BlockdevOptionsSheepdog *location, int64_t size,
     Visitor *v;
     QObject *obj = NULL;
     QDict *qdict;
-    Error *local_err = NULL;
     int ret;
 
     v = qobject_output_visitor_new(&obj);
-    visit_type_BlockdevOptionsSheepdog(v, NULL, &location, &local_err);
+    visit_type_BlockdevOptionsSheepdog(v, NULL, &location, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         qobject_unref(obj);
         return -EINVAL;
     }
@@ -2164,7 +2153,6 @@ static int coroutine_fn sd_co_create_opts(const char *filename, QemuOpts *opts,
     QDict *qdict, *location_qdict;
     Visitor *v;
     char *redundancy;
-    Error *local_err = NULL;
     int ret;
 
     redundancy = qemu_opt_get_del(opts, BLOCK_OPT_REDUNDANCY);
@@ -2175,9 +2163,8 @@ static int coroutine_fn sd_co_create_opts(const char *filename, QemuOpts *opts,
     location_qdict = qdict_new();
     qdict_put(qdict, "location", location_qdict);
 
-    sd_parse_filename(filename, location_qdict, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    sd_parse_filename(filename, location_qdict, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -2203,11 +2190,10 @@ static int coroutine_fn sd_co_create_opts(const char *filename, QemuOpts *opts,
         goto fail;
     }
 
-    visit_type_BlockdevCreateOptions(v, NULL, &create_options, &local_err);
+    visit_type_BlockdevCreateOptions(v, NULL, &create_options, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
diff --git a/block/snapshot.c b/block/snapshot.c
index f2f48f926a..ca1c79f80f 100644
--- a/block/snapshot.c
+++ b/block/snapshot.c
@@ -208,7 +208,6 @@ int bdrv_snapshot_goto(BlockDriverState *bs,
         BlockDriverState *file;
         QDict *options = qdict_clone_shallow(bs->options);
         QDict *file_options;
-        Error *local_err = NULL;
 
         file = bs->file->bs;
         /* Prevent it from getting deleted when detached from bs */
@@ -225,13 +224,12 @@ int bdrv_snapshot_goto(BlockDriverState *bs,
         bs->file = NULL;
 
         ret = bdrv_snapshot_goto(file, snapshot_id, errp);
-        open_ret = drv->bdrv_open(bs, options, bs->open_flags, &local_err);
+        open_ret = drv->bdrv_open(bs, options, bs->open_flags, errp);
         qobject_unref(options);
         if (open_ret < 0) {
             bdrv_unref(file);
             bs->drv = NULL;
             /* A bdrv_snapshot_goto() error takes precedence */
-            error_propagate(errp, local_err);
             return ret < 0 ? ret : open_ret;
         }
 
@@ -370,17 +368,13 @@ int bdrv_snapshot_load_tmp_by_id_or_name(BlockDriverState *bs,
                                          Error **errp)
 {
     int ret;
-    Error *local_err = NULL;
 
-    ret = bdrv_snapshot_load_tmp(bs, id_or_name, NULL, &local_err);
+    ret = bdrv_snapshot_load_tmp(bs, id_or_name, NULL, errp);
     if (ret == -ENOENT || ret == -EINVAL) {
-        error_free(local_err);
-        local_err = NULL;
-        ret = bdrv_snapshot_load_tmp(bs, NULL, id_or_name, &local_err);
+        error_free_errp(errp);
+        ret = bdrv_snapshot_load_tmp(bs, NULL, id_or_name, errp);
     }
 
-    error_propagate(errp, local_err);
-
     return ret;
 }
 
diff --git a/block/ssh.c b/block/ssh.c
index 84d01e892b..7c41b2a416 100644
--- a/block/ssh.c
+++ b/block/ssh.c
@@ -616,15 +616,13 @@ static BlockdevOptionsSsh *ssh_parse_options(QDict *options, Error **errp)
 {
     BlockdevOptionsSsh *result = NULL;
     QemuOpts *opts = NULL;
-    Error *local_err = NULL;
     const QDictEntry *e;
     Visitor *v;
 
     /* Translate legacy options */
     opts = qemu_opts_create(&ssh_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         goto fail;
     }
 
@@ -638,11 +636,10 @@ static BlockdevOptionsSsh *ssh_parse_options(QDict *options, Error **errp)
         goto fail;
     }
 
-    visit_type_BlockdevOptionsSsh(v, NULL, &result, &local_err);
+    visit_type_BlockdevOptionsSsh(v, NULL, &result, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         goto fail;
     }
 
diff --git a/block/throttle-groups.c b/block/throttle-groups.c
index 77014c741b..90834e31ee 100644
--- a/block/throttle-groups.c
+++ b/block/throttle-groups.c
@@ -811,7 +811,6 @@ static void throttle_group_set(Object *obj, Visitor *v, const char * name,
     ThrottleGroup *tg = THROTTLE_GROUP(obj);
     ThrottleConfig *cfg;
     ThrottleParamInfo *info = opaque;
-    Error *local_err = NULL;
     int64_t value;
 
     /* If we have finished initialization, don't accept individual property
@@ -819,16 +818,16 @@ static void throttle_group_set(Object *obj, Visitor *v, const char * name,
      * transaction, as certain combinations are invalid.
      */
     if (tg->is_initialized) {
-        error_setg(&local_err, "Property cannot be set after initialization");
+        error_setg(errp, "Property cannot be set after initialization");
         goto ret;
     }
 
-    visit_type_int64(v, name, &value, &local_err);
-    if (local_err) {
+    visit_type_int64(v, name, &value, errp);
+    if (*errp) {
         goto ret;
     }
     if (value < 0) {
-        error_setg(&local_err, "Property values cannot be negative");
+        error_setg(errp, "Property values cannot be negative");
         goto ret;
     }
 
@@ -842,7 +841,7 @@ static void throttle_group_set(Object *obj, Visitor *v, const char * name,
         break;
     case BURST_LENGTH:
         if (value > UINT_MAX) {
-            error_setg(&local_err, "%s value must be in the"
+            error_setg(errp, "%s value must be in the"
                        "range [0, %u]", info->name, UINT_MAX);
             goto ret;
         }
@@ -854,7 +853,6 @@ static void throttle_group_set(Object *obj, Visitor *v, const char * name,
     }
 
 ret:
-    error_propagate(errp, local_err);
     return;
 
 }
@@ -895,16 +893,15 @@ static void throttle_group_set_limits(Object *obj, Visitor *v,
     ThrottleConfig cfg;
     ThrottleLimits arg = { 0 };
     ThrottleLimits *argp = &arg;
-    Error *local_err = NULL;
 
-    visit_type_ThrottleLimits(v, name, &argp, &local_err);
-    if (local_err) {
+    visit_type_ThrottleLimits(v, name, &argp, errp);
+    if (*errp) {
         goto ret;
     }
     qemu_mutex_lock(&tg->lock);
     throttle_get_config(&tg->ts, &cfg);
-    throttle_limits_to_config(argp, &cfg, &local_err);
-    if (local_err) {
+    throttle_limits_to_config(argp, &cfg, errp);
+    if (*errp) {
         goto unlock;
     }
     throttle_config(&tg->ts, tg->clock_type, &cfg);
@@ -912,7 +909,6 @@ static void throttle_group_set_limits(Object *obj, Visitor *v,
 unlock:
     qemu_mutex_unlock(&tg->lock);
 ret:
-    error_propagate(errp, local_err);
     return;
 }
 
diff --git a/block/throttle.c b/block/throttle.c
index 0349f42257..b3a9ceec55 100644
--- a/block/throttle.c
+++ b/block/throttle.c
@@ -46,12 +46,10 @@ static int throttle_parse_options(QDict *options, char **group, Error **errp)
 {
     int ret;
     const char *group_name;
-    Error *local_err = NULL;
     QemuOpts *opts = qemu_opts_create(&throttle_opts, NULL, 0, &error_abort);
 
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fin;
     }
diff --git a/block/vdi.c b/block/vdi.c
index 806ba7f53c..2d405d6cf9 100644
--- a/block/vdi.c
+++ b/block/vdi.c
@@ -375,7 +375,6 @@ static int vdi_open(BlockDriverState *bs, QDict *options, int flags,
     VdiHeader header;
     size_t bmap_size;
     int ret;
-    Error *local_err = NULL;
     QemuUUID uuid_link, uuid_parent;
 
     bs->file = bdrv_open_child(NULL, options, "file", bs, &child_file,
@@ -496,9 +495,8 @@ static int vdi_open(BlockDriverState *bs, QDict *options, int flags,
     error_setg(&s->migration_blocker, "The vdi format used by node '%s' "
                "does not support live migration",
                bdrv_get_device_or_node_name(bs));
-    ret = migrate_add_blocker(s->migration_blocker, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ret = migrate_add_blocker(s->migration_blocker, errp);
+    if (*errp) {
         error_free(s->migration_blocker);
         goto fail_free_bmap;
     }
@@ -905,7 +903,6 @@ static int coroutine_fn vdi_co_create_opts(const char *filename, QemuOpts *opts,
     uint64_t block_size = DEFAULT_CLUSTER_SIZE;
     bool is_static = false;
     Visitor *v;
-    Error *local_err = NULL;
     int ret;
 
     /* Parse options and convert legacy syntax.
@@ -956,11 +953,10 @@ static int coroutine_fn vdi_co_create_opts(const char *filename, QemuOpts *opts,
         ret = -EINVAL;
         goto done;
     }
-    visit_type_BlockdevCreateOptions(v, NULL, &create_options, &local_err);
+    visit_type_BlockdevCreateOptions(v, NULL, &create_options, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto done;
     }
diff --git a/block/vhdx.c b/block/vhdx.c
index 6a09d0a55c..1dff40932e 100644
--- a/block/vhdx.c
+++ b/block/vhdx.c
@@ -902,7 +902,6 @@ static int vhdx_open(BlockDriverState *bs, QDict *options, int flags,
     int ret = 0;
     uint32_t i;
     uint64_t signature;
-    Error *local_err = NULL;
 
     bs->file = bdrv_open_child(NULL, options, "file", bs, &child_file,
                                false, errp);
@@ -931,9 +930,8 @@ static int vhdx_open(BlockDriverState *bs, QDict *options, int flags,
      * header update */
     vhdx_guid_generate(&s->session_guid);
 
-    vhdx_parse_header(bs, s, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    vhdx_parse_header(bs, s, errp);
+    if (*errp != NULL) {
         ret = -EINVAL;
         goto fail;
     }
@@ -1007,9 +1005,8 @@ static int vhdx_open(BlockDriverState *bs, QDict *options, int flags,
     error_setg(&s->migration_blocker, "The vhdx format used by node '%s' "
                "does not support live migration",
                bdrv_get_device_or_node_name(bs));
-    ret = migrate_add_blocker(s->migration_blocker, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ret = migrate_add_blocker(s->migration_blocker, errp);
+    if (*errp) {
         error_free(s->migration_blocker);
         goto fail;
     }
@@ -1970,7 +1967,6 @@ static int coroutine_fn vhdx_co_create_opts(const char *filename,
     QDict *qdict;
     Visitor *v;
     BlockDriverState *bs = NULL;
-    Error *local_err = NULL;
     int ret;
 
     static const QDictRenames opt_renames[] = {
@@ -1989,9 +1985,8 @@ static int coroutine_fn vhdx_co_create_opts(const char *filename,
     }
 
     /* Create and open the file (protocol layer) */
-    ret = bdrv_create_file(filename, opts, &local_err);
+    ret = bdrv_create_file(filename, opts, errp);
     if (ret < 0) {
-        error_propagate(errp, local_err);
         goto fail;
     }
 
@@ -2012,11 +2007,10 @@ static int coroutine_fn vhdx_co_create_opts(const char *filename,
         goto fail;
     }
 
-    visit_type_BlockdevCreateOptions(v, NULL, &create_options, &local_err);
+    visit_type_BlockdevCreateOptions(v, NULL, &create_options, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
diff --git a/block/vmdk.c b/block/vmdk.c
index fed3b50c8a..3a0170312c 100644
--- a/block/vmdk.c
+++ b/block/vmdk.c
@@ -1092,7 +1092,6 @@ static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,
     BDRVVmdkState *s = bs->opaque;
     VmdkExtent *extent;
     char extent_opt_prefix[32];
-    Error *local_err = NULL;
 
     for (p = desc; *p; p = next_line(p)) {
         /* parse extent line in one of below formats:
@@ -1152,10 +1151,9 @@ static int vmdk_parse_extents(const char *desc, BlockDriverState *bs,
         assert(ret < 32);
 
         extent_file = bdrv_open_child(extent_path, options, extent_opt_prefix,
-                                      bs, &child_file, false, &local_err);
+                                      bs, &child_file, false, errp);
         g_free(extent_path);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             ret = -EINVAL;
             goto out;
         }
@@ -1255,7 +1253,6 @@ static int vmdk_open(BlockDriverState *bs, QDict *options, int flags,
     int ret;
     BDRVVmdkState *s = bs->opaque;
     uint32_t magic;
-    Error *local_err = NULL;
 
     bs->file = bdrv_open_child(NULL, options, "file", bs, &child_file,
                                false, errp);
@@ -1303,9 +1300,8 @@ static int vmdk_open(BlockDriverState *bs, QDict *options, int flags,
     error_setg(&s->migration_blocker, "The vmdk format used by node '%s' "
                "does not support live migration",
                bdrv_get_device_or_node_name(bs));
-    ret = migrate_add_blocker(s->migration_blocker, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ret = migrate_add_blocker(s->migration_blocker, errp);
+    if (*errp) {
         error_free(s->migration_blocker);
         goto fail;
     }
@@ -2225,19 +2221,16 @@ static int vmdk_create_extent(const char *filename, int64_t filesize,
 {
     int ret;
     BlockBackend *blk = NULL;
-    Error *local_err = NULL;
 
-    ret = bdrv_create_file(filename, opts, &local_err);
+    ret = bdrv_create_file(filename, opts, errp);
     if (ret < 0) {
-        error_propagate(errp, local_err);
         goto exit;
     }
 
     blk = blk_new_open(filename, NULL, NULL,
                        BDRV_O_RDWR | BDRV_O_RESIZE | BDRV_O_PROTOCOL,
-                       &local_err);
+                       errp);
     if (blk == NULL) {
-        error_propagate(errp, local_err);
         ret = -EIO;
         goto exit;
     }
@@ -2336,7 +2329,6 @@ static int coroutine_fn vmdk_co_do_create(int64_t size,
     int extent_idx;
     BlockBackend *blk = NULL;
     BlockBackend *extent_blk;
-    Error *local_err = NULL;
     char *desc = NULL;
     int ret = 0;
     bool flat, split, compress;
@@ -2440,9 +2432,8 @@ static int coroutine_fn vmdk_co_do_create(int64_t size,
         char *full_backing =
             bdrv_get_full_backing_filename_from_filename(blk_bs(blk)->filename,
                                                          backing_file,
-                                                         &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                                                         errp);
+        if (*errp) {
             ret = -ENOENT;
             goto exit;
         }
@@ -2591,7 +2582,6 @@ exit:
 static int coroutine_fn vmdk_co_create_opts(const char *filename, QemuOpts *opts,
                                             Error **errp)
 {
-    Error *local_err = NULL;
     char *desc = NULL;
     int64_t total_size = 0;
     char *adapter_type = NULL;
@@ -2634,9 +2624,8 @@ static int coroutine_fn vmdk_co_create_opts(const char *filename, QemuOpts *opts
         adapter_type_enum = qapi_enum_parse(&BlockdevVmdkAdapterType_lookup,
                                             adapter_type,
                                             BLOCKDEV_VMDK_ADAPTER_TYPE_IDE,
-                                            &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                                            errp);
+        if (*errp) {
             ret = -EINVAL;
             goto exit;
         }
@@ -2651,9 +2640,8 @@ static int coroutine_fn vmdk_co_create_opts(const char *filename, QemuOpts *opts
         subformat = qapi_enum_parse(&BlockdevVmdkSubformat_lookup,
                                     fmt,
                                     BLOCKDEV_VMDK_SUBFORMAT_MONOLITHICSPARSE,
-                                    &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                                    errp);
+        if (*errp) {
             ret = -EINVAL;
             goto exit;
         }
diff --git a/block/vpc.c b/block/vpc.c
index 5cd3890780..2de4f83e4f 100644
--- a/block/vpc.c
+++ b/block/vpc.c
@@ -218,7 +218,6 @@ static int vpc_open(BlockDriverState *bs, QDict *options, int flags,
     VHDFooter *footer;
     VHDDynDiskHeader *dyndisk_header;
     QemuOpts *opts = NULL;
-    Error *local_err = NULL;
     bool use_chs;
     uint8_t buf[HEADER_SIZE];
     uint32_t checksum;
@@ -235,16 +234,14 @@ static int vpc_open(BlockDriverState *bs, QDict *options, int flags,
     }
 
     opts = qemu_opts_create(&vpc_runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
 
-    vpc_parse_options(bs, opts, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    vpc_parse_options(bs, opts, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -448,9 +445,8 @@ static int vpc_open(BlockDriverState *bs, QDict *options, int flags,
     error_setg(&s->migration_blocker, "The vpc format used by node '%s' "
                "does not support live migration",
                bdrv_get_device_or_node_name(bs));
-    ret = migrate_add_blocker(s->migration_blocker, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ret = migrate_add_blocker(s->migration_blocker, errp);
+    if (*errp) {
         error_free(s->migration_blocker);
         goto fail;
     }
@@ -1096,7 +1092,6 @@ static int coroutine_fn vpc_co_create_opts(const char *filename,
     QDict *qdict;
     Visitor *v;
     BlockDriverState *bs = NULL;
-    Error *local_err = NULL;
     int ret;
 
     static const QDictRenames opt_renames[] = {
@@ -1113,9 +1108,8 @@ static int coroutine_fn vpc_co_create_opts(const char *filename,
     }
 
     /* Create and open the file (protocol layer) */
-    ret = bdrv_create_file(filename, opts, &local_err);
+    ret = bdrv_create_file(filename, opts, errp);
     if (ret < 0) {
-        error_propagate(errp, local_err);
         goto fail;
     }
 
@@ -1136,11 +1130,10 @@ static int coroutine_fn vpc_co_create_opts(const char *filename,
         goto fail;
     }
 
-    visit_type_BlockdevCreateOptions(v, NULL, &create_options, &local_err);
+    visit_type_BlockdevCreateOptions(v, NULL, &create_options, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
diff --git a/block/vvfat.c b/block/vvfat.c
index 019b8f1341..71428ea5a4 100644
--- a/block/vvfat.c
+++ b/block/vvfat.c
@@ -1154,7 +1154,6 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
     bool floppy;
     const char *dirname, *label;
     QemuOpts *opts;
-    Error *local_err = NULL;
     int ret;
 
 #ifdef DEBUG
@@ -1162,9 +1161,8 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
 #endif
 
     opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto fail;
     }
@@ -1282,9 +1280,8 @@ static int vvfat_open(BlockDriverState *bs, QDict *options, int flags,
                    "The vvfat (rw) format used by node '%s' "
                    "does not support live migration",
                    bdrv_get_device_or_node_name(bs));
-        ret = migrate_add_blocker(s->migration_blocker, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        ret = migrate_add_blocker(s->migration_blocker, errp);
+        if (*errp) {
             error_free(s->migration_blocker);
             goto fail;
         }
diff --git a/block/vxhs.c b/block/vxhs.c
index 77fd5eb20d..6e98d4338f 100644
--- a/block/vxhs.c
+++ b/block/vxhs.c
@@ -299,7 +299,6 @@ static int vxhs_open(BlockDriverState *bs, QDict *options,
     QemuOpts *opts = NULL;
     QemuOpts *tcp_opts = NULL;
     char *of_vsa_addr = NULL;
-    Error *local_err = NULL;
     const char *vdisk_id_opt;
     const char *server_host_opt;
     int ret = 0;
@@ -317,8 +316,8 @@ static int vxhs_open(BlockDriverState *bs, QDict *options,
     opts = qemu_opts_create(&runtime_opts, NULL, 0, &error_abort);
     tcp_opts = qemu_opts_create(&runtime_tcp_opts, NULL, 0, &error_abort);
 
-    qemu_opts_absorb_qdict(opts, options, &local_err);
-    if (local_err) {
+    qemu_opts_absorb_qdict(opts, options, errp);
+    if (*errp) {
         ret = -EINVAL;
         goto out;
     }
@@ -326,14 +325,14 @@ static int vxhs_open(BlockDriverState *bs, QDict *options,
     /* vdisk-id is the disk UUID */
     vdisk_id_opt = qemu_opt_get(opts, VXHS_OPT_VDISK_ID);
     if (!vdisk_id_opt) {
-        error_setg(&local_err, QERR_MISSING_PARAMETER, VXHS_OPT_VDISK_ID);
+        error_setg(errp, QERR_MISSING_PARAMETER, VXHS_OPT_VDISK_ID);
         ret = -EINVAL;
         goto out;
     }
 
     /* vdisk-id may contain a leading '/' */
     if (strlen(vdisk_id_opt) > UUID_FMT_LEN + 1) {
-        error_setg(&local_err, "vdisk-id cannot be more than %d characters",
+        error_setg(errp, "vdisk-id cannot be more than %d characters",
                    UUID_FMT_LEN);
         ret = -EINVAL;
         goto out;
@@ -345,22 +344,22 @@ static int vxhs_open(BlockDriverState *bs, QDict *options,
     /* get the 'server.' arguments */
     qdict_extract_subqdict(options, &backing_options, VXHS_OPT_SERVER".");
 
-    qemu_opts_absorb_qdict(tcp_opts, backing_options, &local_err);
-    if (local_err != NULL) {
+    qemu_opts_absorb_qdict(tcp_opts, backing_options, errp);
+    if (*errp != NULL) {
         ret = -EINVAL;
         goto out;
     }
 
     server_host_opt = qemu_opt_get(tcp_opts, VXHS_OPT_HOST);
     if (!server_host_opt) {
-        error_setg(&local_err, QERR_MISSING_PARAMETER,
+        error_setg(errp, QERR_MISSING_PARAMETER,
                    VXHS_OPT_SERVER"."VXHS_OPT_HOST);
         ret = -EINVAL;
         goto out;
     }
 
     if (strlen(server_host_opt) > MAXHOSTNAMELEN) {
-        error_setg(&local_err, "server.host cannot be more than %d characters",
+        error_setg(errp, "server.host cannot be more than %d characters",
                    MAXHOSTNAMELEN);
         ret = -EINVAL;
         goto out;
@@ -370,8 +369,8 @@ static int vxhs_open(BlockDriverState *bs, QDict *options,
     s->tlscredsid = g_strdup(qemu_opt_get(opts, "tls-creds"));
     if (s->tlscredsid) {
         vxhs_get_tls_creds(s->tlscredsid, &cacert, &client_key,
-                           &client_cert, &local_err);
-        if (local_err != NULL) {
+                           &client_cert, errp);
+        if (*errp != NULL) {
             ret = -EINVAL;
             goto out;
         }
@@ -413,7 +412,6 @@ out:
 
     if (ret < 0) {
         vxhs_unref();
-        error_propagate(errp, local_err);
         g_free(s->vdisk_hostinfo.host);
         g_free(s->vdisk_guid);
         g_free(s->tlscredsid);
diff --git a/blockdev.c b/blockdev.c
index fbef6845c8..7901fea8cd 100644
--- a/blockdev.c
+++ b/blockdev.c
@@ -376,7 +376,6 @@ static void extract_common_blockdev_options(QemuOpts *opts, int *bdrv_flags,
     const char **throttling_group, ThrottleConfig *throttle_cfg,
     BlockdevDetectZeroesOptions *detect_zeroes, Error **errp)
 {
-    Error *local_error = NULL;
     const char *aio;
 
     if (bdrv_flags) {
@@ -455,9 +454,8 @@ static void extract_common_blockdev_options(QemuOpts *opts, int *bdrv_flags,
             qapi_enum_parse(&BlockdevDetectZeroesOptions_lookup,
                             qemu_opt_get(opts, "detect-zeroes"),
                             BLOCKDEV_DETECT_ZEROES_OPTIONS_OFF,
-                            &local_error);
-        if (local_error) {
-            error_propagate(errp, local_error);
+                            errp);
+        if (*errp) {
             return;
         }
     }
@@ -476,7 +474,6 @@ static BlockBackend *blockdev_init(const char *file, QDict *bs_opts,
     BlockDriverState *bs;
     ThrottleConfig cfg;
     int snapshot = 0;
-    Error *error = NULL;
     QemuOpts *opts;
     QDict *interval_dict = NULL;
     QList *interval_list = NULL;
@@ -488,15 +485,13 @@ static BlockBackend *blockdev_init(const char *file, QDict *bs_opts,
     /* Check common options by copying from bs_opts to opts, all other options
      * stay in bs_opts for processing by bdrv_open(). */
     id = qdict_get_try_str(bs_opts, "id");
-    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, &error);
-    if (error) {
-        error_propagate(errp, error);
+    opts = qemu_opts_create(&qemu_common_drive_opts, id, 1, errp);
+    if (*errp) {
         goto err_no_opts;
     }
 
-    qemu_opts_absorb_qdict(opts, bs_opts, &error);
-    if (error) {
-        error_propagate(errp, error);
+    qemu_opts_absorb_qdict(opts, bs_opts, errp);
+    if (*errp) {
         goto early_err;
     }
 
@@ -524,9 +519,8 @@ static BlockBackend *blockdev_init(const char *file, QDict *bs_opts,
     }
 
     extract_common_blockdev_options(opts, &bdrv_flags, &throttling_group, &cfg,
-                                    &detect_zeroes, &error);
-    if (error) {
-        error_propagate(errp, error);
+                                    &detect_zeroes, errp);
+    if (*errp) {
         goto early_err;
     }
 
@@ -549,18 +543,16 @@ static BlockBackend *blockdev_init(const char *file, QDict *bs_opts,
 
     on_write_error = BLOCKDEV_ON_ERROR_ENOSPC;
     if ((buf = qemu_opt_get(opts, "werror")) != NULL) {
-        on_write_error = parse_block_error_action(buf, 0, &error);
-        if (error) {
-            error_propagate(errp, error);
+        on_write_error = parse_block_error_action(buf, 0, errp);
+        if (*errp) {
             goto early_err;
         }
     }
 
     on_read_error = BLOCKDEV_ON_ERROR_REPORT;
     if ((buf = qemu_opt_get(opts, "rerror")) != NULL) {
-        on_read_error = parse_block_error_action(buf, 1, &error);
-        if (error) {
-            error_propagate(errp, error);
+        on_read_error = parse_block_error_action(buf, 1, errp);
+        if (*errp) {
             goto early_err;
         }
     }
@@ -779,7 +771,6 @@ DriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type,
     bool read_only = false;
     bool copy_on_read;
     const char *filename;
-    Error *local_err = NULL;
     int i;
 
     /* Change legacy command line options into QMP ones */
@@ -812,9 +803,8 @@ DriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type,
 
     for (i = 0; i < ARRAY_SIZE(opt_renames); i++) {
         qemu_opt_rename(all_opts, opt_renames[i].from, opt_renames[i].to,
-                        &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                        errp);
+        if (*errp) {
             return NULL;
         }
     }
@@ -851,9 +841,8 @@ DriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type,
 
     legacy_opts = qemu_opts_create(&qemu_legacy_drive_opts, NULL, 0,
                                    &error_abort);
-    qemu_opts_absorb_qdict(legacy_opts, bs_opts, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(legacy_opts, bs_opts, errp);
+    if (*errp) {
         goto fail;
     }
 
@@ -993,13 +982,12 @@ DriveInfo *drive_new(QemuOpts *all_opts, BlockInterfaceType block_default_type,
     }
 
     /* Actual block device init: Functionality shared with blockdev-add */
-    blk = blockdev_init(filename, bs_opts, &local_err);
+    blk = blockdev_init(filename, bs_opts, errp);
     bs_opts = NULL;
     if (!blk) {
-        error_propagate(errp, local_err);
         goto fail;
     } else {
-        assert(!local_err);
+        assert(!*errp);
     }
 
     /* Create legacy DriveInfo */
@@ -1186,7 +1174,6 @@ SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,
     BlockDriverState *bs;
     AioContext *aio_context;
     QEMUSnapshotInfo sn;
-    Error *local_err = NULL;
     SnapshotInfo *info = NULL;
     int ret;
 
@@ -1214,9 +1201,8 @@ SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,
         goto out_aio_context;
     }
 
-    ret = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ret = bdrv_snapshot_find_by_id_and_name(bs, id, name, &sn, errp);
+    if (*errp) {
         goto out_aio_context;
     }
     if (!ret) {
@@ -1227,9 +1213,8 @@ SnapshotInfo *qmp_blockdev_snapshot_delete_internal_sync(const char *device,
         goto out_aio_context;
     }
 
-    bdrv_snapshot_delete(bs, id, name, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    bdrv_snapshot_delete(bs, id, name, errp);
+    if (*errp) {
         goto out_aio_context;
     }
 
@@ -1370,7 +1355,6 @@ static int action_check_completion_mode(BlkActionState *s, Error **errp)
 static void internal_snapshot_prepare(BlkActionState *common,
                                       Error **errp)
 {
-    Error *local_err = NULL;
     const char *device;
     const char *name;
     BlockDriverState *bs;
@@ -1432,9 +1416,8 @@ static void internal_snapshot_prepare(BlkActionState *common,
 
     /* check whether a snapshot with name exist */
     ret = bdrv_snapshot_find_by_id_and_name(bs, NULL, name, &old_sn,
-                                            &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                            errp);
+    if (*errp) {
         goto out;
     } else if (ret) {
         error_setg(errp,
@@ -1524,7 +1507,6 @@ static void external_snapshot_prepare(BlkActionState *common,
 {
     int flags = 0;
     QDict *options = NULL;
-    Error *local_err = NULL;
     /* Device and node name of the image to generate the snapshot from */
     const char *device;
     const char *node_name;
@@ -1635,9 +1617,8 @@ static void external_snapshot_prepare(BlkActionState *common,
             bdrv_img_create(new_image_file, format,
                             state->old_bs->filename,
                             state->old_bs->drv->format_name,
-                            NULL, size, flags, false, &local_err);
-            if (local_err) {
-                error_propagate(errp, local_err);
+                            NULL, size, flags, false, errp);
+            if (*errp) {
                 goto out;
             }
         }
@@ -1685,9 +1666,8 @@ static void external_snapshot_prepare(BlkActionState *common,
      * can fail, so we need to do it in .prepare; undoing it for abort is
      * always possible. */
     bdrv_ref(state->new_bs);
-    bdrv_append(state->new_bs, state->old_bs, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    bdrv_append(state->new_bs, state->old_bs, errp);
+    if (*errp) {
         goto out;
     }
     state->overlay_appended = true;
@@ -1771,7 +1751,6 @@ static void drive_backup_prepare(BlkActionState *common, Error **errp)
     BlockDriverState *bs;
     DriveBackup *backup;
     AioContext *aio_context;
-    Error *local_err = NULL;
 
     assert(common->action->type == TRANSACTION_ACTION_KIND_DRIVE_BACKUP);
     backup = common->action->u.drive_backup.data;
@@ -1789,9 +1768,8 @@ static void drive_backup_prepare(BlkActionState *common, Error **errp)
 
     state->bs = bs;
 
-    state->job = do_drive_backup(backup, common->block_job_txn, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    state->job = do_drive_backup(backup, common->block_job_txn, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -1861,7 +1839,6 @@ static void blockdev_backup_prepare(BlkActionState *common, Error **errp)
     BlockdevBackup *backup;
     BlockDriverState *bs, *target;
     AioContext *aio_context;
-    Error *local_err = NULL;
 
     assert(common->action->type == TRANSACTION_ACTION_KIND_BLOCKDEV_BACKUP);
     backup = common->action->u.blockdev_backup.data;
@@ -1883,9 +1860,8 @@ static void blockdev_backup_prepare(BlkActionState *common, Error **errp)
     /* Paired with .clean() */
     bdrv_drained_begin(state->bs);
 
-    state->job = do_blockdev_backup(backup, common->block_job_txn, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    state->job = do_blockdev_backup(backup, common->block_job_txn, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -1952,7 +1928,6 @@ typedef struct BlockDirtyBitmapState {
 static void block_dirty_bitmap_add_prepare(BlkActionState *common,
                                            Error **errp)
 {
-    Error *local_err = NULL;
     BlockDirtyBitmapAdd *action;
     BlockDirtyBitmapState *state = DO_UPCAST(BlockDirtyBitmapState,
                                              common, common);
@@ -1968,12 +1943,11 @@ static void block_dirty_bitmap_add_prepare(BlkActionState *common,
                                action->has_persistent, action->persistent,
                                action->has_autoload, action->autoload,
                                action->has_disabled, action->disabled,
-                               &local_err);
+                               errp);
 
-    if (!local_err) {
+    if (!*errp) {
         state->prepared = true;
     } else {
-        error_propagate(errp, local_err);
     }
 }
 
@@ -2379,7 +2353,6 @@ void qmp_eject(bool has_device, const char *device,
                bool has_id, const char *id,
                bool has_force, bool force, Error **errp)
 {
-    Error *local_err = NULL;
     int rc;
 
     if (!has_force) {
@@ -2388,12 +2361,11 @@ void qmp_eject(bool has_device, const char *device,
 
     rc = do_open_tray(has_device ? device : NULL,
                       has_id ? id : NULL,
-                      force, &local_err);
+                      force, errp);
     if (rc && rc != -ENOSYS) {
-        error_propagate(errp, local_err);
         return;
     }
-    error_free(local_err);
+    error_free_errp(errp);
 
     blockdev_remove_medium(has_device, device, has_id, id, errp);
 }
@@ -2466,7 +2438,6 @@ void qmp_blockdev_open_tray(bool has_device, const char *device,
                             bool has_force, bool force,
                             Error **errp)
 {
-    Error *local_err = NULL;
     int rc;
 
     if (!has_force) {
@@ -2474,12 +2445,11 @@ void qmp_blockdev_open_tray(bool has_device, const char *device,
     }
     rc = do_open_tray(has_device ? device : NULL,
                       has_id ? id : NULL,
-                      force, &local_err);
+                      force, errp);
     if (rc && rc != -ENOSYS && rc != -EINPROGRESS) {
-        error_propagate(errp, local_err);
         return;
     }
-    error_free(local_err);
+    error_free_errp(errp);
 }
 
 void qmp_blockdev_close_tray(bool has_device, const char *device,
@@ -2487,7 +2457,6 @@ void qmp_blockdev_close_tray(bool has_device, const char *device,
                              Error **errp)
 {
     BlockBackend *blk;
-    Error *local_err = NULL;
 
     device = has_device ? device : NULL;
     id = has_id ? id : NULL;
@@ -2511,9 +2480,8 @@ void qmp_blockdev_close_tray(bool has_device, const char *device,
         return;
     }
 
-    blk_dev_change_media_cb(blk, true, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    blk_dev_change_media_cb(blk, true, errp);
+    if (*errp) {
         return;
     }
 }
@@ -2583,7 +2551,6 @@ void qmp_blockdev_remove_medium(const char *id, Error **errp)
 static void qmp_blockdev_insert_anon_medium(BlockBackend *blk,
                                             BlockDriverState *bs, Error **errp)
 {
-    Error *local_err = NULL;
     bool has_device;
     int ret;
 
@@ -2616,9 +2583,8 @@ static void qmp_blockdev_insert_anon_medium(BlockBackend *blk,
          * slot here.
          * Do it after blk_insert_bs() so blk_is_inserted(blk) returns the @load
          * value passed here (i.e. true). */
-        blk_dev_change_media_cb(blk, true, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        blk_dev_change_media_cb(blk, true, errp);
+        if (*errp) {
             blk_remove_bs(blk);
             return;
         }
@@ -2673,7 +2639,6 @@ void qmp_blockdev_change_medium(bool has_device, const char *device,
     bool detect_zeroes;
     int rc;
     QDict *options = NULL;
-    Error *err = NULL;
 
     blk = qmp_get_blk(has_device ? device : NULL,
                       has_id ? id : NULL,
@@ -2725,23 +2690,19 @@ void qmp_blockdev_change_medium(bool has_device, const char *device,
 
     rc = do_open_tray(has_device ? device : NULL,
                       has_id ? id : NULL,
-                      false, &err);
+                      false, errp);
     if (rc && rc != -ENOSYS) {
-        error_propagate(errp, err);
         goto fail;
     }
-    error_free(err);
-    err = NULL;
+    error_free_errp(errp);
 
-    blockdev_remove_medium(has_device, device, has_id, id, &err);
-    if (err) {
-        error_propagate(errp, err);
+    blockdev_remove_medium(has_device, device, has_id, id, errp);
+    if (*errp) {
         goto fail;
     }
 
-    qmp_blockdev_insert_anon_medium(blk, medium_bs, &err);
-    if (err) {
-        error_propagate(errp, err);
+    qmp_blockdev_insert_anon_medium(blk, medium_bs, errp);
+    if (*errp) {
         goto fail;
     }
 
@@ -2941,14 +2902,12 @@ static BdrvDirtyBitmap *do_block_dirty_bitmap_remove(
 
     if (bdrv_dirty_bitmap_get_persistence(bitmap)) {
         AioContext *aio_context = bdrv_get_aio_context(bs);
-        Error *local_err = NULL;
 
         aio_context_acquire(aio_context);
-        bdrv_remove_persistent_dirty_bitmap(bs, name, &local_err);
+        bdrv_remove_persistent_dirty_bitmap(bs, name, errp);
         aio_context_release(aio_context);
 
-        if (local_err != NULL) {
-            error_propagate(errp, local_err);
+        if (*errp != NULL) {
             return NULL;
         }
     }
@@ -3036,7 +2995,6 @@ static BdrvDirtyBitmap *do_block_dirty_bitmap_merge(
     BlockDriverState *bs;
     BdrvDirtyBitmap *dst, *src, *anon;
     BlockDirtyBitmapMergeSourceList *lst;
-    Error *local_err = NULL;
 
     dst = block_dirty_bitmap_lookup(node, target, &bs, errp);
     if (!dst) {
@@ -3074,9 +3032,8 @@ static BdrvDirtyBitmap *do_block_dirty_bitmap_merge(
             abort();
         }
 
-        bdrv_merge_dirty_bitmap(anon, src, NULL, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        bdrv_merge_dirty_bitmap(anon, src, NULL, errp);
+        if (*errp) {
             dst = NULL;
             goto out;
         }
@@ -3186,7 +3143,6 @@ void qmp_block_resize(bool has_device, const char *device,
                       bool has_node_name, const char *node_name,
                       int64_t size, Error **errp)
 {
-    Error *local_err = NULL;
     BlockBackend *blk = NULL;
     BlockDriverState *bs;
     AioContext *aio_context;
@@ -3194,9 +3150,8 @@ void qmp_block_resize(bool has_device, const char *device,
 
     bs = bdrv_lookup_bs(has_device ? device : NULL,
                         has_node_name ? node_name : NULL,
-                        &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                        errp);
+    if (*errp) {
         return;
     }
 
@@ -3246,7 +3201,6 @@ void qmp_block_stream(bool has_job_id, const char *job_id, const char *device,
     BlockDriverState *bs, *iter;
     BlockDriverState *base_bs = NULL;
     AioContext *aio_context;
-    Error *local_err = NULL;
     const char *base_name = NULL;
     int job_flags = JOB_DEFAULT;
 
@@ -3319,9 +3273,8 @@ void qmp_block_stream(bool has_job_id, const char *job_id, const char *device,
     }
 
     stream_start(has_job_id ? job_id : NULL, bs, base_bs, base_name,
-                 job_flags, has_speed ? speed : 0, on_error, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                 job_flags, has_speed ? speed : 0, on_error, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -3347,7 +3300,6 @@ void qmp_block_commit(bool has_job_id, const char *job_id, const char *device,
     BlockDriverState *iter;
     BlockDriverState *base_bs, *top_bs;
     AioContext *aio_context;
-    Error *local_err = NULL;
     /* This will be part of the QMP command, if/when the
      * BlockdevOnError change for blkmirror makes it in
      */
@@ -3372,15 +3324,14 @@ void qmp_block_commit(bool has_job_id, const char *job_id, const char *device,
      *  live commit feature versions; for this to work, we must make sure to
      *  perform the device lookup before any generic errors that may occur in a
      *  scenario in which all optional arguments are omitted. */
-    bs = qmp_get_root_bs(device, &local_err);
+    bs = qmp_get_root_bs(device, errp);
     if (!bs) {
         bs = bdrv_lookup_bs(device, device, NULL);
         if (!bs) {
-            error_free(local_err);
+            error_free_errp(errp);
             error_set(errp, ERROR_CLASS_DEVICE_NOT_FOUND,
                       "Device '%s' not found", device);
         } else {
-            error_propagate(errp, local_err);
         }
         return;
     }
@@ -3471,7 +3422,7 @@ void qmp_block_commit(bool has_job_id, const char *job_id, const char *device,
         }
         commit_active_start(has_job_id ? job_id : NULL, bs, base_bs,
                             job_flags, speed, on_error,
-                            filter_node_name, NULL, NULL, false, &local_err);
+                            filter_node_name, NULL, NULL, false, errp);
     } else {
         BlockDriverState *overlay_bs = bdrv_find_overlay(bs, top_bs);
         if (bdrv_op_is_blocked(overlay_bs, BLOCK_OP_TYPE_COMMIT_TARGET, errp)) {
@@ -3479,10 +3430,9 @@ void qmp_block_commit(bool has_job_id, const char *job_id, const char *device,
         }
         commit_start(has_job_id ? job_id : NULL, bs, base_bs, top_bs, job_flags,
                      speed, on_error, has_backing_file ? backing_file : NULL,
-                     filter_node_name, &local_err);
+                     filter_node_name, errp);
     }
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    if (*errp != NULL) {
         goto out;
     }
 
@@ -3616,7 +3566,6 @@ static BlockJob *do_drive_backup(DriveBackup *backup, JobTxn *txn,
     BlockJob *job = NULL;
     AioContext *aio_context;
     QDict *options;
-    Error *local_err = NULL;
     int flags;
     int64_t size;
     bool set_backing_hd = false;
@@ -3676,15 +3625,14 @@ static BlockJob *do_drive_backup(DriveBackup *backup, JobTxn *txn,
             bdrv_refresh_filename(source);
             bdrv_img_create(backup->target, backup->format, source->filename,
                             source->drv->format_name, NULL,
-                            size, flags, false, &local_err);
+                            size, flags, false, errp);
         } else {
             bdrv_img_create(backup->target, backup->format, NULL, NULL, NULL,
-                            size, flags, false, &local_err);
+                            size, flags, false, errp);
         }
     }
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         goto out;
     }
 
@@ -3701,8 +3649,8 @@ static BlockJob *do_drive_backup(DriveBackup *backup, JobTxn *txn,
     }
 
     if (set_backing_hd) {
-        bdrv_set_backing_hd(target_bs, source, &local_err);
-        if (local_err) {
+        bdrv_set_backing_hd(target_bs, source, errp);
+        if (*errp) {
             goto unref;
         }
     }
@@ -3902,7 +3850,6 @@ void qmp_drive_mirror(DriveMirror *arg, Error **errp)
     BlockDriverState *source, *target_bs;
     AioContext *aio_context;
     BlockMirrorBackingMode backing_mode;
-    Error *local_err = NULL;
     QDict *options = NULL;
     int flags;
     int64_t size;
@@ -3970,7 +3917,7 @@ void qmp_drive_mirror(DriveMirror *arg, Error **errp)
         /* create new image w/o backing file */
         assert(format);
         bdrv_img_create(arg->target, format,
-                        NULL, NULL, NULL, size, flags, false, &local_err);
+                        NULL, NULL, NULL, size, flags, false, errp);
     } else {
         switch (arg->mode) {
         case NEW_IMAGE_MODE_EXISTING:
@@ -3981,15 +3928,14 @@ void qmp_drive_mirror(DriveMirror *arg, Error **errp)
             bdrv_img_create(arg->target, format,
                             source->filename,
                             source->drv->format_name,
-                            NULL, size, flags, false, &local_err);
+                            NULL, size, flags, false, errp);
             break;
         default:
             abort();
         }
     }
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         goto out;
     }
 
@@ -4032,9 +3978,8 @@ void qmp_drive_mirror(DriveMirror *arg, Error **errp)
                            arg->has_copy_mode, arg->copy_mode,
                            arg->has_auto_finalize, arg->auto_finalize,
                            arg->has_auto_dismiss, arg->auto_dismiss,
-                           &local_err);
+                           errp);
     bdrv_unref(target_bs);
-    error_propagate(errp, local_err);
 out:
     aio_context_release(aio_context);
 }
@@ -4061,7 +4006,6 @@ void qmp_blockdev_mirror(bool has_job_id, const char *job_id,
     BlockDriverState *target_bs;
     AioContext *aio_context;
     BlockMirrorBackingMode backing_mode = MIRROR_LEAVE_BACKING_CHAIN;
-    Error *local_err = NULL;
     bool zero_target;
     int ret;
 
@@ -4097,8 +4041,7 @@ void qmp_blockdev_mirror(bool has_job_id, const char *job_id,
                            has_copy_mode, copy_mode,
                            has_auto_finalize, auto_finalize,
                            has_auto_dismiss, auto_dismiss,
-                           &local_err);
-    error_propagate(errp, local_err);
+                           errp);
 out:
     aio_context_release(aio_context);
 }
@@ -4246,7 +4189,6 @@ void qmp_change_backing_file(const char *device,
     BlockDriverState *bs = NULL;
     AioContext *aio_context;
     BlockDriverState *image_bs = NULL;
-    Error *local_err = NULL;
     bool ro;
     int ret;
 
@@ -4258,9 +4200,8 @@ void qmp_change_backing_file(const char *device,
     aio_context = bdrv_get_aio_context(bs);
     aio_context_acquire(aio_context);
 
-    image_bs = bdrv_lookup_bs(NULL, image_node_name, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    image_bs = bdrv_lookup_bs(NULL, image_node_name, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -4308,8 +4249,7 @@ void qmp_change_backing_file(const char *device,
     }
 
     if (ro) {
-        bdrv_reopen_set_read_only(image_bs, true, &local_err);
-        error_propagate(errp, local_err);
+        bdrv_reopen_set_read_only(image_bs, true, errp);
     }
 
 out:
@@ -4353,11 +4293,9 @@ void qmp_blockdev_add(BlockdevOptions *options, Error **errp)
     QObject *obj;
     Visitor *v = qobject_output_visitor_new(&obj);
     QDict *qdict;
-    Error *local_err = NULL;
 
-    visit_type_BlockdevOptions(v, NULL, &options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_BlockdevOptions(v, NULL, &options, errp);
+    if (*errp) {
         goto fail;
     }
 
@@ -4388,7 +4326,6 @@ void qmp_x_blockdev_reopen(BlockdevOptions *options, Error **errp)
     AioContext *ctx;
     QObject *obj;
     Visitor *v = qobject_output_visitor_new(&obj);
-    Error *local_err = NULL;
     BlockReopenQueue *queue;
     QDict *qdict;
 
@@ -4405,9 +4342,8 @@ void qmp_x_blockdev_reopen(BlockdevOptions *options, Error **errp)
     }
 
     /* Put all options in a QDict and flatten it */
-    visit_type_BlockdevOptions(v, NULL, &options, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_BlockdevOptions(v, NULL, &options, errp);
+    if (*errp) {
         goto fail;
     }
 
diff --git a/blockjob.c b/blockjob.c
index c6e20e2fcd..8718ead3b8 100644
--- a/blockjob.c
+++ b/blockjob.c
@@ -449,12 +449,9 @@ void *block_job_create(const char *job_id, const BlockJobDriver *driver,
 
     /* Only set speed when necessary to avoid NotSupported error */
     if (speed != 0) {
-        Error *local_err = NULL;
-
-        block_job_set_speed(job, speed, &local_err);
-        if (local_err) {
+        block_job_set_speed(job, speed, errp);
+        if (*errp) {
             job_early_fail(&job->job);
-            error_propagate(errp, local_err);
             return NULL;
         }
     }
diff --git a/bootdevice.c b/bootdevice.c
index 1d225202f9..fccd47dd44 100644
--- a/bootdevice.c
+++ b/bootdevice.c
@@ -53,17 +53,14 @@ void qemu_register_boot_set(QEMUBootSetHandler *func, void *opaque)
 
 void qemu_boot_set(const char *boot_order, Error **errp)
 {
-    Error *local_err = NULL;
-
     if (!boot_set_handler) {
         error_setg(errp, "no function defined to set boot device list for"
                          " this architecture");
         return;
     }
 
-    validate_bootdevices(boot_order, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    validate_bootdevices(boot_order, errp);
+    if (*errp) {
         return;
     }
 
@@ -288,24 +285,20 @@ static void device_set_bootindex(Object *obj, Visitor *v, const char *name,
 {
     BootIndexProperty *prop = opaque;
     int32_t boot_index;
-    Error *local_err = NULL;
 
-    visit_type_int32(v, name, &boot_index, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_int32(v, name, &boot_index, errp);
+    if (*errp) {
+        return;
     }
     /* check whether bootindex is present in fw_boot_order list  */
-    check_boot_index(boot_index, &local_err);
-    if (local_err) {
-        goto out;
+    check_boot_index(boot_index, errp);
+    if (*errp) {
+        return;
     }
     /* change bootindex to a new one */
     *prop->bootindex = boot_index;
 
     add_boot_device_path(*prop->bootindex, prop->dev, prop->suffix);
-
-out:
-    error_propagate(errp, local_err);
 }
 
 static void property_release_bootindex(Object *obj, const char *name,
@@ -322,7 +315,6 @@ void device_add_bootindex_property(Object *obj, int32_t *bootindex,
                                    const char *name, const char *suffix,
                                    DeviceState *dev, Error **errp)
 {
-    Error *local_err = NULL;
     BootIndexProperty *prop = g_malloc0(sizeof(*prop));
 
     prop->bootindex = bootindex;
@@ -333,10 +325,9 @@ void device_add_bootindex_property(Object *obj, int32_t *bootindex,
                         device_get_bootindex,
                         device_set_bootindex,
                         property_release_bootindex,
-                        prop, &local_err);
+                        prop, errp);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         g_free(prop);
         return;
     }
diff --git a/chardev/char-socket.c b/chardev/char-socket.c
index 185fe38dda..4eb881f998 100644
--- a/chardev/char-socket.c
+++ b/chardev/char-socket.c
@@ -1031,13 +1031,11 @@ static int tcp_chr_wait_connected(Chardev *chr, Error **errp)
         if (s->is_listen) {
             tcp_chr_accept_server_sync(chr);
         } else {
-            Error *err = NULL;
-            if (tcp_chr_connect_client_sync(chr, &err) < 0) {
+            if (tcp_chr_connect_client_sync(chr, errp) < 0) {
                 if (s->reconnect_time) {
-                    error_free(err);
+                    error_free_errp(errp);
                     g_usleep(s->reconnect_time * 1000ULL * 1000ULL);
                 } else {
-                    error_propagate(errp, err);
                     return -1;
                 }
             }
diff --git a/chardev/char.c b/chardev/char.c
index 7b6b2cb123..d0385958c4 100644
--- a/chardev/char.c
+++ b/chardev/char.c
@@ -603,7 +603,6 @@ static const char *chardev_alias_translate(const char *name)
 
 ChardevBackend *qemu_chr_parse_opts(QemuOpts *opts, Error **errp)
 {
-    Error *local_err = NULL;
     const ChardevClass *cc;
     ChardevBackend *backend = NULL;
     const char *name = chardev_alias_translate(qemu_opt_get(opts, "backend"));
@@ -623,9 +622,8 @@ ChardevBackend *qemu_chr_parse_opts(QemuOpts *opts, Error **errp)
     backend->type = CHARDEV_BACKEND_KIND_NULL;
 
     if (cc->parse) {
-        cc->parse(opts, backend, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        cc->parse(opts, backend, errp);
+        if (*errp) {
             qapi_free_ChardevBackend(backend);
             return NULL;
         }
@@ -951,7 +949,6 @@ Chardev *qemu_chardev_new(const char *id, const char *typename,
 {
     Object *obj;
     Chardev *chr = NULL;
-    Error *local_err = NULL;
     bool be_opened = true;
 
     assert(g_str_has_prefix(typename, "chardev-"));
@@ -961,8 +958,8 @@ Chardev *qemu_chardev_new(const char *id, const char *typename,
     chr->label = g_strdup(id);
     chr->gcontext = gcontext;
 
-    qemu_char_open(chr, backend, &be_opened, &local_err);
-    if (local_err) {
+    qemu_char_open(chr, backend, &be_opened, errp);
+    if (*errp) {
         goto end;
     }
 
@@ -974,16 +971,15 @@ Chardev *qemu_chardev_new(const char *id, const char *typename,
     }
 
     if (id) {
-        object_property_add_child(get_chardevs_root(), id, obj, &local_err);
-        if (local_err) {
+        object_property_add_child(get_chardevs_root(), id, obj, errp);
+        if (*errp) {
             goto end;
         }
         object_unref(obj);
     }
 
 end:
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         object_unref(obj);
         return NULL;
     }
diff --git a/crypto/block-luks.c b/crypto/block-luks.c
index 743949adbf..023c4dfeea 100644
--- a/crypto/block-luks.c
+++ b/crypto/block-luks.c
@@ -631,7 +631,6 @@ qcrypto_block_luks_open(QCryptoBlock *block,
                         Error **errp)
 {
     QCryptoBlockLUKS *luks;
-    Error *local_err = NULL;
     int ret = 0;
     size_t i;
     ssize_t rv;
@@ -727,45 +726,40 @@ qcrypto_block_luks_open(QCryptoBlock *block,
         ivhash_name++;
 
         ivhash = qcrypto_block_luks_hash_name_lookup(ivhash_name,
-                                                     &local_err);
-        if (local_err) {
+                                                     errp);
+        if (*errp) {
             ret = -ENOTSUP;
-            error_propagate(errp, local_err);
             goto fail;
         }
     }
 
     ciphermode = qcrypto_block_luks_cipher_mode_lookup(luks->header.cipher_mode,
-                                                       &local_err);
-    if (local_err) {
+                                                       errp);
+    if (*errp) {
         ret = -ENOTSUP;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
     cipheralg = qcrypto_block_luks_cipher_name_lookup(luks->header.cipher_name,
                                                       ciphermode,
                                                       luks->header.key_bytes,
-                                                      &local_err);
-    if (local_err) {
+                                                      errp);
+    if (*errp) {
         ret = -ENOTSUP;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
     hash = qcrypto_block_luks_hash_name_lookup(luks->header.hash_spec,
-                                               &local_err);
-    if (local_err) {
+                                               errp);
+    if (*errp) {
         ret = -ENOTSUP;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
     ivalg = qcrypto_block_luks_ivgen_name_lookup(ivgen_name,
-                                                 &local_err);
-    if (local_err) {
+                                                 errp);
+    if (*errp) {
         ret = -ENOTSUP;
-        error_propagate(errp, local_err);
         goto fail;
     }
 
@@ -777,10 +771,9 @@ qcrypto_block_luks_open(QCryptoBlock *block,
         }
         ivcipheralg = qcrypto_block_luks_essiv_cipher(cipheralg,
                                                       ivhash,
-                                                      &local_err);
-        if (local_err) {
+                                                      errp);
+        if (*errp) {
             ret = -ENOTSUP;
-            error_propagate(errp, local_err);
             goto fail;
         }
     } else {
diff --git a/crypto/secret.c b/crypto/secret.c
index 1cf0ad0ce8..34400f42df 100644
--- a/crypto/secret.c
+++ b/crypto/secret.c
@@ -181,24 +181,21 @@ qcrypto_secret_prop_set_loaded(Object *obj,
     QCryptoSecret *secret = QCRYPTO_SECRET(obj);
 
     if (value) {
-        Error *local_err = NULL;
         uint8_t *input = NULL;
         size_t inputlen = 0;
         uint8_t *output = NULL;
         size_t outputlen = 0;
 
-        qcrypto_secret_load_data(secret, &input, &inputlen, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        qcrypto_secret_load_data(secret, &input, &inputlen, errp);
+        if (*errp) {
             return;
         }
 
         if (secret->keyid) {
             qcrypto_secret_decrypt(secret, input, inputlen,
-                                   &output, &outputlen, &local_err);
+                                   &output, &outputlen, errp);
             g_free(input);
-            if (local_err) {
-                error_propagate(errp, local_err);
+            if (*errp) {
                 return;
             }
             input = output;
@@ -206,10 +203,9 @@ qcrypto_secret_prop_set_loaded(Object *obj,
         } else {
             if (secret->format != QCRYPTO_SECRET_FORMAT_RAW) {
                 qcrypto_secret_decode(input, inputlen,
-                                      &output, &outputlen, &local_err);
+                                      &output, &outputlen, errp);
                 g_free(input);
-                if (local_err) {
-                    error_propagate(errp, local_err);
+                if (*errp) {
                     return;
                 }
                 input = output;
diff --git a/crypto/tlssession.c b/crypto/tlssession.c
index 33203e8ca7..3ba25c6834 100644
--- a/crypto/tlssession.c
+++ b/crypto/tlssession.c
@@ -262,7 +262,6 @@ qcrypto_tls_session_check_certificate(QCryptoTLSSession *session,
     unsigned int nCerts, i;
     time_t now;
     gnutls_x509_crt_t cert = NULL;
-    Error *err = NULL;
 
     now = time(NULL);
     if (now == ((time_t)-1)) {
@@ -354,9 +353,8 @@ qcrypto_tls_session_check_certificate(QCryptoTLSSession *session,
                 bool allow;
 
                 allow = qauthz_is_allowed_by_id(session->authzid,
-                                                session->peername, &err);
-                if (err) {
-                    error_propagate(errp, err);
+                                                session->peername, errp);
+                if (*errp) {
                     goto error;
                 }
                 if (!allow) {
diff --git a/dump/dump.c b/dump/dump.c
index 6fb6e1245a..4fe38a385a 100644
--- a/dump/dump.c
+++ b/dump/dump.c
@@ -388,22 +388,19 @@ static void write_memory(DumpState *s, GuestPhysBlock *block, ram_addr_t start,
                          int64_t size, Error **errp)
 {
     int64_t i;
-    Error *local_err = NULL;
 
     for (i = 0; i < size / s->dump_info.page_size; i++) {
         write_data(s, block->host_addr + start + i * s->dump_info.page_size,
-                   s->dump_info.page_size, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                   s->dump_info.page_size, errp);
+        if (*errp) {
             return;
         }
     }
 
     if ((size % s->dump_info.page_size) != 0) {
         write_data(s, block->host_addr + start + i * s->dump_info.page_size,
-                   size % s->dump_info.page_size, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                   size % s->dump_info.page_size, errp);
+        if (*errp) {
             return;
         }
     }
@@ -477,7 +474,6 @@ static void write_elf_loads(DumpState *s, Error **errp)
     MemoryMapping *memory_mapping;
     uint32_t phdr_index = 1;
     uint32_t max_index;
-    Error *local_err = NULL;
 
     if (s->have_section) {
         max_index = s->sh_info;
@@ -491,14 +487,13 @@ static void write_elf_loads(DumpState *s, Error **errp)
                          s, &offset, &filesz);
         if (s->dump_info.d_class == ELFCLASS64) {
             write_elf64_load(s, memory_mapping, phdr_index++, offset,
-                             filesz, &local_err);
+                             filesz, errp);
         } else {
             write_elf32_load(s, memory_mapping, phdr_index++, offset,
-                             filesz, &local_err);
+                             filesz, errp);
         }
 
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             return;
         }
 
@@ -511,8 +506,6 @@ static void write_elf_loads(DumpState *s, Error **errp)
 /* write elf header, PT_NOTE and elf note to vmcore. */
 static void dump_begin(DumpState *s, Error **errp)
 {
-    Error *local_err = NULL;
-
     /*
      * the vmcore's format is:
      *   --------------
@@ -539,73 +532,64 @@ static void dump_begin(DumpState *s, Error **errp)
 
     /* write elf header to vmcore */
     if (s->dump_info.d_class == ELFCLASS64) {
-        write_elf64_header(s, &local_err);
+        write_elf64_header(s, errp);
     } else {
-        write_elf32_header(s, &local_err);
+        write_elf32_header(s, errp);
     }
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return;
     }
 
     if (s->dump_info.d_class == ELFCLASS64) {
         /* write PT_NOTE to vmcore */
-        write_elf64_note(s, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        write_elf64_note(s, errp);
+        if (*errp) {
             return;
         }
 
         /* write all PT_LOAD to vmcore */
-        write_elf_loads(s, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        write_elf_loads(s, errp);
+        if (*errp) {
             return;
         }
 
         /* write section to vmcore */
         if (s->have_section) {
-            write_elf_section(s, 1, &local_err);
-            if (local_err) {
-                error_propagate(errp, local_err);
+            write_elf_section(s, 1, errp);
+            if (*errp) {
                 return;
             }
         }
 
         /* write notes to vmcore */
-        write_elf64_notes(fd_write_vmcore, s, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        write_elf64_notes(fd_write_vmcore, s, errp);
+        if (*errp) {
             return;
         }
     } else {
         /* write PT_NOTE to vmcore */
-        write_elf32_note(s, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        write_elf32_note(s, errp);
+        if (*errp) {
             return;
         }
 
         /* write all PT_LOAD to vmcore */
-        write_elf_loads(s, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        write_elf_loads(s, errp);
+        if (*errp) {
             return;
         }
 
         /* write section to vmcore */
         if (s->have_section) {
-            write_elf_section(s, 0, &local_err);
-            if (local_err) {
-                error_propagate(errp, local_err);
+            write_elf_section(s, 0, errp);
+            if (*errp) {
                 return;
             }
         }
 
         /* write notes to vmcore */
-        write_elf32_notes(fd_write_vmcore, s, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        write_elf32_notes(fd_write_vmcore, s, errp);
+        if (*errp) {
             return;
         }
     }
@@ -643,7 +627,6 @@ static void dump_iterate(DumpState *s, Error **errp)
 {
     GuestPhysBlock *block;
     int64_t size;
-    Error *local_err = NULL;
 
     do {
         block = s->next_block;
@@ -655,9 +638,8 @@ static void dump_iterate(DumpState *s, Error **errp)
                 size -= block->target_end - (s->begin + s->length);
             }
         }
-        write_memory(s, block, s->start, size, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        write_memory(s, block, s->start, size, errp);
+        if (*errp) {
             return;
         }
 
@@ -666,11 +648,8 @@ static void dump_iterate(DumpState *s, Error **errp)
 
 static void create_vmcore(DumpState *s, Error **errp)
 {
-    Error *local_err = NULL;
-
-    dump_begin(s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    dump_begin(s, errp);
+    if (*errp) {
         return;
     }
 
@@ -815,7 +794,6 @@ static void create_header32(DumpState *s, Error **errp)
     uint32_t bitmap_blocks;
     uint32_t status = 0;
     uint64_t offset_note;
-    Error *local_err = NULL;
 
     /* write common header, the version of kdump-compressed format is 6th */
     size = sizeof(DiskDumpHeader32);
@@ -891,9 +869,8 @@ static void create_header32(DumpState *s, Error **errp)
     s->note_buf_offset = 0;
 
     /* use s->note_buf to store notes temporarily */
-    write_elf32_notes(buf_write_note, s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    write_elf32_notes(buf_write_note, s, errp);
+    if (*errp) {
         goto out;
     }
     if (write_buffer(s->fd, offset_note, s->note_buf,
@@ -927,7 +904,6 @@ static void create_header64(DumpState *s, Error **errp)
     uint32_t bitmap_blocks;
     uint32_t status = 0;
     uint64_t offset_note;
-    Error *local_err = NULL;
 
     /* write common header, the version of kdump-compressed format is 6th */
     size = sizeof(DiskDumpHeader64);
@@ -1003,9 +979,8 @@ static void create_header64(DumpState *s, Error **errp)
     s->note_buf_offset = 0;
 
     /* use s->note_buf to store notes temporarily */
-    write_elf64_notes(buf_write_note, s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    write_elf64_notes(buf_write_note, s, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -1031,14 +1006,11 @@ out:
 
 static void write_dump_header(DumpState *s, Error **errp)
 {
-     Error *local_err = NULL;
-
     if (s->dump_info.d_class == ELFCLASS32) {
-        create_header32(s, &local_err);
+        create_header32(s, errp);
     } else {
-        create_header64(s, &local_err);
+        create_header64(s, errp);
     }
-    error_propagate(errp, local_err);
 }
 
 static size_t dump_bitmap_get_bufsize(DumpState *s)
@@ -1473,7 +1445,6 @@ out:
 static void create_kdump_vmcore(DumpState *s, Error **errp)
 {
     int ret;
-    Error *local_err = NULL;
 
     /*
      * the kdump-compressed format is:
@@ -1503,21 +1474,18 @@ static void create_kdump_vmcore(DumpState *s, Error **errp)
         return;
     }
 
-    write_dump_header(s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    write_dump_header(s, errp);
+    if (*errp) {
         return;
     }
 
-    write_dump_bitmap(s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    write_dump_bitmap(s, errp);
+    if (*errp) {
         return;
     }
 
-    write_dump_pages(s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    write_dump_pages(s, errp);
+    if (*errp) {
         return;
     }
 
@@ -1650,7 +1618,6 @@ static void dump_init(DumpState *s, int fd, bool has_format,
     VMCoreInfoState *vmci = vmcoreinfo_find();
     CPUState *cpu;
     int nr_cpus;
-    Error *err = NULL;
     int ret;
 
     s->has_format = has_format;
@@ -1769,9 +1736,8 @@ static void dump_init(DumpState *s, int fd, bool has_format,
 
     /* get memory mapping */
     if (paging) {
-        qemu_get_guest_memory_mapping(&s->list, &s->guest_phys_blocks, &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        qemu_get_guest_memory_mapping(&s->list, &s->guest_phys_blocks, errp);
+        if (*errp != NULL) {
             goto cleanup;
         }
     } else {
@@ -1870,33 +1836,31 @@ cleanup:
 /* this operation might be time consuming. */
 static void dump_process(DumpState *s, Error **errp)
 {
-    Error *local_err = NULL;
     DumpQueryResult *result = NULL;
 
     if (s->has_format && s->format == DUMP_GUEST_MEMORY_FORMAT_WIN_DMP) {
 #ifdef TARGET_X86_64
-        create_win_dump(s, &local_err);
+        create_win_dump(s, errp);
 #endif
     } else if (s->has_format && s->format != DUMP_GUEST_MEMORY_FORMAT_ELF) {
-        create_kdump_vmcore(s, &local_err);
+        create_kdump_vmcore(s, errp);
     } else {
-        create_vmcore(s, &local_err);
+        create_vmcore(s, errp);
     }
 
     /* make sure status is written after written_size updates */
     smp_wmb();
     atomic_set(&s->status,
-               (local_err ? DUMP_STATUS_FAILED : DUMP_STATUS_COMPLETED));
+               (*errp ? DUMP_STATUS_FAILED : DUMP_STATUS_COMPLETED));
 
     /* send DUMP_COMPLETED message (unconditionally) */
     result = qmp_query_dump(NULL);
     /* should never fail */
     assert(result);
-    qapi_event_send_dump_completed(result, !!local_err, (local_err ? \
-                                   error_get_pretty(local_err) : NULL));
+    qapi_event_send_dump_completed(result, !!*errp, (*errp ? \
+                                   error_get_pretty(*errp) : NULL));
     qapi_free_DumpQueryResult(result);
 
-    error_propagate(errp, local_err);
     dump_cleanup(s);
 }
 
@@ -1928,7 +1892,6 @@ void qmp_dump_guest_memory(bool paging, const char *file,
     const char *p;
     int fd = -1;
     DumpState *s;
-    Error *local_err = NULL;
     bool detach_p = false;
 
     if (runstate_check(RUN_STATE_INMIGRATE)) {
@@ -2013,9 +1976,8 @@ void qmp_dump_guest_memory(bool paging, const char *file,
     dump_state_prepare(s);
 
     dump_init(s, fd, has_format, format, paging, has_begin,
-              begin, length, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+              begin, length, errp);
+    if (*errp) {
         atomic_set(&s->status, DUMP_STATUS_FAILED);
         return;
     }
diff --git a/dump/win_dump.c b/dump/win_dump.c
index eda2a48974..73b3b454d4 100644
--- a/dump/win_dump.c
+++ b/dump/win_dump.c
@@ -62,13 +62,11 @@ static void write_runs(DumpState *s, WinDumpHeader64 *h, Error **errp)
 {
     WinDumpPhyMemDesc64 *desc = &h->PhysicalMemoryBlock;
     WinDumpPhyMemRun64 *run = desc->Run;
-    Error *local_err = NULL;
     int i;
 
     for (i = 0; i < desc->NumberOfRuns; i++) {
-        s->written_size += write_run(run + i, s->fd, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        s->written_size += write_run(run + i, s->fd, errp);
+        if (*errp) {
             return;
         }
     }
@@ -322,7 +320,6 @@ void create_win_dump(DumpState *s, Error **errp)
     X86CPU *first_x86_cpu = X86_CPU(first_cpu);
     uint64_t saved_cr3 = first_x86_cpu->env.cr[3];
     struct saved_context *saved_ctx = NULL;
-    Error *local_err = NULL;
 
     if (s->guest_note_size != sizeof(WinDumpHeader64) +
             VMCOREINFO_ELF_NOTE_HDR_SIZE) {
@@ -330,9 +327,8 @@ void create_win_dump(DumpState *s, Error **errp)
         return;
     }
 
-    check_header(h, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    check_header(h, errp);
+    if (*errp) {
         return;
     }
 
@@ -343,9 +339,8 @@ void create_win_dump(DumpState *s, Error **errp)
 
     first_x86_cpu->env.cr[3] = h->DirectoryTableBase;
 
-    check_kdbg(h, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    check_kdbg(h, errp);
+    if (*errp) {
         goto out_cr3;
     }
 
@@ -358,9 +353,8 @@ void create_win_dump(DumpState *s, Error **errp)
      * to determine if the system-saved context is valid
      */
 
-    patch_and_save_context(h, saved_ctx, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    patch_and_save_context(h, saved_ctx, errp);
+    if (*errp) {
         goto out_free;
     }
 
@@ -372,9 +366,8 @@ void create_win_dump(DumpState *s, Error **errp)
         goto out_restore;
     }
 
-    write_runs(s, h, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    write_runs(s, h, errp);
+    if (*errp) {
         goto out_restore;
     }
 
diff --git a/exec.c b/exec.c
index 8b998974f8..a0aaa1b24a 100644
--- a/exec.c
+++ b/exec.c
@@ -2338,7 +2338,6 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
                                  Error **errp)
 {
     RAMBlock *new_block;
-    Error *local_err = NULL;
     int64_t file_size;
 
     /* Just support these ram flags by now. */
@@ -2386,10 +2385,9 @@ RAMBlock *qemu_ram_alloc_from_fd(ram_addr_t size, MemoryRegion *mr,
         return NULL;
     }
 
-    ram_block_add(new_block, &local_err, ram_flags & RAM_SHARED);
-    if (local_err) {
+    ram_block_add(new_block, errp, ram_flags & RAM_SHARED);
+    if (*errp) {
         g_free(new_block);
-        error_propagate(errp, local_err);
         return NULL;
     }
     return new_block;
@@ -2432,7 +2430,6 @@ RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
                                   MemoryRegion *mr, Error **errp)
 {
     RAMBlock *new_block;
-    Error *local_err = NULL;
 
     size = HOST_PAGE_ALIGN(size);
     max_size = HOST_PAGE_ALIGN(max_size);
@@ -2451,10 +2448,9 @@ RAMBlock *qemu_ram_alloc_internal(ram_addr_t size, ram_addr_t max_size,
     if (resizeable) {
         new_block->flags |= RAM_RESIZEABLE;
     }
-    ram_block_add(new_block, &local_err, share);
-    if (local_err) {
+    ram_block_add(new_block, errp, share);
+    if (*errp) {
         g_free(new_block);
-        error_propagate(errp, local_err);
         return NULL;
     }
     return new_block;
diff --git a/hw/9pfs/9p-local.c b/hw/9pfs/9p-local.c
index 08e673a79c..730d58e9ef 100644
--- a/hw/9pfs/9p-local.c
+++ b/hw/9pfs/9p-local.c
@@ -1479,7 +1479,6 @@ static int local_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)
 {
     const char *sec_model = qemu_opt_get(opts, "security_model");
     const char *path = qemu_opt_get(opts, "path");
-    Error *local_err = NULL;
 
     if (!sec_model) {
         error_setg(errp, "security_model property not set");
@@ -1507,9 +1506,9 @@ static int local_parse_opts(QemuOpts *opts, FsDriverEntry *fse, Error **errp)
         return -1;
     }
 
-    fsdev_throttle_parse_opts(opts, &fse->fst, &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+    fsdev_throttle_parse_opts(opts, &fse->fst, errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "invalid throttle configuration: ");
         return -1;
     }
diff --git a/hw/acpi/core.c b/hw/acpi/core.c
index 45cbed49ab..b644616697 100644
--- a/hw/acpi/core.c
+++ b/hw/acpi/core.c
@@ -239,7 +239,6 @@ static void acpi_table_install(const char unsigned *blob, size_t bloblen,
 void acpi_table_add(const QemuOpts *opts, Error **errp)
 {
     AcpiTableOptions *hdrs = NULL;
-    Error *err = NULL;
     char **pathnames = NULL;
     char **cur;
     size_t bloblen = 0;
@@ -249,21 +248,21 @@ void acpi_table_add(const QemuOpts *opts, Error **errp)
         Visitor *v;
 
         v = opts_visitor_new(opts);
-        visit_type_AcpiTableOptions(v, NULL, &hdrs, &err);
+        visit_type_AcpiTableOptions(v, NULL, &hdrs, errp);
         visit_free(v);
     }
 
-    if (err) {
+    if (*errp) {
         goto out;
     }
     if (hdrs->has_file == hdrs->has_data) {
-        error_setg(&err, "'-acpitable' requires one of 'data' or 'file'");
+        error_setg(errp, "'-acpitable' requires one of 'data' or 'file'");
         goto out;
     }
 
     pathnames = g_strsplit(hdrs->has_file ? hdrs->file : hdrs->data, ":", 0);
     if (pathnames == NULL || pathnames[0] == NULL) {
-        error_setg(&err, "'-acpitable' requires at least one pathname");
+        error_setg(errp, "'-acpitable' requires at least one pathname");
         goto out;
     }
 
@@ -272,7 +271,7 @@ void acpi_table_add(const QemuOpts *opts, Error **errp)
         int fd = open(*cur, O_RDONLY | O_BINARY);
 
         if (fd < 0) {
-            error_setg(&err, "can't open file %s: %s", *cur, strerror(errno));
+            error_setg(errp, "can't open file %s: %s", *cur, strerror(errno));
             goto out;
         }
 
@@ -288,7 +287,7 @@ void acpi_table_add(const QemuOpts *opts, Error **errp)
                 memcpy(blob + bloblen, data, r);
                 bloblen += r;
             } else if (errno != EINTR) {
-                error_setg(&err, "can't read file %s: %s",
+                error_setg(errp, "can't read file %s: %s",
                            *cur, strerror(errno));
                 close(fd);
                 goto out;
@@ -298,14 +297,12 @@ void acpi_table_add(const QemuOpts *opts, Error **errp)
         close(fd);
     }
 
-    acpi_table_install(blob, bloblen, hdrs->has_file, hdrs, &err);
+    acpi_table_install(blob, bloblen, hdrs->has_file, hdrs, errp);
 
 out:
     g_free(blob);
     g_strfreev(pathnames);
     qapi_free_AcpiTableOptions(hdrs);
-
-    error_propagate(errp, err);
 }
 
 unsigned acpi_table_len(void *current)
diff --git a/hw/acpi/ich9.c b/hw/acpi/ich9.c
index 2034dd749e..232b550fa2 100644
--- a/hw/acpi/ich9.c
+++ b/hw/acpi/ich9.c
@@ -370,16 +370,13 @@ static void ich9_pm_set_disable_s3(Object *obj, Visitor *v, const char *name,
                                    void *opaque, Error **errp)
 {
     ICH9LPCPMRegs *pm = opaque;
-    Error *local_err = NULL;
     uint8_t value;
 
-    visit_type_uint8(v, name, &value, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_uint8(v, name, &value, errp);
+    if (*errp) {
+        return;
     }
     pm->disable_s3 = value;
-out:
-    error_propagate(errp, local_err);
 }
 
 static void ich9_pm_get_disable_s4(Object *obj, Visitor *v, const char *name,
@@ -395,16 +392,13 @@ static void ich9_pm_set_disable_s4(Object *obj, Visitor *v, const char *name,
                                    void *opaque, Error **errp)
 {
     ICH9LPCPMRegs *pm = opaque;
-    Error *local_err = NULL;
     uint8_t value;
 
-    visit_type_uint8(v, name, &value, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_uint8(v, name, &value, errp);
+    if (*errp) {
+        return;
     }
     pm->disable_s4 = value;
-out:
-    error_propagate(errp, local_err);
 }
 
 static void ich9_pm_get_s4_val(Object *obj, Visitor *v, const char *name,
@@ -420,16 +414,13 @@ static void ich9_pm_set_s4_val(Object *obj, Visitor *v, const char *name,
                                void *opaque, Error **errp)
 {
     ICH9LPCPMRegs *pm = opaque;
-    Error *local_err = NULL;
     uint8_t value;
 
-    visit_type_uint8(v, name, &value, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_uint8(v, name, &value, errp);
+    if (*errp) {
+        return;
     }
     pm->s4_val = value;
-out:
-    error_propagate(errp, local_err);
 }
 
 static bool ich9_pm_get_enable_tco(Object *obj, Error **errp)
diff --git a/hw/acpi/memory_hotplug.c b/hw/acpi/memory_hotplug.c
index 9483d66e86..38f36aa9d8 100644
--- a/hw/acpi/memory_hotplug.c
+++ b/hw/acpi/memory_hotplug.c
@@ -241,12 +241,10 @@ static MemStatus *
 acpi_memory_slot_status(MemHotplugState *mem_st,
                         DeviceState *dev, Error **errp)
 {
-    Error *local_err = NULL;
     int slot = object_property_get_int(OBJECT(dev), PC_DIMM_SLOT_PROP,
-                                       &local_err);
+                                       errp);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return NULL;
     }
 
diff --git a/hw/arm/allwinner-a10.c b/hw/arm/allwinner-a10.c
index 118032c8c7..02932fec88 100644
--- a/hw/arm/allwinner-a10.c
+++ b/hw/arm/allwinner-a10.c
@@ -51,19 +51,16 @@ static void aw_a10_realize(DeviceState *dev, Error **errp)
     SysBusDevice *sysbusdev;
     uint8_t i;
     qemu_irq fiq, irq;
-    Error *err = NULL;
 
-    object_property_set_bool(OBJECT(&s->cpu), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->cpu), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     irq = qdev_get_gpio_in(DEVICE(&s->cpu), ARM_CPU_IRQ);
     fiq = qdev_get_gpio_in(DEVICE(&s->cpu), ARM_CPU_FIQ);
 
-    object_property_set_bool(OBJECT(&s->intc), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->intc), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     sysbusdev = SYS_BUS_DEVICE(&s->intc);
@@ -74,9 +71,8 @@ static void aw_a10_realize(DeviceState *dev, Error **errp)
         s->irq[i] = qdev_get_gpio_in(DEVICE(&s->intc), i);
     }
 
-    object_property_set_bool(OBJECT(&s->timer), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->timer), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     sysbusdev = SYS_BUS_DEVICE(&s->timer);
@@ -98,18 +94,16 @@ static void aw_a10_realize(DeviceState *dev, Error **errp)
         qemu_check_nic_model(&nd_table[0], TYPE_AW_EMAC);
         qdev_set_nic_properties(DEVICE(&s->emac), &nd_table[0]);
     }
-    object_property_set_bool(OBJECT(&s->emac), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->emac), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     sysbusdev = SYS_BUS_DEVICE(&s->emac);
     sysbus_mmio_map(sysbusdev, 0, AW_A10_EMAC_BASE);
     sysbus_connect_irq(sysbusdev, 0, s->irq[55]);
 
-    object_property_set_bool(OBJECT(&s->sata), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->sata), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->sata), 0, AW_A10_SATA_BASE);
diff --git a/hw/arm/armv7m.c b/hw/arm/armv7m.c
index 7a3c48f002..33ae9ada90 100644
--- a/hw/arm/armv7m.c
+++ b/hw/arm/armv7m.c
@@ -150,7 +150,6 @@ static void armv7m_realize(DeviceState *dev, Error **errp)
 {
     ARMv7MState *s = ARMV7M(dev);
     SysBusDevice *sbd;
-    Error *err = NULL;
     int i;
 
     if (!s->board_memory) {
@@ -161,50 +160,44 @@ static void armv7m_realize(DeviceState *dev, Error **errp)
     memory_region_add_subregion_overlap(&s->container, 0, s->board_memory, -1);
 
     s->cpu = ARM_CPU(object_new_with_props(s->cpu_type, OBJECT(s), "cpu",
-                                           &err, NULL));
-    if (err != NULL) {
-        error_propagate(errp, err);
+                                           errp, NULL));
+    if (*errp != NULL) {
         return;
     }
 
     object_property_set_link(OBJECT(s->cpu), OBJECT(&s->container), "memory",
                              &error_abort);
     if (object_property_find(OBJECT(s->cpu), "idau", NULL)) {
-        object_property_set_link(OBJECT(s->cpu), s->idau, "idau", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        object_property_set_link(OBJECT(s->cpu), s->idau, "idau", errp);
+        if (*errp != NULL) {
             return;
         }
     }
     if (object_property_find(OBJECT(s->cpu), "init-svtor", NULL)) {
         object_property_set_uint(OBJECT(s->cpu), s->init_svtor,
-                                 "init-svtor", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+                                 "init-svtor", errp);
+        if (*errp != NULL) {
             return;
         }
     }
     if (object_property_find(OBJECT(s->cpu), "start-powered-off", NULL)) {
         object_property_set_bool(OBJECT(s->cpu), s->start_powered_off,
-                                 "start-powered-off", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+                                 "start-powered-off", errp);
+        if (*errp != NULL) {
             return;
         }
     }
     if (object_property_find(OBJECT(s->cpu), "vfp", NULL)) {
         object_property_set_bool(OBJECT(s->cpu), s->vfp,
-                                 "vfp", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+                                 "vfp", errp);
+        if (*errp != NULL) {
             return;
         }
     }
     if (object_property_find(OBJECT(s->cpu), "dsp", NULL)) {
         object_property_set_bool(OBJECT(s->cpu), s->dsp,
-                                 "dsp", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+                                 "dsp", errp);
+        if (*errp != NULL) {
             return;
         }
     }
@@ -216,16 +209,14 @@ static void armv7m_realize(DeviceState *dev, Error **errp)
     s->cpu->env.nvic = &s->nvic;
     s->nvic.cpu = s->cpu;
 
-    object_property_set_bool(OBJECT(s->cpu), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(s->cpu), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
     /* Note that we must realize the NVIC after the CPU */
-    object_property_set_bool(OBJECT(&s->nvic), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->nvic), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
@@ -250,16 +241,14 @@ static void armv7m_realize(DeviceState *dev, Error **errp)
             Object *obj = OBJECT(&s->bitband[i]);
             SysBusDevice *sbd = SYS_BUS_DEVICE(&s->bitband[i]);
 
-            object_property_set_int(obj, bitband_input_addr[i], "base", &err);
-            if (err != NULL) {
-                error_propagate(errp, err);
+            object_property_set_int(obj, bitband_input_addr[i], "base", errp);
+            if (*errp != NULL) {
                 return;
             }
             object_property_set_link(obj, OBJECT(s->board_memory),
                                      "source-memory", &error_abort);
-            object_property_set_bool(obj, true, "realized", &err);
-            if (err != NULL) {
-                error_propagate(errp, err);
+            object_property_set_bool(obj, true, "realized", errp);
+            if (*errp != NULL) {
                 return;
             }
 
diff --git a/hw/arm/bcm2835_peripherals.c b/hw/arm/bcm2835_peripherals.c
index 8984e2e91f..0301322f7b 100644
--- a/hw/arm/bcm2835_peripherals.c
+++ b/hw/arm/bcm2835_peripherals.c
@@ -112,14 +112,13 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
     BCM2835PeripheralState *s = BCM2835_PERIPHERALS(dev);
     Object *obj;
     MemoryRegion *ram;
-    Error *err = NULL;
     uint64_t ram_size, vcram_size;
     int n;
 
-    obj = object_property_get_link(OBJECT(dev), "ram", &err);
+    obj = object_property_get_link(OBJECT(dev), "ram", errp);
     if (obj == NULL) {
         error_setg(errp, "%s: required ram link not found: %s",
-                   __func__, error_get_pretty(err));
+                   __func__, error_get_pretty(*errp));
         return;
     }
 
@@ -143,9 +142,8 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
     }
 
     /* Interrupt Controller */
-    object_property_set_bool(OBJECT(&s->ic), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->ic), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -155,9 +153,8 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
 
     /* UART0 */
     qdev_prop_set_chr(DEVICE(&s->uart0), "chardev", serial_hd(0));
-    object_property_set_bool(OBJECT(&s->uart0), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->uart0), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -169,9 +166,8 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
     /* AUX / UART1 */
     qdev_prop_set_chr(DEVICE(&s->aux), "chardev", serial_hd(1));
 
-    object_property_set_bool(OBJECT(&s->aux), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->aux), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -182,9 +178,8 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
                                INTERRUPT_AUX));
 
     /* Mailboxes */
-    object_property_set_bool(OBJECT(&s->mboxes), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->mboxes), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -195,22 +190,19 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
                                INTERRUPT_ARM_MAILBOX));
 
     /* Framebuffer */
-    vcram_size = object_property_get_uint(OBJECT(s), "vcram-size", &err);
-    if (err) {
-        error_propagate(errp, err);
+    vcram_size = object_property_get_uint(OBJECT(s), "vcram-size", errp);
+    if (*errp) {
         return;
     }
 
     object_property_set_uint(OBJECT(&s->fb), ram_size - vcram_size,
-                             "vcram-base", &err);
-    if (err) {
-        error_propagate(errp, err);
+                             "vcram-base", errp);
+    if (*errp) {
         return;
     }
 
-    object_property_set_bool(OBJECT(&s->fb), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->fb), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -220,9 +212,8 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
                        qdev_get_gpio_in(DEVICE(&s->mboxes), MBOX_CHAN_FB));
 
     /* Property channel */
-    object_property_set_bool(OBJECT(&s->property), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->property), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -233,9 +224,8 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
                       qdev_get_gpio_in(DEVICE(&s->mboxes), MBOX_CHAN_PROPERTY));
 
     /* Random Number Generator */
-    object_property_set_bool(OBJECT(&s->rng), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->rng), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -252,19 +242,17 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
      * For the exact details please refer to the Arasan documentation:
      *   SD3.0_Host_AHB_eMMC4.4_Usersguide_ver5.9_jan11_10.pdf
      */
-    object_property_set_uint(OBJECT(&s->sdhci), 3, "sd-spec-version", &err);
+    object_property_set_uint(OBJECT(&s->sdhci), 3, "sd-spec-version", errp);
     object_property_set_uint(OBJECT(&s->sdhci), BCM2835_SDHC_CAPAREG, "capareg",
-                             &err);
+                             errp);
     object_property_set_bool(OBJECT(&s->sdhci), true, "pending-insert-quirk",
-                             &err);
-    if (err) {
-        error_propagate(errp, err);
+                             errp);
+    if (*errp) {
         return;
     }
 
-    object_property_set_bool(OBJECT(&s->sdhci), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->sdhci), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -275,9 +263,8 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
                                INTERRUPT_ARASANSDIO));
 
     /* SDHOST */
-    object_property_set_bool(OBJECT(&s->sdhost), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->sdhost), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -288,9 +275,8 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
                                INTERRUPT_SDIO));
 
     /* DMA Channels */
-    object_property_set_bool(OBJECT(&s->dma), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->dma), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -307,9 +293,8 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
     }
 
     /* GPIO */
-    object_property_set_bool(OBJECT(&s->gpio), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gpio), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -317,9 +302,8 @@ static void bcm2835_peripherals_realize(DeviceState *dev, Error **errp)
                 sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->gpio), 0));
 
     object_property_add_alias(OBJECT(s), "sd-bus", OBJECT(&s->gpio), "sd-bus",
-                              &err);
-    if (err) {
-        error_propagate(errp, err);
+                              errp);
+    if (*errp) {
         return;
     }
 }
diff --git a/hw/arm/bcm2836.c b/hw/arm/bcm2836.c
index 493a913f89..cd605eb53d 100644
--- a/hw/arm/bcm2836.c
+++ b/hw/arm/bcm2836.c
@@ -72,34 +72,30 @@ static void bcm2836_realize(DeviceState *dev, Error **errp)
     BCM283XClass *bc = BCM283X_GET_CLASS(dev);
     const BCM283XInfo *info = bc->info;
     Object *obj;
-    Error *err = NULL;
     int n;
 
     /* common peripherals from bcm2835 */
 
-    obj = object_property_get_link(OBJECT(dev), "ram", &err);
+    obj = object_property_get_link(OBJECT(dev), "ram", errp);
     if (obj == NULL) {
         error_setg(errp, "%s: required ram link not found: %s",
-                   __func__, error_get_pretty(err));
+                   __func__, error_get_pretty(*errp));
         return;
     }
 
-    object_property_add_const_link(OBJECT(&s->peripherals), "ram", obj, &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_add_const_link(OBJECT(&s->peripherals), "ram", obj, errp);
+    if (*errp) {
         return;
     }
 
-    object_property_set_bool(OBJECT(&s->peripherals), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->peripherals), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
     object_property_add_alias(OBJECT(s), "sd-bus", OBJECT(&s->peripherals),
-                              "sd-bus", &err);
-    if (err) {
-        error_propagate(errp, err);
+                              "sd-bus", errp);
+    if (*errp) {
         return;
     }
 
@@ -107,9 +103,8 @@ static void bcm2836_realize(DeviceState *dev, Error **errp)
                             BCM2836_PERI_BASE, 1);
 
     /* bcm2836 interrupt controller (and mailboxes, etc.) */
-    object_property_set_bool(OBJECT(&s->control), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->control), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -127,23 +122,20 @@ static void bcm2836_realize(DeviceState *dev, Error **errp)
         /* set periphbase/CBAR value for CPU-local registers */
         object_property_set_int(OBJECT(&s->cpus[n]),
                                 BCM2836_PERI_BASE + MCORE_OFFSET,
-                                "reset-cbar", &err);
-        if (err) {
-            error_propagate(errp, err);
+                                "reset-cbar", errp);
+        if (*errp) {
             return;
         }
 
         /* start powered off if not enabled */
         object_property_set_bool(OBJECT(&s->cpus[n]), n >= s->enabled_cpus,
-                                 "start-powered-off", &err);
-        if (err) {
-            error_propagate(errp, err);
+                                 "start-powered-off", errp);
+        if (*errp) {
             return;
         }
 
-        object_property_set_bool(OBJECT(&s->cpus[n]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->cpus[n]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
diff --git a/hw/arm/digic.c b/hw/arm/digic.c
index 22434a65a2..024aa10509 100644
--- a/hw/arm/digic.c
+++ b/hw/arm/digic.c
@@ -56,26 +56,22 @@ static void digic_init(Object *obj)
 static void digic_realize(DeviceState *dev, Error **errp)
 {
     DigicState *s = DIGIC(dev);
-    Error *err = NULL;
     SysBusDevice *sbd;
     int i;
 
-    object_property_set_bool(OBJECT(&s->cpu), true, "reset-hivecs", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->cpu), true, "reset-hivecs", errp);
+    if (*errp != NULL) {
         return;
     }
 
-    object_property_set_bool(OBJECT(&s->cpu), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->cpu), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
     for (i = 0; i < DIGIC4_NB_TIMERS; i++) {
-        object_property_set_bool(OBJECT(&s->timer[i]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->timer[i]), true, "realized", errp);
+        if (*errp != NULL) {
             return;
         }
 
@@ -84,9 +80,8 @@ static void digic_realize(DeviceState *dev, Error **errp)
     }
 
     qdev_prop_set_chr(DEVICE(&s->uart), "chardev", serial_hd(0));
-    object_property_set_bool(OBJECT(&s->uart), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->uart), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/hw/arm/fsl-imx25.c b/hw/arm/fsl-imx25.c
index 3cb5a8fdfd..2a8aa8d188 100644
--- a/hw/arm/fsl-imx25.c
+++ b/hw/arm/fsl-imx25.c
@@ -77,17 +77,14 @@ static void fsl_imx25_realize(DeviceState *dev, Error **errp)
 {
     FslIMX25State *s = FSL_IMX25(dev);
     uint8_t i;
-    Error *err = NULL;
 
-    object_property_set_bool(OBJECT(&s->cpu), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->cpu), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
-    object_property_set_bool(OBJECT(&s->avic), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->avic), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->avic), 0, FSL_IMX25_AVIC_ADDR);
@@ -96,9 +93,8 @@ static void fsl_imx25_realize(DeviceState *dev, Error **errp)
     sysbus_connect_irq(SYS_BUS_DEVICE(&s->avic), 1,
                        qdev_get_gpio_in(DEVICE(&s->cpu), ARM_CPU_FIQ));
 
-    object_property_set_bool(OBJECT(&s->ccm), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->ccm), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->ccm), 0, FSL_IMX25_CCM_ADDR);
@@ -118,9 +114,8 @@ static void fsl_imx25_realize(DeviceState *dev, Error **errp)
 
         qdev_prop_set_chr(DEVICE(&s->uart[i]), "chardev", serial_hd(i));
 
-        object_property_set_bool(OBJECT(&s->uart[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->uart[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_mmio_map(SYS_BUS_DEVICE(&s->uart[i]), 0, serial_table[i].addr);
@@ -143,9 +138,8 @@ static void fsl_imx25_realize(DeviceState *dev, Error **errp)
 
         s->gpt[i].ccm = IMX_CCM(&s->ccm);
 
-        object_property_set_bool(OBJECT(&s->gpt[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->gpt[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_mmio_map(SYS_BUS_DEVICE(&s->gpt[i]), 0, gpt_table[i].addr);
@@ -166,9 +160,8 @@ static void fsl_imx25_realize(DeviceState *dev, Error **errp)
 
         s->epit[i].ccm = IMX_CCM(&s->ccm);
 
-        object_property_set_bool(OBJECT(&s->epit[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->epit[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_mmio_map(SYS_BUS_DEVICE(&s->epit[i]), 0, epit_table[i].addr);
@@ -179,9 +172,8 @@ static void fsl_imx25_realize(DeviceState *dev, Error **errp)
 
     qdev_set_nic_properties(DEVICE(&s->fec), &nd_table[0]);
 
-    object_property_set_bool(OBJECT(&s->fec), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->fec), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->fec), 0, FSL_IMX25_FEC_ADDR);
@@ -200,9 +192,8 @@ static void fsl_imx25_realize(DeviceState *dev, Error **errp)
             { FSL_IMX25_I2C3_ADDR, FSL_IMX25_I2C3_IRQ }
         };
 
-        object_property_set_bool(OBJECT(&s->i2c[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->i2c[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_mmio_map(SYS_BUS_DEVICE(&s->i2c[i]), 0, i2c_table[i].addr);
@@ -223,9 +214,8 @@ static void fsl_imx25_realize(DeviceState *dev, Error **errp)
             { FSL_IMX25_GPIO4_ADDR, FSL_IMX25_GPIO4_IRQ }
         };
 
-        object_property_set_bool(OBJECT(&s->gpio[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->gpio[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_mmio_map(SYS_BUS_DEVICE(&s->gpio[i]), 0, gpio_table[i].addr);
@@ -237,17 +227,15 @@ static void fsl_imx25_realize(DeviceState *dev, Error **errp)
 
     /* initialize 2 x 16 KB ROM */
     memory_region_init_rom(&s->rom[0], NULL,
-                           "imx25.rom0", FSL_IMX25_ROM0_SIZE, &err);
-    if (err) {
-        error_propagate(errp, err);
+                           "imx25.rom0", FSL_IMX25_ROM0_SIZE, errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(get_system_memory(), FSL_IMX25_ROM0_ADDR,
                                 &s->rom[0]);
     memory_region_init_rom(&s->rom[1], NULL,
-                           "imx25.rom1", FSL_IMX25_ROM1_SIZE, &err);
-    if (err) {
-        error_propagate(errp, err);
+                           "imx25.rom1", FSL_IMX25_ROM1_SIZE, errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(get_system_memory(), FSL_IMX25_ROM1_ADDR,
@@ -255,9 +243,8 @@ static void fsl_imx25_realize(DeviceState *dev, Error **errp)
 
     /* initialize internal RAM (128 KB) */
     memory_region_init_ram(&s->iram, NULL, "imx25.iram", FSL_IMX25_IRAM_SIZE,
-                           &err);
-    if (err) {
-        error_propagate(errp, err);
+                           errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(get_system_memory(), FSL_IMX25_IRAM_ADDR,
diff --git a/hw/arm/fsl-imx31.c b/hw/arm/fsl-imx31.c
index 55e90d104b..d1c18ec727 100644
--- a/hw/arm/fsl-imx31.c
+++ b/hw/arm/fsl-imx31.c
@@ -69,17 +69,14 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
 {
     FslIMX31State *s = FSL_IMX31(dev);
     uint16_t i;
-    Error *err = NULL;
 
-    object_property_set_bool(OBJECT(&s->cpu), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->cpu), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
-    object_property_set_bool(OBJECT(&s->avic), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->avic), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->avic), 0, FSL_IMX31_AVIC_ADDR);
@@ -88,9 +85,8 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
     sysbus_connect_irq(SYS_BUS_DEVICE(&s->avic), 1,
                        qdev_get_gpio_in(DEVICE(&s->cpu), ARM_CPU_FIQ));
 
-    object_property_set_bool(OBJECT(&s->ccm), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->ccm), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->ccm), 0, FSL_IMX31_CCM_ADDR);
@@ -107,9 +103,8 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
 
         qdev_prop_set_chr(DEVICE(&s->uart[i]), "chardev", serial_hd(i));
 
-        object_property_set_bool(OBJECT(&s->uart[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->uart[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
@@ -121,9 +116,8 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
 
     s->gpt.ccm = IMX_CCM(&s->ccm);
 
-    object_property_set_bool(OBJECT(&s->gpt), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gpt), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -143,9 +137,8 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
 
         s->epit[i].ccm = IMX_CCM(&s->ccm);
 
-        object_property_set_bool(OBJECT(&s->epit[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->epit[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
@@ -167,9 +160,8 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
         };
 
         /* Initialize the I2C */
-        object_property_set_bool(OBJECT(&s->i2c[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->i2c[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
         /* Map I2C memory */
@@ -193,9 +185,8 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
 
         object_property_set_bool(OBJECT(&s->gpio[i]), false, "has-edge-sel",
                                  &error_abort);
-        object_property_set_bool(OBJECT(&s->gpio[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->gpio[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_mmio_map(SYS_BUS_DEVICE(&s->gpio[i]), 0, gpio_table[i].addr);
@@ -207,9 +198,8 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
 
     /* On a real system, the first 16k is a `secure boot rom' */
     memory_region_init_rom(&s->secure_rom, NULL, "imx31.secure_rom",
-                           FSL_IMX31_SECURE_ROM_SIZE, &err);
-    if (err) {
-        error_propagate(errp, err);
+                           FSL_IMX31_SECURE_ROM_SIZE, errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(get_system_memory(), FSL_IMX31_SECURE_ROM_ADDR,
@@ -217,9 +207,8 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
 
     /* There is also a 16k ROM */
     memory_region_init_rom(&s->rom, NULL, "imx31.rom",
-                           FSL_IMX31_ROM_SIZE, &err);
-    if (err) {
-        error_propagate(errp, err);
+                           FSL_IMX31_ROM_SIZE, errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(get_system_memory(), FSL_IMX31_ROM_ADDR,
@@ -227,9 +216,8 @@ static void fsl_imx31_realize(DeviceState *dev, Error **errp)
 
     /* initialize internal RAM (16 KB) */
     memory_region_init_ram(&s->iram, NULL, "imx31.iram", FSL_IMX31_IRAM_SIZE,
-                           &err);
-    if (err) {
-        error_propagate(errp, err);
+                           errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(get_system_memory(), FSL_IMX31_IRAM_ADDR,
diff --git a/hw/arm/fsl-imx6.c b/hw/arm/fsl-imx6.c
index 552145b24e..3b1310f91c 100644
--- a/hw/arm/fsl-imx6.c
+++ b/hw/arm/fsl-imx6.c
@@ -100,7 +100,6 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
     MachineState *ms = MACHINE(qdev_get_machine());
     FslIMX6State *s = FSL_IMX6(dev);
     uint16_t i;
-    Error *err = NULL;
     unsigned int smp_cpus = ms->smp.cpus;
 
     if (smp_cpus > FSL_IMX6_NUM_CPUS) {
@@ -123,9 +122,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
                                      "start-powered-off", &error_abort);
         }
 
-        object_property_set_bool(OBJECT(&s->cpu[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->cpu[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
     }
@@ -137,9 +135,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
                             FSL_IMX6_MAX_IRQ + GIC_INTERNAL, "num-irq",
                             &error_abort);
 
-    object_property_set_bool(OBJECT(&s->a9mpcore), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->a9mpcore), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->a9mpcore), 0, FSL_IMX6_A9MPCORE_ADDR);
@@ -151,16 +148,14 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
                            qdev_get_gpio_in(DEVICE(&s->cpu[i]), ARM_CPU_FIQ));
     }
 
-    object_property_set_bool(OBJECT(&s->ccm), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->ccm), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->ccm), 0, FSL_IMX6_CCM_ADDR);
 
-    object_property_set_bool(OBJECT(&s->src), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->src), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->src), 0, FSL_IMX6_SRC_ADDR);
@@ -180,9 +175,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
 
         qdev_prop_set_chr(DEVICE(&s->uart[i]), "chardev", serial_hd(i));
 
-        object_property_set_bool(OBJECT(&s->uart[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->uart[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
@@ -194,9 +188,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
 
     s->gpt.ccm = IMX_CCM(&s->ccm);
 
-    object_property_set_bool(OBJECT(&s->gpt), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gpt), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -217,9 +210,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
 
         s->epit[i].ccm = IMX_CCM(&s->ccm);
 
-        object_property_set_bool(OBJECT(&s->epit[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->epit[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
@@ -240,9 +232,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
             { FSL_IMX6_I2C3_ADDR, FSL_IMX6_I2C3_IRQ }
         };
 
-        object_property_set_bool(OBJECT(&s->i2c[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->i2c[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
@@ -300,9 +291,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
                                  &error_abort);
         object_property_set_bool(OBJECT(&s->gpio[i]), true, "has-upper-pin-irq",
                                  &error_abort);
-        object_property_set_bool(OBJECT(&s->gpio[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->gpio[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
@@ -329,12 +319,11 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
 
         /* UHS-I SDIO3.0 SDR104 1.8V ADMA */
         object_property_set_uint(OBJECT(&s->esdhc[i]), 3, "sd-spec-version",
-                                 &err);
+                                 errp);
         object_property_set_uint(OBJECT(&s->esdhc[i]), IMX6_ESDHC_CAPABILITIES,
-                                 "capareg", &err);
-        object_property_set_bool(OBJECT(&s->esdhc[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+                                 "capareg", errp);
+        object_property_set_bool(OBJECT(&s->esdhc[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_mmio_map(SYS_BUS_DEVICE(&s->esdhc[i]), 0, esdhc_table[i].addr);
@@ -357,9 +346,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
         };
 
         /* Initialize the SPI */
-        object_property_set_bool(OBJECT(&s->spi[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->spi[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
@@ -370,9 +358,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
     }
 
     qdev_set_nic_properties(DEVICE(&s->eth), &nd_table[0]);
-    object_property_set_bool(OBJECT(&s->eth), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->eth), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->eth), 0, FSL_IMX6_ENET_ADDR);
@@ -385,9 +372,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
 
     /* ROM memory */
     memory_region_init_rom(&s->rom, NULL, "imx6.rom",
-                           FSL_IMX6_ROM_SIZE, &err);
-    if (err) {
-        error_propagate(errp, err);
+                           FSL_IMX6_ROM_SIZE, errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(get_system_memory(), FSL_IMX6_ROM_ADDR,
@@ -395,9 +381,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
 
     /* CAAM memory */
     memory_region_init_rom(&s->caam, NULL, "imx6.caam",
-                           FSL_IMX6_CAAM_MEM_SIZE, &err);
-    if (err) {
-        error_propagate(errp, err);
+                           FSL_IMX6_CAAM_MEM_SIZE, errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(get_system_memory(), FSL_IMX6_CAAM_MEM_ADDR,
@@ -405,9 +390,8 @@ static void fsl_imx6_realize(DeviceState *dev, Error **errp)
 
     /* OCRAM memory */
     memory_region_init_ram(&s->ocram, NULL, "imx6.ocram", FSL_IMX6_OCRAM_SIZE,
-                           &err);
-    if (err) {
-        error_propagate(errp, err);
+                           errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(get_system_memory(), FSL_IMX6_OCRAM_ADDR,
diff --git a/hw/arm/integratorcp.c b/hw/arm/integratorcp.c
index 524970840d..dcdb2fd156 100644
--- a/hw/arm/integratorcp.c
+++ b/hw/arm/integratorcp.c
@@ -286,12 +286,10 @@ static void integratorcm_realize(DeviceState *d, Error **errp)
 {
     IntegratorCMState *s = INTEGRATOR_CM(d);
     SysBusDevice *dev = SYS_BUS_DEVICE(d);
-    Error *local_err = NULL;
 
     memory_region_init_ram(&s->flash, OBJECT(d), "integrator.flash", 0x100000,
-                           &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                           errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/arm/msf2-soc.c b/hw/arm/msf2-soc.c
index 008fd9327a..8f23674d81 100644
--- a/hw/arm/msf2-soc.c
+++ b/hw/arm/msf2-soc.c
@@ -88,7 +88,6 @@ static void m2sxxx_soc_realize(DeviceState *dev_soc, Error **errp)
     MSF2State *s = MSF2_SOC(dev_soc);
     DeviceState *dev, *armv7m;
     SysBusDevice *busdev;
-    Error *err = NULL;
     int i;
 
     MemoryRegion *system_memory = get_system_memory();
@@ -120,9 +119,8 @@ static void m2sxxx_soc_realize(DeviceState *dev_soc, Error **errp)
     qdev_prop_set_bit(armv7m, "enable-bitband", true);
     object_property_set_link(OBJECT(&s->armv7m), OBJECT(get_system_memory()),
                                      "memory", &error_abort);
-    object_property_set_bool(OBJECT(&s->armv7m), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->armv7m), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
@@ -148,9 +146,8 @@ static void m2sxxx_soc_realize(DeviceState *dev_soc, Error **errp)
     dev = DEVICE(&s->timer);
     /* APB0 clock is the timer input clock */
     qdev_prop_set_uint32(dev, "clock-frequency", s->m3clk / s->apb0div);
-    object_property_set_bool(OBJECT(&s->timer), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->timer), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     busdev = SYS_BUS_DEVICE(dev);
@@ -163,9 +160,8 @@ static void m2sxxx_soc_realize(DeviceState *dev_soc, Error **errp)
     dev = DEVICE(&s->sysreg);
     qdev_prop_set_uint32(dev, "apb0divisor", s->apb0div);
     qdev_prop_set_uint32(dev, "apb1divisor", s->apb1div);
-    object_property_set_bool(OBJECT(&s->sysreg), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->sysreg), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     busdev = SYS_BUS_DEVICE(dev);
@@ -174,9 +170,8 @@ static void m2sxxx_soc_realize(DeviceState *dev_soc, Error **errp)
     for (i = 0; i < MSF2_NUM_SPIS; i++) {
         gchar *bus_name;
 
-        object_property_set_bool(OBJECT(&s->spi[i]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->spi[i]), true, "realized", errp);
+        if (*errp != NULL) {
             return;
         }
 
diff --git a/hw/arm/nrf51_soc.c b/hw/arm/nrf51_soc.c
index 74029169d0..8c0a87d6fd 100644
--- a/hw/arm/nrf51_soc.c
+++ b/hw/arm/nrf51_soc.c
@@ -56,7 +56,6 @@ static void nrf51_soc_realize(DeviceState *dev_soc, Error **errp)
 {
     NRF51State *s = NRF51_SOC(dev_soc);
     MemoryRegion *mr;
-    Error *err = NULL;
     uint8_t i = 0;
     hwaddr base_addr = 0;
 
@@ -66,31 +65,27 @@ static void nrf51_soc_realize(DeviceState *dev_soc, Error **errp)
     }
 
     object_property_set_link(OBJECT(&s->cpu), OBJECT(&s->container), "memory",
-            &err);
-    if (err) {
-        error_propagate(errp, err);
+            errp);
+    if (*errp) {
         return;
     }
-    object_property_set_bool(OBJECT(&s->cpu), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->cpu), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
     memory_region_add_subregion_overlap(&s->container, 0, s->board_memory, -1);
 
     memory_region_init_ram(&s->sram, OBJECT(s), "nrf51.sram", s->sram_size,
-                           &err);
-    if (err) {
-        error_propagate(errp, err);
+                           errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(&s->container, NRF51_SRAM_BASE, &s->sram);
 
     /* UART */
-    object_property_set_bool(OBJECT(&s->uart), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->uart), true, "realized", errp);
+    if (*errp) {
         return;
     }
     mr = sysbus_mmio_get_region(SYS_BUS_DEVICE(&s->uart), 0);
@@ -100,9 +95,8 @@ static void nrf51_soc_realize(DeviceState *dev_soc, Error **errp)
                        BASE_TO_IRQ(NRF51_UART_BASE)));
 
     /* RNG */
-    object_property_set_bool(OBJECT(&s->rng), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->rng), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -114,15 +108,13 @@ static void nrf51_soc_realize(DeviceState *dev_soc, Error **errp)
 
     /* UICR, FICR, NVMC, FLASH */
     object_property_set_uint(OBJECT(&s->nvm), s->flash_size, "flash-size",
-                             &err);
-    if (err) {
-        error_propagate(errp, err);
+                             errp);
+    if (*errp) {
         return;
     }
 
-    object_property_set_bool(OBJECT(&s->nvm), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->nvm), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -136,9 +128,8 @@ static void nrf51_soc_realize(DeviceState *dev_soc, Error **errp)
     memory_region_add_subregion_overlap(&s->container, NRF51_FLASH_BASE, mr, 0);
 
     /* GPIO */
-    object_property_set_bool(OBJECT(&s->gpio), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gpio), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -150,9 +141,8 @@ static void nrf51_soc_realize(DeviceState *dev_soc, Error **errp)
 
     /* TIMER */
     for (i = 0; i < NRF51_NUM_TIMERS; i++) {
-        object_property_set_bool(OBJECT(&s->timer[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->timer[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
diff --git a/hw/arm/smmu-common.c b/hw/arm/smmu-common.c
index 245817d23e..868f18c5e5 100644
--- a/hw/arm/smmu-common.c
+++ b/hw/arm/smmu-common.c
@@ -423,11 +423,9 @@ static void smmu_base_realize(DeviceState *dev, Error **errp)
 {
     SMMUState *s = ARM_SMMU(dev);
     SMMUBaseClass *sbc = ARM_SMMU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    sbc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    sbc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
     s->configs = g_hash_table_new_full(NULL, NULL, NULL, g_free);
diff --git a/hw/arm/smmuv3.c b/hw/arm/smmuv3.c
index db051dcac8..2831f024bd 100644
--- a/hw/arm/smmuv3.c
+++ b/hw/arm/smmuv3.c
@@ -1389,11 +1389,9 @@ static void smmu_realize(DeviceState *d, Error **errp)
     SMMUv3State *s = ARM_SMMUV3(sys);
     SMMUv3Class *c = ARM_SMMUV3_GET_CLASS(s);
     SysBusDevice *dev = SYS_BUS_DEVICE(d);
-    Error *local_err = NULL;
 
-    c->parent_realize(d, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    c->parent_realize(d, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/arm/stm32f205_soc.c b/hw/arm/stm32f205_soc.c
index f5a5c2d80c..52042d6d80 100644
--- a/hw/arm/stm32f205_soc.c
+++ b/hw/arm/stm32f205_soc.c
@@ -85,7 +85,6 @@ static void stm32f205_soc_realize(DeviceState *dev_soc, Error **errp)
     STM32F205State *s = STM32F205_SOC(dev_soc);
     DeviceState *dev, *armv7m;
     SysBusDevice *busdev;
-    Error *err = NULL;
     int i;
 
     MemoryRegion *system_memory = get_system_memory();
@@ -114,17 +113,15 @@ static void stm32f205_soc_realize(DeviceState *dev_soc, Error **errp)
     qdev_prop_set_bit(armv7m, "enable-bitband", true);
     object_property_set_link(OBJECT(&s->armv7m), OBJECT(get_system_memory()),
                                      "memory", &error_abort);
-    object_property_set_bool(OBJECT(&s->armv7m), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->armv7m), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
     /* System configuration controller */
     dev = DEVICE(&s->syscfg);
-    object_property_set_bool(OBJECT(&s->syscfg), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->syscfg), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     busdev = SYS_BUS_DEVICE(dev);
@@ -135,9 +132,8 @@ static void stm32f205_soc_realize(DeviceState *dev_soc, Error **errp)
     for (i = 0; i < STM_NUM_USARTS; i++) {
         dev = DEVICE(&(s->usart[i]));
         qdev_prop_set_chr(dev, "chardev", serial_hd(i));
-        object_property_set_bool(OBJECT(&s->usart[i]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->usart[i]), true, "realized", errp);
+        if (*errp != NULL) {
             return;
         }
         busdev = SYS_BUS_DEVICE(dev);
@@ -149,9 +145,8 @@ static void stm32f205_soc_realize(DeviceState *dev_soc, Error **errp)
     for (i = 0; i < STM_NUM_TIMERS; i++) {
         dev = DEVICE(&(s->timer[i]));
         qdev_prop_set_uint64(dev, "clock-frequency", 1000000000);
-        object_property_set_bool(OBJECT(&s->timer[i]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->timer[i]), true, "realized", errp);
+        if (*errp != NULL) {
             return;
         }
         busdev = SYS_BUS_DEVICE(dev);
@@ -161,10 +156,9 @@ static void stm32f205_soc_realize(DeviceState *dev_soc, Error **errp)
 
     /* ADC 1 to 3 */
     object_property_set_int(OBJECT(s->adc_irqs), STM_NUM_ADCS,
-                            "num-lines", &err);
-    object_property_set_bool(OBJECT(s->adc_irqs), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+                            "num-lines", errp);
+    object_property_set_bool(OBJECT(s->adc_irqs), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     qdev_connect_gpio_out(DEVICE(s->adc_irqs), 0,
@@ -172,9 +166,8 @@ static void stm32f205_soc_realize(DeviceState *dev_soc, Error **errp)
 
     for (i = 0; i < STM_NUM_ADCS; i++) {
         dev = DEVICE(&(s->adc[i]));
-        object_property_set_bool(OBJECT(&s->adc[i]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->adc[i]), true, "realized", errp);
+        if (*errp != NULL) {
             return;
         }
         busdev = SYS_BUS_DEVICE(dev);
@@ -186,9 +179,8 @@ static void stm32f205_soc_realize(DeviceState *dev_soc, Error **errp)
     /* SPI 1 and 2 */
     for (i = 0; i < STM_NUM_SPIS; i++) {
         dev = DEVICE(&(s->spi[i]));
-        object_property_set_bool(OBJECT(&s->spi[i]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->spi[i]), true, "realized", errp);
+        if (*errp != NULL) {
             return;
         }
         busdev = SYS_BUS_DEVICE(dev);
diff --git a/hw/arm/tosa.c b/hw/arm/tosa.c
index 4d95a1f3e2..567c56f726 100644
--- a/hw/arm/tosa.c
+++ b/hw/arm/tosa.c
@@ -138,6 +138,7 @@ static uint32_t tosa_ssp_tansfer(SSISlave *dev, uint32_t value)
 
 static void tosa_ssp_realize(SSISlave *dev, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
     /* Nothing to do.  */
 }
 
diff --git a/hw/arm/xlnx-versal-virt.c b/hw/arm/xlnx-versal-virt.c
index 462493c467..2223d3281c 100644
--- a/hw/arm/xlnx-versal-virt.c
+++ b/hw/arm/xlnx-versal-virt.c
@@ -232,13 +232,11 @@ static void fdt_add_gem_nodes(VersalVirt *s)
 
 static void fdt_nop_memory_nodes(void *fdt, Error **errp)
 {
-    Error *err = NULL;
     char **node_path;
     int n = 0;
 
-    node_path = qemu_fdt_node_unit_path(fdt, "memory", &err);
-    if (err) {
-        error_propagate(errp, err);
+    node_path = qemu_fdt_node_unit_path(fdt, "memory", errp);
+    if (*errp) {
         return;
     }
     while (node_path[n]) {
diff --git a/hw/arm/xlnx-zynqmp.c b/hw/arm/xlnx-zynqmp.c
index fb03c60ebb..55d191ea2b 100644
--- a/hw/arm/xlnx-zynqmp.c
+++ b/hw/arm/xlnx-zynqmp.c
@@ -176,7 +176,6 @@ static inline int arm_gic_ppi_index(int cpu_nr, int ppi_index)
 static void xlnx_zynqmp_create_rpu(MachineState *ms, XlnxZynqMPState *s,
                                    const char *boot_cpu, Error **errp)
 {
-    Error *err = NULL;
     int i;
     int num_rpus = MIN(ms->smp.cpus - XLNX_ZYNQMP_NUM_APU_CPUS,
                        XLNX_ZYNQMP_NUM_RPU_CPUS);
@@ -212,9 +211,8 @@ static void xlnx_zynqmp_create_rpu(MachineState *ms, XlnxZynqMPState *s,
         object_property_set_bool(OBJECT(&s->rpu_cpu[i]), true, "reset-hivecs",
                                  &error_abort);
         object_property_set_bool(OBJECT(&s->rpu_cpu[i]), true, "realized",
-                                 &err);
-        if (err) {
-            error_propagate(errp, err);
+                                 errp);
+        if (*errp) {
             return;
         }
     }
@@ -303,7 +301,6 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
     const char *boot_cpu = s->boot_cpu ? s->boot_cpu : "apu-cpu[0]";
     ram_addr_t ddr_low_size, ddr_high_size;
     qemu_irq gic_spi[GIC_NUM_SPI_INTR];
-    Error *err = NULL;
 
     ram_size = memory_region_size(s->ddr_ram);
 
@@ -384,16 +381,14 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
         object_property_set_int(OBJECT(&s->apu_cpu[i]), num_apus,
                                 "core-count", &error_abort);
         object_property_set_bool(OBJECT(&s->apu_cpu[i]), true, "realized",
-                                 &err);
-        if (err) {
-            error_propagate(errp, err);
+                                 errp);
+        if (*errp) {
             return;
         }
     }
 
-    object_property_set_bool(OBJECT(&s->gic), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gic), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -461,9 +456,8 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
                     "RPUs just use -smp 6.");
     }
 
-    xlnx_zynqmp_create_rpu(ms, s, boot_cpu, &err);
-    if (err) {
-        error_propagate(errp, err);
+    xlnx_zynqmp_create_rpu(ms, s, boot_cpu, errp);
+    if (*errp) {
         return;
     }
 
@@ -487,9 +481,8 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
                                 &error_abort);
         object_property_set_int(OBJECT(&s->gem[i]), 2, "num-priority-queues",
                                 &error_abort);
-        object_property_set_bool(OBJECT(&s->gem[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->gem[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_mmio_map(SYS_BUS_DEVICE(&s->gem[i]), 0, gem_addr[i]);
@@ -499,9 +492,8 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
 
     for (i = 0; i < XLNX_ZYNQMP_NUM_UARTS; i++) {
         qdev_prop_set_chr(DEVICE(&s->uart[i]), "chardev", serial_hd(i));
-        object_property_set_bool(OBJECT(&s->uart[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->uart[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_mmio_map(SYS_BUS_DEVICE(&s->uart[i]), 0, uart_addr[i]);
@@ -511,9 +503,8 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
 
     object_property_set_int(OBJECT(&s->sata), SATA_NUM_PORTS, "num-ports",
                             &error_abort);
-    object_property_set_bool(OBJECT(&s->sata), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->sata), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -530,12 +521,11 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
          * - SDIO Specification Version 3.0
          * - eMMC Specification Version 4.51
          */
-        object_property_set_uint(sdhci, 3, "sd-spec-version", &err);
-        object_property_set_uint(sdhci, SDHCI_CAPABILITIES, "capareg", &err);
-        object_property_set_uint(sdhci, UHS_I, "uhs", &err);
-        object_property_set_bool(sdhci, true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_uint(sdhci, 3, "sd-spec-version", errp);
+        object_property_set_uint(sdhci, SDHCI_CAPABILITIES, "capareg", errp);
+        object_property_set_uint(sdhci, UHS_I, "uhs", errp);
+        object_property_set_bool(sdhci, true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_mmio_map(sbd, 0, sdhci_addr[i]);
@@ -550,7 +540,7 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
     for (i = 0; i < XLNX_ZYNQMP_NUM_SPIS; i++) {
         gchar *bus_name;
 
-        object_property_set_bool(OBJECT(&s->spi[i]), true, "realized", &err);
+        object_property_set_bool(OBJECT(&s->spi[i]), true, "realized", errp);
 
         sysbus_mmio_map(SYS_BUS_DEVICE(&s->spi[i]), 0, spi_addr[i]);
         sysbus_connect_irq(SYS_BUS_DEVICE(&s->spi[i]), 0,
@@ -564,7 +554,7 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
         g_free(bus_name);
     }
 
-    object_property_set_bool(OBJECT(&s->qspi), true, "realized", &err);
+    object_property_set_bool(OBJECT(&s->qspi), true, "realized", errp);
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->qspi), 0, QSPI_ADDR);
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->qspi), 1, LQSPI_ADDR);
     sysbus_connect_irq(SYS_BUS_DEVICE(&s->qspi), 0, gic_spi[QSPI_IRQ]);
@@ -583,17 +573,15 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
         g_free(target_bus);
     }
 
-    object_property_set_bool(OBJECT(&s->dp), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->dp), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->dp), 0, DP_ADDR);
     sysbus_connect_irq(SYS_BUS_DEVICE(&s->dp), 0, gic_spi[DP_IRQ]);
 
-    object_property_set_bool(OBJECT(&s->dpdma), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->dpdma), true, "realized", errp);
+    if (*errp) {
         return;
     }
     object_property_set_link(OBJECT(&s->dp), OBJECT(&s->dpdma), "dpdma",
@@ -601,27 +589,24 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->dpdma), 0, DPDMA_ADDR);
     sysbus_connect_irq(SYS_BUS_DEVICE(&s->dpdma), 0, gic_spi[DPDMA_IRQ]);
 
-    object_property_set_bool(OBJECT(&s->ipi), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->ipi), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->ipi), 0, IPI_ADDR);
     sysbus_connect_irq(SYS_BUS_DEVICE(&s->ipi), 0, gic_spi[IPI_IRQ]);
 
-    object_property_set_bool(OBJECT(&s->rtc), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->rtc), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->rtc), 0, RTC_ADDR);
     sysbus_connect_irq(SYS_BUS_DEVICE(&s->rtc), 0, gic_spi[RTC_IRQ]);
 
     for (i = 0; i < XLNX_ZYNQMP_NUM_GDMA_CH; i++) {
-        object_property_set_uint(OBJECT(&s->gdma[i]), 128, "bus-width", &err);
-        object_property_set_bool(OBJECT(&s->gdma[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_uint(OBJECT(&s->gdma[i]), 128, "bus-width", errp);
+        object_property_set_bool(OBJECT(&s->gdma[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
@@ -631,9 +616,8 @@ static void xlnx_zynqmp_realize(DeviceState *dev, Error **errp)
     }
 
     for (i = 0; i < XLNX_ZYNQMP_NUM_ADMA_CH; i++) {
-        object_property_set_bool(OBJECT(&s->adma[i]), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->adma[i]), true, "realized", errp);
+        if (*errp) {
             return;
         }
 
diff --git a/hw/audio/intel-hda.c b/hw/audio/intel-hda.c
index 6ecd383540..13c2be81ac 100644
--- a/hw/audio/intel-hda.c
+++ b/hw/audio/intel-hda.c
@@ -1097,7 +1097,6 @@ static void intel_hda_realize(PCIDevice *pci, Error **errp)
 {
     IntelHDAState *d = INTEL_HDA(pci);
     uint8_t *conf = d->pci.config;
-    Error *err = NULL;
     int ret;
 
     d->name = object_get_typename(OBJECT(d));
@@ -1109,20 +1108,19 @@ static void intel_hda_realize(PCIDevice *pci, Error **errp)
 
     if (d->msi != ON_OFF_AUTO_OFF) {
         ret = msi_init(&d->pci, d->old_msi_addr ? 0x50 : 0x60,
-                       1, true, false, &err);
+                       1, true, false, errp);
         /* Any error other than -ENOTSUP(board's MSI support is broken)
          * is a programming error */
         assert(!ret || ret == -ENOTSUP);
         if (ret && d->msi == ON_OFF_AUTO_ON) {
             /* Can't satisfy user's explicit msi=on request, fail */
-            error_append_hint(&err, "You have to use msi=auto (default) or "
-                    "msi=off with this machine type.\n");
-            error_propagate(errp, err);
+            error_append_hint(errp, "You have to use msi=auto (default) or "
+                              "msi=off with this machine type.\n");
             return;
         }
-        assert(!err || d->msi == ON_OFF_AUTO_AUTO);
+        assert(!*errp || d->msi == ON_OFF_AUTO_AUTO);
         /* With msi=auto, we fall back to MSI off silently */
-        error_free(err);
+        error_free_errp(errp);
     }
 
     memory_region_init_io(&d->mmio, OBJECT(d), &intel_hda_mmio_ops, d,
diff --git a/hw/block/dataplane/xen-block.c b/hw/block/dataplane/xen-block.c
index 3b9caeb2fa..ae3fcd9308 100644
--- a/hw/block/dataplane/xen-block.c
+++ b/hw/block/dataplane/xen-block.c
@@ -728,7 +728,6 @@ void xen_block_dataplane_start(XenBlockDataPlane *dataplane,
                                Error **errp)
 {
     XenDevice *xendev = dataplane->xendev;
-    Error *local_err = NULL;
     unsigned int ring_size;
     unsigned int i;
 
@@ -764,9 +763,8 @@ void xen_block_dataplane_start(XenBlockDataPlane *dataplane,
     }
 
     xen_device_set_max_grant_refs(xendev, dataplane->nr_ring_ref,
-                                  &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                  errp);
+    if (*errp) {
         goto stop;
     }
 
@@ -774,9 +772,8 @@ void xen_block_dataplane_start(XenBlockDataPlane *dataplane,
                                               dataplane->ring_ref,
                                               dataplane->nr_ring_ref,
                                               PROT_READ | PROT_WRITE,
-                                              &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                              errp);
+    if (*errp) {
         goto stop;
     }
 
@@ -809,9 +806,8 @@ void xen_block_dataplane_start(XenBlockDataPlane *dataplane,
     dataplane->event_channel =
         xen_device_bind_event_channel(xendev, dataplane->ctx, event_channel,
                                       xen_block_dataplane_event, dataplane,
-                                      &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                      errp);
+    if (*errp) {
         goto stop;
     }
 
diff --git a/hw/block/fdc.c b/hw/block/fdc.c
index ac5d31e8c1..1019cae4eb 100644
--- a/hw/block/fdc.c
+++ b/hw/block/fdc.c
@@ -2526,7 +2526,6 @@ static void fdctrl_connect_drives(FDCtrl *fdctrl, DeviceState *fdc_dev,
     FDrive *drive;
     DeviceState *dev;
     BlockBackend *blk;
-    Error *local_err = NULL;
 
     for (i = 0; i < MAX_FD; i++) {
         drive = &fdctrl->drives[i];
@@ -2548,17 +2547,15 @@ static void fdctrl_connect_drives(FDCtrl *fdctrl, DeviceState *fdc_dev,
         blk_ref(blk);
         blk_detach_dev(blk, fdc_dev);
         fdctrl->qdev_for_drives[i].blk = NULL;
-        qdev_prop_set_drive(dev, "drive", blk, &local_err);
+        qdev_prop_set_drive(dev, "drive", blk, errp);
         blk_unref(blk);
 
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             return;
         }
 
-        object_property_set_bool(OBJECT(dev), true, "realized", &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        object_property_set_bool(OBJECT(dev), true, "realized", errp);
+        if (*errp) {
             return;
         }
     }
@@ -2688,7 +2685,6 @@ static void isabus_fdc_realize(DeviceState *dev, Error **errp)
     ISADevice *isadev = ISA_DEVICE(dev);
     FDCtrlISABus *isa = ISA_FDC(dev);
     FDCtrl *fdctrl = &isa->state;
-    Error *err = NULL;
 
     isa_register_portio_list(isadev, &fdctrl->portio_list,
                              isa->iobase, fdc_portio_list, fdctrl,
@@ -2705,9 +2701,8 @@ static void isabus_fdc_realize(DeviceState *dev, Error **errp)
     }
 
     qdev_set_legacy_instance_id(dev, isa->iobase, 2);
-    fdctrl_realize_common(dev, fdctrl, &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    fdctrl_realize_common(dev, fdctrl, errp);
+    if (*errp != NULL) {
         return;
     }
 }
diff --git a/hw/block/onenand.c b/hw/block/onenand.c
index fcc5a69b90..48af07bb11 100644
--- a/hw/block/onenand.c
+++ b/hw/block/onenand.c
@@ -780,7 +780,6 @@ static void onenand_realize(DeviceState *dev, Error **errp)
     OneNANDState *s = ONE_NAND(dev);
     uint32_t size = 1 << (24 + ((s->id.dev >> 4) & 7));
     void *ram;
-    Error *local_err = NULL;
 
     s->base = (hwaddr)-1;
     s->rdy = NULL;
@@ -800,9 +799,8 @@ static void onenand_realize(DeviceState *dev, Error **errp)
             return;
         }
         blk_set_perm(s->blk, BLK_PERM_CONSISTENT_READ | BLK_PERM_WRITE,
-                     BLK_PERM_ALL, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                     BLK_PERM_ALL, errp);
+        if (*errp) {
             return;
         }
         s->blk_cur = s->blk;
diff --git a/hw/block/pflash_cfi01.c b/hw/block/pflash_cfi01.c
index 566c0acb77..4ba559677e 100644
--- a/hw/block/pflash_cfi01.c
+++ b/hw/block/pflash_cfi01.c
@@ -705,7 +705,6 @@ static void pflash_cfi01_realize(DeviceState *dev, Error **errp)
     int ret;
     uint64_t blocks_per_device, sector_len_per_device, device_len;
     int num_devices;
-    Error *local_err = NULL;
 
     if (pfl->sector_len == 0) {
         error_setg(errp, "attribute \"sector-length\" not specified or zero.");
@@ -739,9 +738,8 @@ static void pflash_cfi01_realize(DeviceState *dev, Error **errp)
         &pfl->mem, OBJECT(dev),
         &pflash_cfi01_ops,
         pfl,
-        pfl->name, total_len, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+        pfl->name, total_len, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/block/pflash_cfi02.c b/hw/block/pflash_cfi02.c
index 4baca701b7..d5110c12d0 100644
--- a/hw/block/pflash_cfi02.c
+++ b/hw/block/pflash_cfi02.c
@@ -721,7 +721,6 @@ static void pflash_cfi02_realize(DeviceState *dev, Error **errp)
 {
     PFlashCFI02 *pfl = PFLASH_CFI02(dev);
     int ret;
-    Error *local_err = NULL;
 
     if (pfl->uniform_sector_len == 0 && pfl->sector_len[0] == 0) {
         error_setg(errp, "attribute \"sector-length\" not specified or zero.");
@@ -787,9 +786,8 @@ static void pflash_cfi02_realize(DeviceState *dev, Error **errp)
 
     memory_region_init_rom_device(&pfl->orig_mem, OBJECT(pfl),
                                   &pflash_cfi02_ops, pfl, pfl->name,
-                                  pfl->chip_len, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                  pfl->chip_len, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/block/vhost-user-blk.c b/hw/block/vhost-user-blk.c
index 63da9bb619..5906fac6aa 100644
--- a/hw/block/vhost-user-blk.c
+++ b/hw/block/vhost-user-blk.c
@@ -390,7 +390,6 @@ static void vhost_user_blk_device_realize(DeviceState *dev, Error **errp)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
     VHostUserBlk *s = VHOST_USER_BLK(vdev);
-    Error *err = NULL;
     int i, ret;
 
     if (!s->chardev.chr) {
@@ -429,8 +428,8 @@ static void vhost_user_blk_device_realize(DeviceState *dev, Error **errp)
                              NULL, (void *)dev, NULL, true);
 
 reconnect:
-    if (qemu_chr_fe_wait_connected(&s->chardev, &err) < 0) {
-        error_report_err(err);
+    if (qemu_chr_fe_wait_connected(&s->chardev, errp) < 0) {
+        error_report_errp(errp);
         goto virtio_err;
     }
 
diff --git a/hw/block/virtio-blk.c b/hw/block/virtio-blk.c
index 18851601cb..3a76f231c9 100644
--- a/hw/block/virtio-blk.c
+++ b/hw/block/virtio-blk.c
@@ -1102,7 +1102,6 @@ static void virtio_blk_device_realize(DeviceState *dev, Error **errp)
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
     VirtIOBlock *s = VIRTIO_BLK(dev);
     VirtIOBlkConf *conf = &s->conf;
-    Error *err = NULL;
     unsigned i;
 
     if (!conf->conf.blk) {
@@ -1174,9 +1173,8 @@ static void virtio_blk_device_realize(DeviceState *dev, Error **errp)
     for (i = 0; i < conf->num_queues; i++) {
         virtio_add_queue(vdev, conf->queue_size, virtio_blk_handle_output);
     }
-    virtio_blk_data_plane_create(vdev, conf, &s->dataplane, &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    virtio_blk_data_plane_create(vdev, conf, &s->dataplane, errp);
+    if (*errp != NULL) {
         virtio_cleanup(vdev);
         return;
     }
diff --git a/hw/block/xen-block.c b/hw/block/xen-block.c
index f77343db60..7cdefd0656 100644
--- a/hw/block/xen-block.c
+++ b/hw/block/xen-block.c
@@ -201,7 +201,6 @@ static void xen_block_realize(XenDevice *xendev, Error **errp)
     XenBlockVdev *vdev = &blockdev->props.vdev;
     BlockConf *conf = &blockdev->props.conf;
     BlockBackend *blk = conf->blk;
-    Error *local_err = NULL;
 
     if (vdev->type == XEN_BLOCK_VDEV_TYPE_INVALID) {
         error_setg(errp, "vdev property not set");
@@ -211,9 +210,8 @@ static void xen_block_realize(XenDevice *xendev, Error **errp)
     trace_xen_block_realize(type, vdev->disk, vdev->partition);
 
     if (blockdev_class->realize) {
-        blockdev_class->realize(blockdev, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        blockdev_class->realize(blockdev, errp);
+        if (*errp) {
             return;
         }
     }
@@ -284,7 +282,6 @@ static void xen_block_frontend_changed(XenDevice *xendev,
                                        Error **errp)
 {
     enum xenbus_state backend_state = xen_device_backend_get_state(xendev);
-    Error *local_err = NULL;
 
     switch (frontend_state) {
     case XenbusStateInitialised:
@@ -293,15 +290,13 @@ static void xen_block_frontend_changed(XenDevice *xendev,
             break;
         }
 
-        xen_block_disconnect(xendev, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        xen_block_disconnect(xendev, errp);
+        if (*errp) {
             break;
         }
 
-        xen_block_connect(xendev, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        xen_block_connect(xendev, errp);
+        if (*errp) {
             break;
         }
 
@@ -313,9 +308,8 @@ static void xen_block_frontend_changed(XenDevice *xendev,
         break;
 
     case XenbusStateClosed:
-        xen_block_disconnect(xendev, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        xen_block_disconnect(xendev, errp);
+        if (*errp) {
             break;
         }
 
@@ -405,7 +399,6 @@ static void xen_block_set_vdev(Object *obj, Visitor *v, const char *name,
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
     XenBlockVdev *vdev = qdev_get_prop_ptr(dev, prop);
-    Error *local_err = NULL;
     char *str, *p;
     const char *end;
 
@@ -414,9 +407,8 @@ static void xen_block_set_vdev(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
 
@@ -672,7 +664,6 @@ static char *xen_block_blockdev_add(const char *id, QDict *qdict,
 {
     const char *driver = qdict_get_try_str(qdict, "driver");
     BlockdevOptions *options = NULL;
-    Error *local_err = NULL;
     char *node_name;
     Visitor *v;
 
@@ -687,18 +678,16 @@ static char *xen_block_blockdev_add(const char *id, QDict *qdict,
     trace_xen_block_blockdev_add(node_name);
 
     v = qobject_input_visitor_new(QOBJECT(qdict));
-    visit_type_BlockdevOptions(v, NULL, &options, &local_err);
+    visit_type_BlockdevOptions(v, NULL, &options, errp);
     visit_free(v);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         goto fail;
     }
 
-    qmp_blockdev_add(options, &local_err);
+    qmp_blockdev_add(options, errp);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         goto fail;
     }
 
@@ -720,11 +709,8 @@ static void xen_block_drive_destroy(XenBlockDrive *drive, Error **errp)
     char *node_name = drive->node_name;
 
     if (node_name) {
-        Error *local_err = NULL;
-
-        xen_block_blockdev_del(node_name, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        xen_block_blockdev_del(node_name, errp);
+        if (*errp) {
             return;
         }
         g_free(node_name);
@@ -745,7 +731,6 @@ static XenBlockDrive *xen_block_drive_create(const char *id,
     char *driver = NULL;
     char *filename = NULL;
     XenBlockDrive *drive = NULL;
-    Error *local_err = NULL;
     QDict *file_layer;
     QDict *driver_layer;
 
@@ -824,13 +809,12 @@ static XenBlockDrive *xen_block_drive_create(const char *id,
 
     g_assert(!drive->node_name);
     drive->node_name = xen_block_blockdev_add(drive->id, driver_layer,
-                                              &local_err);
+                                              errp);
 
     qobject_unref(driver_layer);
 
 done:
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         xen_block_drive_destroy(drive, NULL);
         return NULL;
     }
@@ -856,14 +840,11 @@ static XenBlockIOThread *xen_block_iothread_create(const char *id,
                                                    Error **errp)
 {
     XenBlockIOThread *iothread = g_new(XenBlockIOThread, 1);
-    Error *local_err = NULL;
 
     iothread->id = g_strdup(id);
 
-    qmp_object_add(TYPE_IOTHREAD, id, false, NULL, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
-
+    qmp_object_add(TYPE_IOTHREAD, id, false, NULL, errp);
+    if (*errp) {
         g_free(iothread->id);
         g_free(iothread);
         return NULL;
@@ -882,7 +863,6 @@ static void xen_block_device_create(XenBackendInstance *backend,
     XenBlockDrive *drive = NULL;
     XenBlockIOThread *iothread = NULL;
     XenDevice *xendev = NULL;
-    Error *local_err = NULL;
     const char *type;
     XenBlockDevice *blockdev;
 
@@ -914,15 +894,15 @@ static void xen_block_device_create(XenBackendInstance *backend,
         goto fail;
     }
 
-    drive = xen_block_drive_create(vdev, device_type, opts, &local_err);
+    drive = xen_block_drive_create(vdev, device_type, opts, errp);
     if (!drive) {
-        error_propagate_prepend(errp, local_err, "failed to create drive: ");
+        error_propagate_prepend(errp, *errp, "failed to create drive: ");
         goto fail;
     }
 
-    iothread = xen_block_iothread_create(vdev, &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+    iothread = xen_block_iothread_create(vdev, errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "failed to create iothread: ");
         goto fail;
     }
@@ -930,24 +910,24 @@ static void xen_block_device_create(XenBackendInstance *backend,
     xendev = XEN_DEVICE(qdev_create(BUS(xenbus), type));
     blockdev = XEN_BLOCK_DEVICE(xendev);
 
-    object_property_set_str(OBJECT(xendev), vdev, "vdev", &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err, "failed to set 'vdev': ");
+    object_property_set_str(OBJECT(xendev), vdev, "vdev", errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp, "failed to set 'vdev': ");
         goto fail;
     }
 
     object_property_set_str(OBJECT(xendev),
                             xen_block_drive_get_node_name(drive), "drive",
-                            &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err, "failed to set 'drive': ");
+                            errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp, "failed to set 'drive': ");
         goto fail;
     }
 
     object_property_set_str(OBJECT(xendev), iothread->id, "iothread",
-                            &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+                            errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "failed to set 'iothread': ");
         goto fail;
     }
@@ -955,9 +935,9 @@ static void xen_block_device_create(XenBackendInstance *backend,
     blockdev->iothread = iothread;
     blockdev->drive = drive;
 
-    object_property_set_bool(OBJECT(xendev), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+    object_property_set_bool(OBJECT(xendev), true, "realized", errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "realization of device %s failed: ",
                                 type);
         goto fail;
@@ -994,23 +974,19 @@ static void xen_block_device_destroy(XenBackendInstance *backend,
     object_unparent(OBJECT(xendev));
 
     if (iothread) {
-        Error *local_err = NULL;
-
-        xen_block_iothread_destroy(iothread, &local_err);
-        if (local_err) {
-            error_propagate_prepend(errp, local_err,
-                                "failed to destroy iothread: ");
+        xen_block_iothread_destroy(iothread, errp);
+        if (*errp) {
+            error_propagate_prepend(errp, *errp,
+                                    "failed to destroy iothread: ");
             return;
         }
     }
 
     if (drive) {
-        Error *local_err = NULL;
-
-        xen_block_drive_destroy(drive, &local_err);
-        if (local_err) {
-            error_propagate_prepend(errp, local_err,
-                                "failed to destroy drive: ");
+        xen_block_drive_destroy(drive, errp);
+        if (*errp) {
+            error_propagate_prepend(errp, *errp,
+                                    "failed to destroy drive: ");
         }
     }
 }
diff --git a/hw/char/debugcon.c b/hw/char/debugcon.c
index 5c592e091b..92ef636b1b 100644
--- a/hw/char/debugcon.c
+++ b/hw/char/debugcon.c
@@ -100,11 +100,9 @@ static void debugcon_isa_realizefn(DeviceState *dev, Error **errp)
     ISADevice *d = ISA_DEVICE(dev);
     ISADebugconState *isa = ISA_DEBUGCON_DEVICE(dev);
     DebugconState *s = &isa->state;
-    Error *err = NULL;
 
-    debugcon_realize_core(s, &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    debugcon_realize_core(s, errp);
+    if (*errp != NULL) {
         return;
     }
     memory_region_init_io(&s->io, OBJECT(dev), &debugcon_ops, s,
diff --git a/hw/char/serial-pci-multi.c b/hw/char/serial-pci-multi.c
index 5f13b5663b..fc4b1fed70 100644
--- a/hw/char/serial-pci-multi.c
+++ b/hw/char/serial-pci-multi.c
@@ -82,7 +82,6 @@ static void multi_serial_pci_realize(PCIDevice *dev, Error **errp)
     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);
     PCIMultiSerialState *pci = DO_UPCAST(PCIMultiSerialState, dev, dev);
     SerialState *s;
-    Error *err = NULL;
     int i, nr_ports = 0;
 
     switch (pc->device_id) {
@@ -106,9 +105,8 @@ static void multi_serial_pci_realize(PCIDevice *dev, Error **errp)
     for (i = 0; i < nr_ports; i++) {
         s = pci->state + i;
         s->baudbase = 115200;
-        serial_realize_core(s, &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        serial_realize_core(s, errp);
+        if (*errp != NULL) {
             multi_serial_pci_exit(dev);
             return;
         }
diff --git a/hw/char/serial-pci.c b/hw/char/serial-pci.c
index cb9b76e22b..bb804bd7b2 100644
--- a/hw/char/serial-pci.c
+++ b/hw/char/serial-pci.c
@@ -45,12 +45,10 @@ static void serial_pci_realize(PCIDevice *dev, Error **errp)
 {
     PCISerialState *pci = DO_UPCAST(PCISerialState, dev, dev);
     SerialState *s = &pci->state;
-    Error *err = NULL;
 
     s->baudbase = 115200;
-    serial_realize_core(s, &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    serial_realize_core(s, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/hw/char/virtio-serial-bus.c b/hw/char/virtio-serial-bus.c
index 4e0ed829ae..466bd4b1bd 100644
--- a/hw/char/virtio-serial-bus.c
+++ b/hw/char/virtio-serial-bus.c
@@ -940,7 +940,6 @@ static void virtser_port_device_realize(DeviceState *dev, Error **errp)
     VirtIOSerialBus *bus = VIRTIO_SERIAL_BUS(qdev_get_parent_bus(dev));
     int max_nr_ports;
     bool plugging_port0;
-    Error *err = NULL;
 
     port->vser = bus->vser;
     port->bh = qemu_bh_new(flush_queued_data_bh, port);
@@ -986,9 +985,8 @@ static void virtser_port_device_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    vsc->realize(dev, &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    vsc->realize(dev, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/hw/core/bus.c b/hw/core/bus.c
index 7f3d2a3dbd..50b3cf4b36 100644
--- a/hw/core/bus.c
+++ b/hw/core/bus.c
@@ -149,11 +149,10 @@ static void bus_set_realized(Object *obj, bool value, Error **errp)
     BusState *bus = BUS(obj);
     BusClass *bc = BUS_GET_CLASS(bus);
     BusChild *kid;
-    Error *local_err = NULL;
 
     if (value && !bus->realized) {
         if (bc->realize) {
-            bc->realize(bus, &local_err);
+            bc->realize(bus, errp);
         }
 
         /* TODO: recursive realization */
@@ -161,18 +160,17 @@ static void bus_set_realized(Object *obj, bool value, Error **errp)
         QTAILQ_FOREACH(kid, &bus->children, sibling) {
             DeviceState *dev = kid->child;
             object_property_set_bool(OBJECT(dev), false, "realized",
-                                     &local_err);
-            if (local_err != NULL) {
+                                     errp);
+            if (*errp != NULL) {
                 break;
             }
         }
-        if (bc->unrealize && local_err == NULL) {
-            bc->unrealize(bus, &local_err);
+        if (bc->unrealize && *errp == NULL) {
+            bc->unrealize(bus, errp);
         }
     }
 
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/hw/core/machine.c b/hw/core/machine.c
index 1689ad3bf8..a998e210af 100644
--- a/hw/core/machine.c
+++ b/hw/core/machine.c
@@ -192,13 +192,11 @@ static void machine_set_kernel_irqchip(Object *obj, Visitor *v,
                                        const char *name, void *opaque,
                                        Error **errp)
 {
-    Error *err = NULL;
     MachineState *ms = MACHINE(obj);
     OnOffSplit mode;
 
-    visit_type_OnOffSplit(v, name, &mode, &err);
-    if (err) {
-        error_propagate(errp, err);
+    visit_type_OnOffSplit(v, name, &mode, errp);
+    if (*errp) {
         return;
     } else {
         switch (mode) {
@@ -241,12 +239,10 @@ static void machine_set_kvm_shadow_mem(Object *obj, Visitor *v,
                                        Error **errp)
 {
     MachineState *ms = MACHINE(obj);
-    Error *error = NULL;
     int64_t value;
 
-    visit_type_int(v, name, &value, &error);
-    if (error) {
-        error_propagate(errp, error);
+    visit_type_int(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
@@ -343,12 +339,10 @@ static void machine_set_phandle_start(Object *obj, Visitor *v,
                                       Error **errp)
 {
     MachineState *ms = MACHINE(obj);
-    Error *error = NULL;
     int64_t value;
 
-    visit_type_int(v, name, &value, &error);
-    if (error) {
-        error_propagate(errp, error);
+    visit_type_int(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/core/numa.c b/hw/core/numa.c
index 4dfec5c95b..df85c0e559 100644
--- a/hw/core/numa.c
+++ b/hw/core/numa.c
@@ -59,7 +59,6 @@ static int max_numa_nodeid; /* Highest specified NUMA node ID, plus one.
 static void parse_numa_node(MachineState *ms, NumaNodeOptions *node,
                             Error **errp)
 {
-    Error *err = NULL;
     uint16_t nodenr;
     uint16List *cpus = NULL;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
@@ -99,9 +98,8 @@ static void parse_numa_node(MachineState *ms, NumaNodeOptions *node,
         props = mc->cpu_index_to_instance_props(ms, cpus->value);
         props.node_id = nodenr;
         props.has_node_id = true;
-        machine_set_cpu_numa_node(ms, &props, &err);
-        if (err) {
-            error_propagate(errp, err);
+        machine_set_cpu_numa_node(ms, &props, errp);
+        if (*errp) {
             return;
         }
     }
@@ -177,60 +175,55 @@ void parse_numa_distance(MachineState *ms, NumaDistOptions *dist, Error **errp)
 
 void set_numa_options(MachineState *ms, NumaOptions *object, Error **errp)
 {
-    Error *err = NULL;
     MachineClass *mc = MACHINE_GET_CLASS(ms);
 
     if (!mc->numa_mem_supported) {
         error_setg(errp, "NUMA is not supported by this machine-type");
-        goto end;
+        return;
     }
 
     switch (object->type) {
     case NUMA_OPTIONS_TYPE_NODE:
-        parse_numa_node(ms, &object->u.node, &err);
-        if (err) {
-            goto end;
+        parse_numa_node(ms, &object->u.node, errp);
+        if (*errp) {
+            return;
         }
         break;
     case NUMA_OPTIONS_TYPE_DIST:
-        parse_numa_distance(ms, &object->u.dist, &err);
-        if (err) {
-            goto end;
+        parse_numa_distance(ms, &object->u.dist, errp);
+        if (*errp) {
+            return;
         }
         break;
     case NUMA_OPTIONS_TYPE_CPU:
         if (!object->u.cpu.has_node_id) {
-            error_setg(&err, "Missing mandatory node-id property");
-            goto end;
+            error_setg(errp, "Missing mandatory node-id property");
+            return;
         }
         if (!ms->numa_state->nodes[object->u.cpu.node_id].present) {
-            error_setg(&err, "Invalid node-id=%" PRId64 ", NUMA node must be "
-                "defined with -numa node,nodeid=ID before it's used with "
-                "-numa cpu,node-id=ID", object->u.cpu.node_id);
-            goto end;
+            error_setg(errp, "Invalid node-id=%" PRId64 ", NUMA node must be "
+                       "defined with -numa node,nodeid=ID before it's used with "
+                       "-numa cpu,node-id=ID", object->u.cpu.node_id);
+            return;
         }
 
         machine_set_cpu_numa_node(ms, qapi_NumaCpuOptions_base(&object->u.cpu),
-                                  &err);
+                                  errp);
         break;
     default:
         abort();
     }
-
-end:
-    error_propagate(errp, err);
 }
 
 static int parse_numa(void *opaque, QemuOpts *opts, Error **errp)
 {
     NumaOptions *object = NULL;
     MachineState *ms = MACHINE(opaque);
-    Error *err = NULL;
     Visitor *v = opts_visitor_new(opts);
 
-    visit_type_NumaOptions(v, NULL, &object, &err);
+    visit_type_NumaOptions(v, NULL, &object, errp);
     visit_free(v);
-    if (err) {
+    if (*errp) {
         goto end;
     }
 
@@ -240,12 +233,11 @@ static int parse_numa(void *opaque, QemuOpts *opts, Error **errp)
         qemu_strtosz_MiB(mem_str, NULL, &object->u.node.mem);
     }
 
-    set_numa_options(ms, object, &err);
+    set_numa_options(ms, object, errp);
 
 end:
     qapi_free_NumaOptions(object);
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         return -1;
     }
 
diff --git a/hw/core/qdev-properties-system.c b/hw/core/qdev-properties-system.c
index 70bfd4809b..b53056a5fa 100644
--- a/hw/core/qdev-properties-system.c
+++ b/hw/core/qdev-properties-system.c
@@ -45,7 +45,6 @@ static void set_pointer(Object *obj, Visitor *v, Property *prop,
                         const char *name, Error **errp)
 {
     DeviceState *dev = DEVICE(obj);
-    Error *local_err = NULL;
     void **ptr = qdev_get_prop_ptr(dev, prop);
     char *str;
 
@@ -54,9 +53,8 @@ static void set_pointer(Object *obj, Visitor *v, Property *prop,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
     if (!*str) {
@@ -222,7 +220,6 @@ static void set_chr(Object *obj, Visitor *v, const char *name, void *opaque,
                     Error **errp)
 {
     DeviceState *dev = DEVICE(obj);
-    Error *local_err = NULL;
     Property *prop = opaque;
     CharBackend *be = qdev_get_prop_ptr(dev, prop);
     Chardev *s;
@@ -233,9 +230,8 @@ static void set_chr(Object *obj, Visitor *v, const char *name, void *opaque,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
 
@@ -294,7 +290,6 @@ static void set_netdev(Object *obj, Visitor *v, const char *name,
     NICPeers *peers_ptr = qdev_get_prop_ptr(dev, prop);
     NetClientState **ncs = peers_ptr->ncs;
     NetClientState *peers[MAX_QUEUE_NUM];
-    Error *local_err = NULL;
     int queues, err = 0, i = 0;
     char *str;
 
@@ -303,9 +298,8 @@ static void set_netdev(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
 
@@ -374,7 +368,6 @@ static void set_audiodev(Object *obj, Visitor *v, const char* name,
     Property *prop = opaque;
     QEMUSoundCard *card = qdev_get_prop_ptr(dev, prop);
     AudioState *state;
-    Error *local_err = NULL;
     int err = 0;
     char *str;
 
@@ -383,9 +376,8 @@ static void set_audiodev(Object *obj, Visitor *v, const char* name,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/core/qdev-properties.c b/hw/core/qdev-properties.c
index ac28890e5a..2fb74ee619 100644
--- a/hw/core/qdev-properties.c
+++ b/hw/core/qdev-properties.c
@@ -116,7 +116,6 @@ static void prop_set_bit(Object *obj, Visitor *v, const char *name,
 {
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
-    Error *local_err = NULL;
     bool value;
 
     if (dev->realized) {
@@ -124,9 +123,8 @@ static void prop_set_bit(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_bool(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_bool(v, name, &value, errp);
+    if (*errp) {
         return;
     }
     bit_prop_set(dev, prop, value);
@@ -180,7 +178,6 @@ static void prop_set_bit64(Object *obj, Visitor *v, const char *name,
 {
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
-    Error *local_err = NULL;
     bool value;
 
     if (dev->realized) {
@@ -188,9 +185,8 @@ static void prop_set_bit64(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_bool(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_bool(v, name, &value, errp);
+    if (*errp) {
         return;
     }
     bit64_prop_set(dev, prop, value);
@@ -477,7 +473,6 @@ static void set_string(Object *obj, Visitor *v, const char *name,
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
     char **ptr = qdev_get_prop_ptr(dev, prop);
-    Error *local_err = NULL;
     char *str;
 
     if (dev->realized) {
@@ -485,9 +480,8 @@ static void set_string(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
     g_free(*ptr);
@@ -537,7 +531,6 @@ static void set_mac(Object *obj, Visitor *v, const char *name, void *opaque,
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
     MACAddr *mac = qdev_get_prop_ptr(dev, prop);
-    Error *local_err = NULL;
     int i, pos;
     char *str, *p;
 
@@ -546,9 +539,8 @@ static void set_mac(Object *obj, Visitor *v, const char *name, void *opaque,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
 
@@ -660,7 +652,6 @@ static void set_pci_devfn(Object *obj, Visitor *v, const char *name,
     Property *prop = opaque;
     int32_t value, *ptr = qdev_get_prop_ptr(dev, prop);
     unsigned int slot, fn, n;
-    Error *local_err = NULL;
     char *str;
 
     if (dev->realized) {
@@ -668,13 +659,11 @@ static void set_pci_devfn(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_free(local_err);
-        local_err = NULL;
-        visit_type_int32(v, name, &value, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
+        error_free_errp(errp);
+        visit_type_int32(v, name, &value, errp);
+        if (*errp) {
         } else if (value < -1 || value > 255) {
             error_setg(errp, QERR_INVALID_PARAMETER_VALUE,
                        name ? name : "null", "pci_devfn");
@@ -731,7 +720,6 @@ static void set_blocksize(Object *obj, Visitor *v, const char *name,
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
     uint16_t value, *ptr = qdev_get_prop_ptr(dev, prop);
-    Error *local_err = NULL;
     const int64_t min = 512;
     const int64_t max = 32768;
 
@@ -740,9 +728,8 @@ static void set_blocksize(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_uint16(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_uint16(v, name, &value, errp);
+    if (*errp) {
         return;
     }
     /* value of 0 means "unset" */
@@ -806,7 +793,6 @@ static void set_pci_host_devaddr(Object *obj, Visitor *v, const char *name,
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
     PCIHostDeviceAddress *addr = qdev_get_prop_ptr(dev, prop);
-    Error *local_err = NULL;
     char *str, *p;
     char *e;
     unsigned long val;
@@ -818,9 +804,8 @@ static void set_pci_host_devaddr(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
 
@@ -910,7 +895,6 @@ static void set_uuid(Object *obj, Visitor *v, const char *name, void *opaque,
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
     QemuUUID *uuid = qdev_get_prop_ptr(dev, prop);
-    Error *local_err = NULL;
     char *str;
 
     if (dev->realized) {
@@ -918,9 +902,8 @@ static void set_uuid(Object *obj, Visitor *v, const char *name, void *opaque,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
 
@@ -986,7 +969,6 @@ static void set_prop_arraylen(Object *obj, Visitor *v, const char *name,
     Property *prop = opaque;
     uint32_t *alenptr = qdev_get_prop_ptr(dev, prop);
     void **arrayptr = (void *)dev + prop->arrayoffset;
-    Error *local_err = NULL;
     void *eltptr;
     const char *arrayname;
     int i;
@@ -1000,9 +982,8 @@ static void set_prop_arraylen(Object *obj, Visitor *v, const char *name,
                    name);
         return;
     }
-    visit_type_uint32(v, name, alenptr, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_uint32(v, name, alenptr, errp);
+    if (*errp) {
         return;
     }
     if (!*alenptr) {
@@ -1039,9 +1020,8 @@ static void set_prop_arraylen(Object *obj, Visitor *v, const char *name,
                             arrayprop->prop.info->get,
                             arrayprop->prop.info->set,
                             array_element_release,
-                            arrayprop, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                            arrayprop, errp);
+        if (*errp) {
             return;
         }
     }
@@ -1326,16 +1306,14 @@ static void set_prop_pcielinkspeed(Object *obj, Visitor *v, const char *name,
     Property *prop = opaque;
     PCIExpLinkSpeed *p = qdev_get_prop_ptr(dev, prop);
     int speed;
-    Error *local_err = NULL;
 
     if (dev->realized) {
         qdev_prop_set_after_realize(dev, name, errp);
         return;
     }
 
-    visit_type_enum(v, prop->name, &speed, prop->info->enum_table, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_enum(v, prop->name, &speed, prop->info->enum_table, errp);
+    if (*errp) {
         return;
     }
 
@@ -1414,16 +1392,14 @@ static void set_prop_pcielinkwidth(Object *obj, Visitor *v, const char *name,
     Property *prop = opaque;
     PCIExpLinkWidth *p = qdev_get_prop_ptr(dev, prop);
     int width;
-    Error *local_err = NULL;
 
     if (dev->realized) {
         qdev_prop_set_after_realize(dev, name, errp);
         return;
     }
 
-    visit_type_enum(v, prop->name, &width, prop->info->enum_table, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_enum(v, prop->name, &width, prop->info->enum_table, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/core/qdev.c b/hw/core/qdev.c
index cbad6c1d55..34eca74089 100644
--- a/hw/core/qdev.c
+++ b/hw/core/qdev.c
@@ -709,11 +709,10 @@ static void qdev_property_add_legacy(DeviceState *dev, Property *prop,
 void qdev_property_add_static(DeviceState *dev, Property *prop,
                               Error **errp)
 {
-    Error *local_err = NULL;
     Object *obj = OBJECT(dev);
 
     if (prop->info->create) {
-        prop->info->create(obj, prop, &local_err);
+        prop->info->create(obj, prop, errp);
     } else {
         /*
          * TODO qdev_prop_ptr does not have getters or setters.  It must
@@ -726,11 +725,10 @@ void qdev_property_add_static(DeviceState *dev, Property *prop,
         object_property_add(obj, prop->name, prop->info->name,
                             prop->info->get, prop->info->set,
                             prop->info->release,
-                            prop, &local_err);
+                            prop, errp);
     }
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return;
     }
 
@@ -816,7 +814,6 @@ static void device_set_realized(Object *obj, bool value, Error **errp)
     DeviceClass *dc = DEVICE_GET_CLASS(dev);
     HotplugHandler *hotplug_ctrl;
     BusState *bus;
-    Error *local_err = NULL;
     bool unattached_parent = false;
     static int unattached_count;
 
@@ -826,7 +823,7 @@ static void device_set_realized(Object *obj, bool value, Error **errp)
     }
 
     if (value && !dev->realized) {
-        if (!check_only_migratable(obj, &local_err)) {
+        if (!check_only_migratable(obj, errp)) {
             goto fail;
         }
 
@@ -842,17 +839,17 @@ static void device_set_realized(Object *obj, bool value, Error **errp)
 
         hotplug_ctrl = qdev_get_hotplug_handler(dev);
         if (hotplug_ctrl) {
-            hotplug_handler_pre_plug(hotplug_ctrl, dev, &local_err);
-            if (local_err != NULL) {
+            hotplug_handler_pre_plug(hotplug_ctrl, dev, errp);
+            if (*errp != NULL) {
                 goto fail;
             }
         }
 
         if (dc->realize) {
-            dc->realize(dev, &local_err);
+            dc->realize(dev, errp);
         }
 
-        if (local_err != NULL) {
+        if (*errp != NULL) {
             goto fail;
         }
 
@@ -869,15 +866,15 @@ static void device_set_realized(Object *obj, bool value, Error **errp)
             if (vmstate_register_with_alias_id(dev, -1, qdev_get_vmsd(dev), dev,
                                                dev->instance_id_alias,
                                                dev->alias_required_for_version,
-                                               &local_err) < 0) {
+                                               errp) < 0) {
                 goto post_realize_fail;
             }
         }
 
         QLIST_FOREACH(bus, &dev->child_bus, sibling) {
             object_property_set_bool(OBJECT(bus), true, "realized",
-                                         &local_err);
-            if (local_err != NULL) {
+                                         errp);
+            if (*errp != NULL) {
                 goto child_realize_fail;
             }
         }
@@ -887,8 +884,8 @@ static void device_set_realized(Object *obj, bool value, Error **errp)
         dev->pending_deleted_event = false;
 
         if (hotplug_ctrl) {
-            hotplug_handler_plug(hotplug_ctrl, dev, &local_err);
-            if (local_err != NULL) {
+            hotplug_handler_plug(hotplug_ctrl, dev, errp);
+            if (*errp != NULL) {
                 goto child_realize_fail;
             }
        }
@@ -896,7 +893,7 @@ static void device_set_realized(Object *obj, bool value, Error **errp)
     } else if (!value && dev->realized) {
         Error **local_errp = NULL;
         QLIST_FOREACH(bus, &dev->child_bus, sibling) {
-            local_errp = local_err ? NULL : &local_err;
+            local_errp = *errp ? NULL : errp;
             object_property_set_bool(OBJECT(bus), false, "realized",
                                      local_errp);
         }
@@ -904,14 +901,14 @@ static void device_set_realized(Object *obj, bool value, Error **errp)
             vmstate_unregister(dev, qdev_get_vmsd(dev), dev);
         }
         if (dc->unrealize) {
-            local_errp = local_err ? NULL : &local_err;
+            local_errp = *errp ? NULL : errp;
             dc->unrealize(dev, local_errp);
         }
         dev->pending_deleted_event = true;
         DEVICE_LISTENER_CALL(unrealize, Reverse, dev);
     }
 
-    if (local_err != NULL) {
+    if (*errp != NULL) {
         goto fail;
     }
 
@@ -936,7 +933,6 @@ post_realize_fail:
     }
 
 fail:
-    error_propagate(errp, local_err);
     if (unattached_parent) {
         object_unparent(OBJECT(dev));
         unattached_count--;
diff --git a/hw/core/sysbus.c b/hw/core/sysbus.c
index 9e69c83aed..bb7d25df38 100644
--- a/hw/core/sysbus.c
+++ b/hw/core/sysbus.c
@@ -219,6 +219,7 @@ void sysbus_init_ioports(SysBusDevice *dev, uint32_t ioport, uint32_t size)
  */
 static void sysbus_realize(DeviceState *dev, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 DeviceState *sysbus_create_varargs(const char *name,
diff --git a/hw/cpu/a15mpcore.c b/hw/cpu/a15mpcore.c
index 7e9983aa19..6dfcc9a042 100644
--- a/hw/cpu/a15mpcore.c
+++ b/hw/cpu/a15mpcore.c
@@ -54,7 +54,6 @@ static void a15mp_priv_realize(DeviceState *dev, Error **errp)
     DeviceState *gicdev;
     SysBusDevice *busdev;
     int i;
-    Error *err = NULL;
     bool has_el3;
     bool has_el2 = false;
     Object *cpuobj;
@@ -77,9 +76,8 @@ static void a15mp_priv_realize(DeviceState *dev, Error **errp)
         qdev_prop_set_bit(gicdev, "has-virtualization-extensions", has_el2);
     }
 
-    object_property_set_bool(OBJECT(&s->gic), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gic), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     busdev = SYS_BUS_DEVICE(&s->gic);
diff --git a/hw/cpu/a9mpcore.c b/hw/cpu/a9mpcore.c
index 6872a3a00a..e1c010c158 100644
--- a/hw/cpu/a9mpcore.c
+++ b/hw/cpu/a9mpcore.c
@@ -51,16 +51,14 @@ static void a9mp_priv_realize(DeviceState *dev, Error **errp)
     DeviceState *scudev, *gicdev, *gtimerdev, *mptimerdev, *wdtdev;
     SysBusDevice *scubusdev, *gicbusdev, *gtimerbusdev, *mptimerbusdev,
                  *wdtbusdev;
-    Error *err = NULL;
     int i;
     bool has_el3;
     Object *cpuobj;
 
     scudev = DEVICE(&s->scu);
     qdev_prop_set_uint32(scudev, "num-cpu", s->num_cpu);
-    object_property_set_bool(OBJECT(&s->scu), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->scu), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     scubusdev = SYS_BUS_DEVICE(&s->scu);
@@ -77,9 +75,8 @@ static void a9mp_priv_realize(DeviceState *dev, Error **errp)
         object_property_get_bool(cpuobj, "has_el3", &error_abort);
     qdev_prop_set_bit(gicdev, "has-security-extensions", has_el3);
 
-    object_property_set_bool(OBJECT(&s->gic), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gic), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     gicbusdev = SYS_BUS_DEVICE(&s->gic);
@@ -92,27 +89,24 @@ static void a9mp_priv_realize(DeviceState *dev, Error **errp)
 
     gtimerdev = DEVICE(&s->gtimer);
     qdev_prop_set_uint32(gtimerdev, "num-cpu", s->num_cpu);
-    object_property_set_bool(OBJECT(&s->gtimer), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gtimer), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     gtimerbusdev = SYS_BUS_DEVICE(&s->gtimer);
 
     mptimerdev = DEVICE(&s->mptimer);
     qdev_prop_set_uint32(mptimerdev, "num-cpu", s->num_cpu);
-    object_property_set_bool(OBJECT(&s->mptimer), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->mptimer), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     mptimerbusdev = SYS_BUS_DEVICE(&s->mptimer);
 
     wdtdev = DEVICE(&s->wdt);
     qdev_prop_set_uint32(wdtdev, "num-cpu", s->num_cpu);
-    object_property_set_bool(OBJECT(&s->wdt), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->wdt), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     wdtbusdev = SYS_BUS_DEVICE(&s->wdt);
diff --git a/hw/cpu/arm11mpcore.c b/hw/cpu/arm11mpcore.c
index e78f5d080c..2292c2dbf6 100644
--- a/hw/cpu/arm11mpcore.c
+++ b/hw/cpu/arm11mpcore.c
@@ -75,20 +75,17 @@ static void mpcore_priv_realize(DeviceState *dev, Error **errp)
     DeviceState *gicdev = DEVICE(&s->gic);
     DeviceState *mptimerdev = DEVICE(&s->mptimer);
     DeviceState *wdtimerdev = DEVICE(&s->wdtimer);
-    Error *err = NULL;
 
     qdev_prop_set_uint32(scudev, "num-cpu", s->num_cpu);
-    object_property_set_bool(OBJECT(&s->scu), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->scu), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
     qdev_prop_set_uint32(gicdev, "num-cpu", s->num_cpu);
     qdev_prop_set_uint32(gicdev, "num-irq", s->num_irq);
-    object_property_set_bool(OBJECT(&s->gic), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gic), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
@@ -99,16 +96,14 @@ static void mpcore_priv_realize(DeviceState *dev, Error **errp)
     qdev_init_gpio_in(dev, mpcore_priv_set_irq, s->num_irq - 32);
 
     qdev_prop_set_uint32(mptimerdev, "num-cpu", s->num_cpu);
-    object_property_set_bool(OBJECT(&s->mptimer), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->mptimer), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
     qdev_prop_set_uint32(wdtimerdev, "num-cpu", s->num_cpu);
-    object_property_set_bool(OBJECT(&s->wdtimer), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->wdtimer), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/hw/cpu/core.c b/hw/cpu/core.c
index 9874c5c870..8f2d4e3b64 100644
--- a/hw/cpu/core.c
+++ b/hw/cpu/core.c
@@ -28,12 +28,10 @@ static void core_prop_set_core_id(Object *obj, Visitor *v, const char *name,
                                   void *opaque, Error **errp)
 {
     CPUCore *core = CPU_CORE(obj);
-    Error *local_err = NULL;
     int64_t value;
 
-    visit_type_int(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_int(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
@@ -58,12 +56,10 @@ static void core_prop_set_nr_threads(Object *obj, Visitor *v, const char *name,
                                      void *opaque, Error **errp)
 {
     CPUCore *core = CPU_CORE(obj);
-    Error *local_err = NULL;
     int64_t value;
 
-    visit_type_int(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_int(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/cpu/realview_mpcore.c b/hw/cpu/realview_mpcore.c
index ae2c9913f6..d6331192a5 100644
--- a/hw/cpu/realview_mpcore.c
+++ b/hw/cpu/realview_mpcore.c
@@ -65,14 +65,12 @@ static void realview_mpcore_realize(DeviceState *dev, Error **errp)
     DeviceState *priv = DEVICE(&s->priv);
     DeviceState *gic;
     SysBusDevice *gicbusdev;
-    Error *err = NULL;
     int n;
     int i;
 
     qdev_prop_set_uint32(priv, "num-cpu", s->num_cpu);
-    object_property_set_bool(OBJECT(&s->priv), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->priv), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     sysbus_pass_irq(sbd, SYS_BUS_DEVICE(&s->priv));
@@ -81,9 +79,8 @@ static void realview_mpcore_realize(DeviceState *dev, Error **errp)
     }
     /* ??? IRQ routing is hardcoded to "normal" mode.  */
     for (n = 0; n < 4; n++) {
-        object_property_set_bool(OBJECT(&s->gic[n]), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->gic[n]), true, "realized", errp);
+        if (*errp != NULL) {
             return;
         }
         gic = DEVICE(&s->gic[n]);
diff --git a/hw/display/bcm2835_fb.c b/hw/display/bcm2835_fb.c
index 8f856878cd..584fc0164c 100644
--- a/hw/display/bcm2835_fb.c
+++ b/hw/display/bcm2835_fb.c
@@ -402,7 +402,6 @@ static void bcm2835_fb_reset(DeviceState *dev)
 static void bcm2835_fb_realize(DeviceState *dev, Error **errp)
 {
     BCM2835FBState *s = BCM2835_FB(dev);
-    Error *err = NULL;
     Object *obj;
 
     if (s->vcram_base == 0) {
@@ -410,10 +409,10 @@ static void bcm2835_fb_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    obj = object_property_get_link(OBJECT(dev), "dma-mr", &err);
+    obj = object_property_get_link(OBJECT(dev), "dma-mr", errp);
     if (obj == NULL) {
         error_setg(errp, "%s: required dma-mr link not found: %s",
-                   __func__, error_get_pretty(err));
+                   __func__, error_get_pretty(*errp));
         return;
     }
 
diff --git a/hw/display/qxl.c b/hw/display/qxl.c
index cd7eb39d20..c693726253 100644
--- a/hw/display/qxl.c
+++ b/hw/display/qxl.c
@@ -2212,7 +2212,6 @@ static void qxl_realize_primary(PCIDevice *dev, Error **errp)
 {
     PCIQXLDevice *qxl = PCI_QXL(dev);
     VGACommonState *vga = &qxl->vga;
-    Error *local_err = NULL;
 
     qxl_init_ramsize(qxl);
     vga->vbe_size = qxl->vgamem_size;
@@ -2234,9 +2233,8 @@ static void qxl_realize_primary(PCIDevice *dev, Error **errp)
         return;
     }
 
-    qxl_realize_common(qxl, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qxl_realize_common(qxl, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/display/virtio-gpu-base.c b/hw/display/virtio-gpu-base.c
index 55e07995fe..241839e83f 100644
--- a/hw/display/virtio-gpu-base.c
+++ b/hw/display/virtio-gpu-base.c
@@ -128,7 +128,6 @@ virtio_gpu_base_device_realize(DeviceState *qdev,
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(qdev);
     VirtIOGPUBase *g = VIRTIO_GPU_BASE(qdev);
-    Error *local_err = NULL;
     int i;
 
     if (g->conf.max_outputs > VIRTIO_GPU_MAX_SCANOUTS) {
@@ -139,9 +138,8 @@ virtio_gpu_base_device_realize(DeviceState *qdev,
     g->use_virgl_renderer = false;
     if (virtio_gpu_virgl_enabled(g->conf)) {
         error_setg(&g->migration_blocker, "virgl is not yet migratable");
-        migrate_add_blocker(g->migration_blocker, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        migrate_add_blocker(g->migration_blocker, errp);
+        if (*errp) {
             error_free(g->migration_blocker);
             return false;
         }
diff --git a/hw/display/virtio-gpu-pci.c b/hw/display/virtio-gpu-pci.c
index 25e4038874..b6f8c207c9 100644
--- a/hw/display/virtio-gpu-pci.c
+++ b/hw/display/virtio-gpu-pci.c
@@ -31,14 +31,12 @@ static void virtio_gpu_pci_base_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
     VirtIOGPUBase *g = vgpu->vgpu;
     DeviceState *vdev = DEVICE(g);
     int i;
-    Error *local_error = NULL;
 
     qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
     virtio_pci_force_virtio_1(vpci_dev);
-    object_property_set_bool(OBJECT(vdev), true, "realized", &local_error);
+    object_property_set_bool(OBJECT(vdev), true, "realized", errp);
 
-    if (local_error) {
-        error_propagate(errp, local_error);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/display/virtio-vga.c b/hw/display/virtio-vga.c
index cc6e66ea1c..bd7cc06f86 100644
--- a/hw/display/virtio-vga.c
+++ b/hw/display/virtio-vga.c
@@ -93,7 +93,6 @@ static void virtio_vga_base_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
     VirtIOVGABase *vvga = VIRTIO_VGA_BASE(vpci_dev);
     VirtIOGPUBase *g = vvga->vgpu;
     VGACommonState *vga = &vvga->vga;
-    Error *err = NULL;
     uint32_t offset;
     int i;
 
@@ -138,9 +137,8 @@ static void virtio_vga_base_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
     /* init virtio bits */
     qdev_set_parent_bus(DEVICE(g), BUS(&vpci_dev->bus));
     virtio_pci_force_virtio_1(vpci_dev);
-    object_property_set_bool(OBJECT(g), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(g), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/dma/bcm2835_dma.c b/hw/dma/bcm2835_dma.c
index 192bd377a0..331779bbd9 100644
--- a/hw/dma/bcm2835_dma.c
+++ b/hw/dma/bcm2835_dma.c
@@ -372,13 +372,12 @@ static void bcm2835_dma_reset(DeviceState *dev)
 static void bcm2835_dma_realize(DeviceState *dev, Error **errp)
 {
     BCM2835DMAState *s = BCM2835_DMA(dev);
-    Error *err = NULL;
     Object *obj;
 
-    obj = object_property_get_link(OBJECT(dev), "dma-mr", &err);
+    obj = object_property_get_link(OBJECT(dev), "dma-mr", errp);
     if (obj == NULL) {
         error_setg(errp, "%s: required dma-mr link not found: %s",
-                   __func__, error_get_pretty(err));
+                   __func__, error_get_pretty(*errp));
         return;
     }
 
diff --git a/hw/dma/xilinx_axidma.c b/hw/dma/xilinx_axidma.c
index a254275b64..b5f49e6f88 100644
--- a/hw/dma/xilinx_axidma.c
+++ b/hw/dma/xilinx_axidma.c
@@ -524,24 +524,23 @@ static void xilinx_axidma_realize(DeviceState *dev, Error **errp)
     XilinxAXIDMAStreamSlave *ds = XILINX_AXI_DMA_DATA_STREAM(&s->rx_data_dev);
     XilinxAXIDMAStreamSlave *cs = XILINX_AXI_DMA_CONTROL_STREAM(
                                                             &s->rx_control_dev);
-    Error *local_err = NULL;
 
     object_property_add_link(OBJECT(ds), "dma", TYPE_XILINX_AXI_DMA,
                              (Object **)&ds->dma,
                              object_property_allow_set_link,
                              OBJ_PROP_LINK_STRONG,
-                             &local_err);
+                             errp);
     object_property_add_link(OBJECT(cs), "dma", TYPE_XILINX_AXI_DMA,
                              (Object **)&cs->dma,
                              object_property_allow_set_link,
                              OBJ_PROP_LINK_STRONG,
-                             &local_err);
-    if (local_err) {
+                             errp);
+    if (*errp) {
         goto xilinx_axidma_realize_fail;
     }
-    object_property_set_link(OBJECT(ds), OBJECT(s), "dma", &local_err);
-    object_property_set_link(OBJECT(cs), OBJECT(s), "dma", &local_err);
-    if (local_err) {
+    object_property_set_link(OBJECT(ds), OBJECT(s), "dma", errp);
+    object_property_set_link(OBJECT(cs), OBJECT(s), "dma", errp);
+    if (*errp) {
         goto xilinx_axidma_realize_fail;
     }
 
@@ -558,7 +557,6 @@ static void xilinx_axidma_realize(DeviceState *dev, Error **errp)
     return;
 
 xilinx_axidma_realize_fail:
-    error_propagate(errp, local_err);
 }
 
 static void xilinx_axidma_init(Object *obj)
diff --git a/hw/gpio/aspeed_gpio.c b/hw/gpio/aspeed_gpio.c
index 25fbfec3b8..695c91aec1 100644
--- a/hw/gpio/aspeed_gpio.c
+++ b/hw/gpio/aspeed_gpio.c
@@ -679,16 +679,14 @@ static void aspeed_gpio_get_pin(Object *obj, Visitor *v, const char *name,
 static void aspeed_gpio_set_pin(Object *obj, Visitor *v, const char *name,
                                void *opaque, Error **errp)
 {
-    Error *local_err = NULL;
     bool level;
     int pin = 0xfff;
     char group[3];
     AspeedGPIOState *s = ASPEED_GPIO(obj);
     int set_idx, group_idx = 0;
 
-    visit_type_bool(v, name, &level, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_bool(v, name, &level, errp);
+    if (*errp) {
         return;
     }
     if (sscanf(name, "gpio%2[A-Z]%1d", group, &pin) != 2) {
diff --git a/hw/gpio/bcm2835_gpio.c b/hw/gpio/bcm2835_gpio.c
index 91ce3d10cc..363ada96d2 100644
--- a/hw/gpio/bcm2835_gpio.c
+++ b/hw/gpio/bcm2835_gpio.c
@@ -312,20 +312,19 @@ static void bcm2835_gpio_realize(DeviceState *dev, Error **errp)
 {
     BCM2835GpioState *s = BCM2835_GPIO(dev);
     Object *obj;
-    Error *err = NULL;
 
-    obj = object_property_get_link(OBJECT(dev), "sdbus-sdhci", &err);
+    obj = object_property_get_link(OBJECT(dev), "sdbus-sdhci", errp);
     if (obj == NULL) {
         error_setg(errp, "%s: required sdhci link not found: %s",
-                __func__, error_get_pretty(err));
+                __func__, error_get_pretty(*errp));
         return;
     }
     s->sdbus_sdhci = SD_BUS(obj);
 
-    obj = object_property_get_link(OBJECT(dev), "sdbus-sdhost", &err);
+    obj = object_property_get_link(OBJECT(dev), "sdbus-sdhost", errp);
     if (obj == NULL) {
         error_setg(errp, "%s: required sdhost link not found: %s",
-                __func__, error_get_pretty(err));
+                __func__, error_get_pretty(*errp));
         return;
     }
     s->sdbus_sdhost = SD_BUS(obj);
diff --git a/hw/i386/kvm/apic.c b/hw/i386/kvm/apic.c
index 91fb622d63..d125b370f4 100644
--- a/hw/i386/kvm/apic.c
+++ b/hw/i386/kvm/apic.c
@@ -232,6 +232,7 @@ static void kvm_apic_realize(DeviceState *dev, Error **errp)
 
 static void kvm_apic_unrealize(DeviceState *dev, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static void kvm_apic_class_init(ObjectClass *klass, void *data)
diff --git a/hw/i386/pc.c b/hw/i386/pc.c
index bcda50efcc..883467136a 100644
--- a/hw/i386/pc.c
+++ b/hw/i386/pc.c
@@ -1377,7 +1377,6 @@ void pc_acpi_smi_interrupt(void *opaque, int irq, int level)
 static void pc_new_cpu(PCMachineState *pcms, int64_t apic_id, Error **errp)
 {
     Object *cpu = NULL;
-    Error *local_err = NULL;
     CPUX86State *env = NULL;
 
     cpu = object_new(MACHINE(pcms)->cpu_type);
@@ -1385,11 +1384,10 @@ static void pc_new_cpu(PCMachineState *pcms, int64_t apic_id, Error **errp)
     env = &X86_CPU(cpu)->env;
     env->nr_dies = pcms->smp_dies;
 
-    object_property_set_uint(cpu, apic_id, "apic-id", &local_err);
-    object_property_set_bool(cpu, true, "realized", &local_err);
+    object_property_set_uint(cpu, apic_id, "apic-id", errp);
+    object_property_set_bool(cpu, true, "realized", errp);
 
     object_unref(cpu);
-    error_propagate(errp, local_err);
 }
 
 /*
@@ -1476,7 +1474,6 @@ void pc_hot_add_cpu(MachineState *ms, const int64_t id, Error **errp)
 {
     PCMachineState *pcms = PC_MACHINE(ms);
     int64_t apic_id = x86_cpu_apic_id_from_index(pcms, id);
-    Error *local_err = NULL;
 
     if (id < 0) {
         error_setg(errp, "Invalid CPU id: %" PRIi64, id);
@@ -1490,9 +1487,8 @@ void pc_hot_add_cpu(MachineState *ms, const int64_t id, Error **errp)
         return;
     }
 
-    pc_new_cpu(PC_MACHINE(ms), apic_id, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pc_new_cpu(PC_MACHINE(ms), apic_id, errp);
+    if (*errp) {
         return;
     }
 }
@@ -1995,7 +1991,6 @@ static void pc_memory_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
     const MachineState *ms = MACHINE(hotplug_dev);
     const bool is_nvdimm = object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM);
     const uint64_t legacy_align = TARGET_PAGE_SIZE;
-    Error *local_err = NULL;
 
     /*
      * When -no-acpi is used with Q35 machine type, no ACPI is built,
@@ -2013,9 +2008,8 @@ static void pc_memory_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
         return;
     }
 
-    hotplug_handler_pre_plug(pcms->acpi_dev, dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    hotplug_handler_pre_plug(pcms->acpi_dev, dev, errp);
+    if (*errp) {
         return;
     }
 
@@ -2026,14 +2020,13 @@ static void pc_memory_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
 static void pc_memory_plug(HotplugHandler *hotplug_dev,
                            DeviceState *dev, Error **errp)
 {
-    Error *local_err = NULL;
     PCMachineState *pcms = PC_MACHINE(hotplug_dev);
     MachineState *ms = MACHINE(hotplug_dev);
     bool is_nvdimm = object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM);
 
-    pc_dimm_plug(PC_DIMM(dev), MACHINE(pcms), &local_err);
-    if (local_err) {
-        goto out;
+    pc_dimm_plug(PC_DIMM(dev), MACHINE(pcms), errp);
+    if (*errp) {
+        return;
     }
 
     if (is_nvdimm) {
@@ -2041,14 +2034,11 @@ static void pc_memory_plug(HotplugHandler *hotplug_dev,
     }
 
     hotplug_handler_plug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &error_abort);
-out:
-    error_propagate(errp, local_err);
 }
 
 static void pc_memory_unplug_request(HotplugHandler *hotplug_dev,
                                      DeviceState *dev, Error **errp)
 {
-    Error *local_err = NULL;
     PCMachineState *pcms = PC_MACHINE(hotplug_dev);
 
     /*
@@ -2057,38 +2047,33 @@ static void pc_memory_unplug_request(HotplugHandler *hotplug_dev,
      * addition to cover this case.
      */
     if (!pcms->acpi_dev || !acpi_enabled) {
-        error_setg(&local_err,
+        error_setg(errp,
                    "memory hotplug is not enabled: missing acpi device or acpi disabled");
-        goto out;
+        return;
     }
 
     if (object_dynamic_cast(OBJECT(dev), TYPE_NVDIMM)) {
-        error_setg(&local_err,
+        error_setg(errp,
                    "nvdimm device hot unplug is not supported yet.");
-        goto out;
+        return;
     }
 
     hotplug_handler_unplug_request(HOTPLUG_HANDLER(pcms->acpi_dev), dev,
-                                   &local_err);
-out:
-    error_propagate(errp, local_err);
+                                   errp);
 }
 
 static void pc_memory_unplug(HotplugHandler *hotplug_dev,
                              DeviceState *dev, Error **errp)
 {
     PCMachineState *pcms = PC_MACHINE(hotplug_dev);
-    Error *local_err = NULL;
 
-    hotplug_handler_unplug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &local_err);
-    if (local_err) {
-        goto out;
+    hotplug_handler_unplug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, errp);
+    if (*errp) {
+        return;
     }
 
     pc_dimm_unplug(PC_DIMM(dev), MACHINE(pcms));
     object_property_set_bool(OBJECT(dev), false, "realized", NULL);
- out:
-    error_propagate(errp, local_err);
 }
 
 static int pc_apic_cmp(const void *a, const void *b)
@@ -2121,14 +2106,13 @@ static void pc_cpu_plug(HotplugHandler *hotplug_dev,
                         DeviceState *dev, Error **errp)
 {
     CPUArchId *found_cpu;
-    Error *local_err = NULL;
     X86CPU *cpu = X86_CPU(dev);
     PCMachineState *pcms = PC_MACHINE(hotplug_dev);
 
     if (pcms->acpi_dev) {
-        hotplug_handler_plug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &local_err);
-        if (local_err) {
-            goto out;
+        hotplug_handler_plug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, errp);
+        if (*errp) {
+            return;
         }
     }
 
@@ -2143,51 +2127,44 @@ static void pc_cpu_plug(HotplugHandler *hotplug_dev,
 
     found_cpu = pc_find_cpu_slot(MACHINE(pcms), cpu->apic_id, NULL);
     found_cpu->cpu = OBJECT(dev);
-out:
-    error_propagate(errp, local_err);
 }
 static void pc_cpu_unplug_request_cb(HotplugHandler *hotplug_dev,
                                      DeviceState *dev, Error **errp)
 {
     int idx = -1;
-    Error *local_err = NULL;
     X86CPU *cpu = X86_CPU(dev);
     PCMachineState *pcms = PC_MACHINE(hotplug_dev);
 
     if (!pcms->acpi_dev) {
-        error_setg(&local_err, "CPU hot unplug not supported without ACPI");
-        goto out;
+        error_setg(errp, "CPU hot unplug not supported without ACPI");
+        return;
     }
 
     pc_find_cpu_slot(MACHINE(pcms), cpu->apic_id, &idx);
     assert(idx != -1);
     if (idx == 0) {
-        error_setg(&local_err, "Boot CPU is unpluggable");
-        goto out;
+        error_setg(errp, "Boot CPU is unpluggable");
+        return;
     }
 
     hotplug_handler_unplug_request(HOTPLUG_HANDLER(pcms->acpi_dev), dev,
-                                   &local_err);
-    if (local_err) {
-        goto out;
+                                   errp);
+    if (*errp) {
+        return;
     }
 
- out:
-    error_propagate(errp, local_err);
-
 }
 
 static void pc_cpu_unplug_cb(HotplugHandler *hotplug_dev,
                              DeviceState *dev, Error **errp)
 {
     CPUArchId *found_cpu;
-    Error *local_err = NULL;
     X86CPU *cpu = X86_CPU(dev);
     PCMachineState *pcms = PC_MACHINE(hotplug_dev);
 
-    hotplug_handler_unplug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, &local_err);
-    if (local_err) {
-        goto out;
+    hotplug_handler_unplug(HOTPLUG_HANDLER(pcms->acpi_dev), dev, errp);
+    if (*errp) {
+        return;
     }
 
     found_cpu = pc_find_cpu_slot(MACHINE(pcms), cpu->apic_id, NULL);
@@ -2199,8 +2176,6 @@ static void pc_cpu_unplug_cb(HotplugHandler *hotplug_dev,
     /* Update the number of CPUs in CMOS */
     rtc_set_cpus_count(pcms->rtc, pcms->boot_cpus);
     fw_cfg_modify_i16(pcms->fw_cfg, FW_CFG_NB_CPUS, pcms->boot_cpus);
- out:
-    error_propagate(errp, local_err);
 }
 
 static void pc_cpu_pre_plug(HotplugHandler *hotplug_dev,
@@ -2354,7 +2329,6 @@ static void pc_virtio_pmem_pci_pre_plug(HotplugHandler *hotplug_dev,
                                         DeviceState *dev, Error **errp)
 {
     HotplugHandler *hotplug_dev2 = qdev_get_bus_hotplug_handler(dev);
-    Error *local_err = NULL;
 
     if (!hotplug_dev2) {
         /*
@@ -2370,18 +2344,16 @@ static void pc_virtio_pmem_pci_pre_plug(HotplugHandler *hotplug_dev,
      * succeeds, branch of to the actual hotplug handler.
      */
     memory_device_pre_plug(MEMORY_DEVICE(dev), MACHINE(hotplug_dev), NULL,
-                           &local_err);
-    if (!local_err) {
-        hotplug_handler_pre_plug(hotplug_dev2, dev, &local_err);
+                           errp);
+    if (!*errp) {
+        hotplug_handler_pre_plug(hotplug_dev2, dev, errp);
     }
-    error_propagate(errp, local_err);
 }
 
 static void pc_virtio_pmem_pci_plug(HotplugHandler *hotplug_dev,
                                     DeviceState *dev, Error **errp)
 {
     HotplugHandler *hotplug_dev2 = qdev_get_bus_hotplug_handler(dev);
-    Error *local_err = NULL;
 
     /*
      * Plug the memory device first and then branch off to the actual
@@ -2389,11 +2361,10 @@ static void pc_virtio_pmem_pci_plug(HotplugHandler *hotplug_dev,
      * device bits.
      */
     memory_device_plug(MEMORY_DEVICE(dev), MACHINE(hotplug_dev));
-    hotplug_handler_plug(hotplug_dev2, dev, &local_err);
-    if (local_err) {
+    hotplug_handler_plug(hotplug_dev2, dev, errp);
+    if (*errp) {
         memory_device_unplug(MEMORY_DEVICE(dev), MACHINE(hotplug_dev));
     }
-    error_propagate(errp, local_err);
 }
 
 static void pc_virtio_pmem_pci_unplug_request(HotplugHandler *hotplug_dev,
@@ -2406,6 +2377,7 @@ static void pc_virtio_pmem_pci_unplug_request(HotplugHandler *hotplug_dev,
 static void pc_virtio_pmem_pci_unplug(HotplugHandler *hotplug_dev,
                                       DeviceState *dev, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
     /* We don't support virtio pmem hot unplug */
 }
 
@@ -2505,19 +2477,16 @@ static void pc_machine_set_max_ram_below_4g(Object *obj, Visitor *v,
                                             Error **errp)
 {
     PCMachineState *pcms = PC_MACHINE(obj);
-    Error *error = NULL;
     uint64_t value;
 
-    visit_type_size(v, name, &value, &error);
-    if (error) {
-        error_propagate(errp, error);
+    visit_type_size(v, name, &value, errp);
+    if (*errp) {
         return;
     }
     if (value > 4 * GiB) {
-        error_setg(&error,
+        error_setg(errp,
                    "Machine option 'max-ram-below-4g=%"PRIu64
                    "' expects size less than or equal to 4G", value);
-        error_propagate(errp, error);
         return;
     }
 
diff --git a/hw/ide/qdev.c b/hw/ide/qdev.c
index 6fba6b62b8..58fbb9263b 100644
--- a/hw/ide/qdev.c
+++ b/hw/ide/qdev.c
@@ -235,16 +235,15 @@ static void ide_dev_set_bootindex(Object *obj, Visitor *v, const char *name,
 {
     IDEDevice *d = IDE_DEVICE(obj);
     int32_t boot_index;
-    Error *local_err = NULL;
 
-    visit_type_int32(v, name, &boot_index, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_int32(v, name, &boot_index, errp);
+    if (*errp) {
+        return;
     }
     /* check whether bootindex is present in fw_boot_order list  */
-    check_boot_index(boot_index, &local_err);
-    if (local_err) {
-        goto out;
+    check_boot_index(boot_index, errp);
+    if (*errp) {
+        return;
     }
     /* change bootindex to a new one */
     d->conf.bootindex = boot_index;
@@ -253,8 +252,6 @@ static void ide_dev_set_bootindex(Object *obj, Visitor *v, const char *name,
         add_boot_device_path(d->conf.bootindex, &d->qdev,
                              d->unit ? "/disk@1" : "/disk@0");
     }
-out:
-    error_propagate(errp, local_err);
 }
 
 static void ide_dev_instance_init(Object *obj)
diff --git a/hw/input/virtio-input.c b/hw/input/virtio-input.c
index 51617a5885..ff2c849e68 100644
--- a/hw/input/virtio-input.c
+++ b/hw/input/virtio-input.c
@@ -236,12 +236,10 @@ static void virtio_input_device_realize(DeviceState *dev, Error **errp)
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
     VirtIOInput *vinput = VIRTIO_INPUT(dev);
     VirtIOInputConfig *cfg;
-    Error *local_err = NULL;
 
     if (vic->realize) {
-        vic->realize(dev, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        vic->realize(dev, errp);
+        if (*errp) {
             return;
         }
     }
@@ -279,12 +277,10 @@ static void virtio_input_device_unrealize(DeviceState *dev, Error **errp)
 {
     VirtIOInputClass *vic = VIRTIO_INPUT_GET_CLASS(dev);
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
-    Error *local_err = NULL;
 
     if (vic->unrealize) {
-        vic->unrealize(dev, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        vic->unrealize(dev, errp);
+        if (*errp) {
             return;
         }
     }
diff --git a/hw/intc/apic_common.c b/hw/intc/apic_common.c
index aafd8e0e33..38c1b5b5c5 100644
--- a/hw/intc/apic_common.c
+++ b/hw/intc/apic_common.c
@@ -466,7 +466,6 @@ static void apic_common_set_id(Object *obj, Visitor *v, const char *name,
 {
     APICCommonState *s = APIC_COMMON(obj);
     DeviceState *dev = DEVICE(obj);
-    Error *local_err = NULL;
     uint32_t value;
 
     if (dev->realized) {
@@ -474,9 +473,8 @@ static void apic_common_set_id(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_uint32(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_uint32(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/intc/arm_gic.c b/hw/intc/arm_gic.c
index 1d7da7baa2..8c340e2e28 100644
--- a/hw/intc/arm_gic.c
+++ b/hw/intc/arm_gic.c
@@ -2041,11 +2041,9 @@ static void arm_gic_realize(DeviceState *dev, Error **errp)
     GICState *s = ARM_GIC(dev);
     SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
     ARMGICClass *agc = ARM_GIC_GET_CLASS(s);
-    Error *local_err = NULL;
 
-    agc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    agc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/intc/arm_gic_kvm.c b/hw/intc/arm_gic_kvm.c
index b56fda144f..beb9476c1e 100644
--- a/hw/intc/arm_gic_kvm.c
+++ b/hw/intc/arm_gic_kvm.c
@@ -496,12 +496,10 @@ static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)
     int i;
     GICState *s = KVM_ARM_GIC(dev);
     KVMARMGICClass *kgc = KVM_ARM_GIC_GET_CLASS(s);
-    Error *local_err = NULL;
     int ret;
 
-    kgc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    kgc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
@@ -520,9 +518,8 @@ static void kvm_arm_gic_realize(DeviceState *dev, Error **errp)
     if (!kvm_arm_gic_can_save_restore(s)) {
         error_setg(&s->migration_blocker, "This operating system kernel does "
                                           "not support vGICv2 migration");
-        migrate_add_blocker(s->migration_blocker, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        migrate_add_blocker(s->migration_blocker, errp);
+        if (*errp) {
             error_free(s->migration_blocker);
             return;
         }
diff --git a/hw/intc/arm_gicv3.c b/hw/intc/arm_gicv3.c
index 66eaa97198..0074733d25 100644
--- a/hw/intc/arm_gicv3.c
+++ b/hw/intc/arm_gicv3.c
@@ -366,11 +366,9 @@ static void arm_gic_realize(DeviceState *dev, Error **errp)
     /* Device instance realize function for the GIC sysbus device */
     GICv3State *s = ARM_GICV3(dev);
     ARMGICv3Class *agc = ARM_GICV3_GET_CLASS(s);
-    Error *local_err = NULL;
 
-    agc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    agc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
@@ -380,9 +378,8 @@ static void arm_gic_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    gicv3_init_irqs_and_mmio(s, gicv3_set_irq, gic_ops, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    gicv3_init_irqs_and_mmio(s, gicv3_set_irq, gic_ops, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/intc/arm_gicv3_its_kvm.c b/hw/intc/arm_gicv3_its_kvm.c
index d66f2431ee..e5c3a83613 100644
--- a/hw/intc/arm_gicv3_its_kvm.c
+++ b/hw/intc/arm_gicv3_its_kvm.c
@@ -91,7 +91,6 @@ static void vm_change_state_handler(void *opaque, int running,
 static void kvm_arm_its_realize(DeviceState *dev, Error **errp)
 {
     GICv3ITSState *s = ARM_GICV3_ITS_COMMON(dev);
-    Error *local_err = NULL;
 
     s->dev_fd = kvm_create_device(kvm_state, KVM_DEV_TYPE_ARM_VGIC_ITS, false);
     if (s->dev_fd < 0) {
@@ -113,9 +112,8 @@ static void kvm_arm_its_realize(DeviceState *dev, Error **errp)
         GITS_CTLR)) {
         error_setg(&s->migration_blocker, "This operating system kernel "
                    "does not support vITS migration");
-        migrate_add_blocker(s->migration_blocker, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        migrate_add_blocker(s->migration_blocker, errp);
+        if (*errp) {
             error_free(s->migration_blocker);
             return;
         }
diff --git a/hw/intc/arm_gicv3_kvm.c b/hw/intc/arm_gicv3_kvm.c
index 9c7f4ab871..e25067b659 100644
--- a/hw/intc/arm_gicv3_kvm.c
+++ b/hw/intc/arm_gicv3_kvm.c
@@ -769,14 +769,12 @@ static void kvm_arm_gicv3_realize(DeviceState *dev, Error **errp)
     GICv3State *s = KVM_ARM_GICV3(dev);
     KVMARMGICv3Class *kgc = KVM_ARM_GICV3_GET_CLASS(s);
     bool multiple_redist_region_allowed;
-    Error *local_err = NULL;
     int i;
 
     DPRINTF("kvm_arm_gicv3_realize\n");
 
-    kgc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    kgc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
@@ -786,9 +784,8 @@ static void kvm_arm_gicv3_realize(DeviceState *dev, Error **errp)
         return;
     }
 
-    gicv3_init_irqs_and_mmio(s, kvm_arm_gicv3_set_irq, NULL, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    gicv3_init_irqs_and_mmio(s, kvm_arm_gicv3_set_irq, NULL, errp);
+    if (*errp) {
         return;
     }
 
@@ -863,9 +860,8 @@ static void kvm_arm_gicv3_realize(DeviceState *dev, Error **errp)
                                GICD_CTLR)) {
         error_setg(&s->migration_blocker, "This operating system kernel does "
                                           "not support vGICv3 migration");
-        migrate_add_blocker(s->migration_blocker, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        migrate_add_blocker(s->migration_blocker, errp);
+        if (*errp) {
             error_free(s->migration_blocker);
             return;
         }
diff --git a/hw/intc/armv7m_nvic.c b/hw/intc/armv7m_nvic.c
index 8e93e51e81..2f84185e8b 100644
--- a/hw/intc/armv7m_nvic.c
+++ b/hw/intc/armv7m_nvic.c
@@ -2609,7 +2609,6 @@ static void nvic_systick_trigger(void *opaque, int n, int level)
 static void armv7m_nvic_realize(DeviceState *dev, Error **errp)
 {
     NVICState *s = NVIC(dev);
-    Error *err = NULL;
     int regionlen;
 
     /* The armv7m container object will have set our CPU pointer */
@@ -2631,9 +2630,8 @@ static void armv7m_nvic_realize(DeviceState *dev, Error **errp)
     s->num_prio_bits = arm_feature(&s->cpu->env, ARM_FEATURE_V7) ? 8 : 2;
 
     object_property_set_bool(OBJECT(&s->systick[M_REG_NS]), true,
-                             "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+                             "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     sysbus_connect_irq(SYS_BUS_DEVICE(&s->systick[M_REG_NS]), 0,
@@ -2650,9 +2648,8 @@ static void armv7m_nvic_realize(DeviceState *dev, Error **errp)
                               sizeof(s->systick[M_REG_S]), TYPE_SYSTICK);
 
         object_property_set_bool(OBJECT(&s->systick[M_REG_S]), true,
-                                 "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+                                 "realized", errp);
+        if (*errp != NULL) {
             return;
         }
         sysbus_connect_irq(SYS_BUS_DEVICE(&s->systick[M_REG_S]), 0,
diff --git a/hw/intc/nios2_iic.c b/hw/intc/nios2_iic.c
index 3a5d86c2a4..c24651cafd 100644
--- a/hw/intc/nios2_iic.c
+++ b/hw/intc/nios2_iic.c
@@ -66,12 +66,11 @@ static void altera_iic_init(Object *obj)
 static void altera_iic_realize(DeviceState *dev, Error **errp)
 {
     struct AlteraIIC *pv = ALTERA_IIC(dev);
-    Error *err = NULL;
 
-    pv->cpu = object_property_get_link(OBJECT(dev), "cpu", &err);
+    pv->cpu = object_property_get_link(OBJECT(dev), "cpu", errp);
     if (!pv->cpu) {
         error_setg(errp, "altera,iic: CPU link not found: %s",
-                   error_get_pretty(err));
+                   error_get_pretty(*errp));
         return;
     }
 }
diff --git a/hw/intc/pnv_xive.c b/hw/intc/pnv_xive.c
index ed6e9d71bb..57855e0da3 100644
--- a/hw/intc/pnv_xive.c
+++ b/hw/intc/pnv_xive.c
@@ -1662,12 +1662,10 @@ static void pnv_xive_realize(DeviceState *dev, Error **errp)
     PnvXive *xive = PNV_XIVE(dev);
     XiveSource *xsrc = &xive->ipi_source;
     XiveENDSource *end_xsrc = &xive->end_source;
-    Error *local_err = NULL;
     Object *obj;
 
-    obj = object_property_get_link(OBJECT(dev), "chip", &local_err);
+    obj = object_property_get_link(OBJECT(dev), "chip", errp);
     if (!obj) {
-        error_propagate(errp, local_err);
         error_prepend(errp, "required link 'chip' not found: ");
         return;
     }
@@ -1685,9 +1683,8 @@ static void pnv_xive_realize(DeviceState *dev, Error **errp)
                             &error_fatal);
     object_property_add_const_link(OBJECT(xsrc), "xive", OBJECT(xive),
                                    &error_fatal);
-    object_property_set_bool(OBJECT(xsrc), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(xsrc), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -1695,9 +1692,8 @@ static void pnv_xive_realize(DeviceState *dev, Error **errp)
                             &error_fatal);
     object_property_add_const_link(OBJECT(end_xsrc), "xive", OBJECT(xive),
                                    &error_fatal);
-    object_property_set_bool(OBJECT(end_xsrc), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(end_xsrc), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/intc/realview_gic.c b/hw/intc/realview_gic.c
index 73fe8cd815..55ac9100b0 100644
--- a/hw/intc/realview_gic.c
+++ b/hw/intc/realview_gic.c
@@ -26,7 +26,6 @@ static void realview_gic_realize(DeviceState *dev, Error **errp)
     SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
     RealViewGICState *s = REALVIEW_GIC(dev);
     SysBusDevice *busdev;
-    Error *err = NULL;
     /* The GICs on the RealView boards have a fixed nonconfigurable
      * number of interrupt lines, so we don't need to expose this as
      * a qdev property.
@@ -34,9 +33,8 @@ static void realview_gic_realize(DeviceState *dev, Error **errp)
     int numirq = 96;
 
     qdev_prop_set_uint32(DEVICE(&s->gic), "num-irq", numirq);
-    object_property_set_bool(OBJECT(&s->gic), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gic), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
     busdev = SYS_BUS_DEVICE(&s->gic);
diff --git a/hw/intc/s390_flic_kvm.c b/hw/intc/s390_flic_kvm.c
index 819aa5e198..57fb678823 100644
--- a/hw/intc/s390_flic_kvm.c
+++ b/hw/intc/s390_flic_kvm.c
@@ -582,15 +582,14 @@ static void kvm_s390_flic_realize(DeviceState *dev, Error **errp)
     struct kvm_create_device cd = {0};
     struct kvm_device_attr test_attr = {0};
     int ret;
-    Error *errp_local = NULL;
 
-    KVM_S390_FLIC_GET_CLASS(dev)->parent_realize(dev, &errp_local);
-    if (errp_local) {
+    KVM_S390_FLIC_GET_CLASS(dev)->parent_realize(dev, errp);
+    if (*errp) {
         goto fail;
     }
     flic_state->fd = -1;
     if (!kvm_check_extension(kvm_state, KVM_CAP_DEVICE_CTRL)) {
-        error_setg_errno(&errp_local, errno, "KVM is missing capability"
+        error_setg_errno(errp, errno, "KVM is missing capability"
                          " KVM_CAP_DEVICE_CTRL");
         trace_flic_no_device_api(errno);
         goto fail;
@@ -599,7 +598,7 @@ static void kvm_s390_flic_realize(DeviceState *dev, Error **errp)
     cd.type = KVM_DEV_TYPE_FLIC;
     ret = kvm_vm_ioctl(kvm_state, KVM_CREATE_DEVICE, &cd);
     if (ret < 0) {
-        error_setg_errno(&errp_local, errno, "Creating the KVM device failed");
+        error_setg_errno(errp, errno, "Creating the KVM device failed");
         trace_flic_create_device(errno);
         goto fail;
     }
@@ -611,7 +610,6 @@ static void kvm_s390_flic_realize(DeviceState *dev, Error **errp)
                                             KVM_HAS_DEVICE_ATTR, test_attr);
     return;
 fail:
-    error_propagate(errp, errp_local);
 }
 
 static void kvm_s390_flic_reset(DeviceState *dev)
diff --git a/hw/intc/spapr_xive.c b/hw/intc/spapr_xive.c
index c1c97192a7..5159f35df7 100644
--- a/hw/intc/spapr_xive.c
+++ b/hw/intc/spapr_xive.c
@@ -276,7 +276,6 @@ static void spapr_xive_realize(DeviceState *dev, Error **errp)
     SpaprXive *xive = SPAPR_XIVE(dev);
     XiveSource *xsrc = &xive->source;
     XiveENDSource *end_xsrc = &xive->end_source;
-    Error *local_err = NULL;
 
     if (!xive->nr_irqs) {
         error_setg(errp, "Number of interrupt needs to be greater 0");
@@ -295,9 +294,8 @@ static void spapr_xive_realize(DeviceState *dev, Error **errp)
                             &error_fatal);
     object_property_add_const_link(OBJECT(xsrc), "xive", OBJECT(xive),
                                    &error_fatal);
-    object_property_set_bool(OBJECT(xsrc), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(xsrc), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_init_mmio(SYS_BUS_DEVICE(xive), &xsrc->esb_mmio);
@@ -309,9 +307,8 @@ static void spapr_xive_realize(DeviceState *dev, Error **errp)
                             &error_fatal);
     object_property_add_const_link(OBJECT(end_xsrc), "xive", OBJECT(xive),
                                    &error_fatal);
-    object_property_set_bool(OBJECT(end_xsrc), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(end_xsrc), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_init_mmio(SYS_BUS_DEVICE(xive), &end_xsrc->esb_mmio);
diff --git a/hw/intc/spapr_xive_kvm.c b/hw/intc/spapr_xive_kvm.c
index 17af4d19f5..925f5f7b37 100644
--- a/hw/intc/spapr_xive_kvm.c
+++ b/hw/intc/spapr_xive_kvm.c
@@ -193,7 +193,6 @@ void kvmppc_xive_set_source_config(SpaprXive *xive, uint32_t lisn, XiveEAS *eas,
     bool masked;
     uint32_t eisn;
     uint64_t kvm_src;
-    Error *local_err = NULL;
 
     assert(xive_eas_is_valid(eas));
 
@@ -214,9 +213,8 @@ void kvmppc_xive_set_source_config(SpaprXive *xive, uint32_t lisn, XiveEAS *eas,
         KVM_XIVE_SOURCE_EISN_MASK;
 
     kvm_device_access(xive->fd, KVM_DEV_XIVE_GRP_SOURCE_CONFIG, lisn,
-                      &kvm_src, true, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                      &kvm_src, true, errp);
+    if (*errp) {
         return;
     }
 }
@@ -258,11 +256,8 @@ static void kvmppc_xive_source_reset(XiveSource *xsrc, Error **errp)
     int i;
 
     for (i = 0; i < xsrc->nr_irqs; i++) {
-        Error *local_err = NULL;
-
-        kvmppc_xive_source_reset_one(xsrc, i, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        kvmppc_xive_source_reset_one(xsrc, i, errp);
+        if (*errp) {
             return;
         }
     }
@@ -381,7 +376,6 @@ void kvmppc_xive_get_queue_config(SpaprXive *xive, uint8_t end_blk,
     uint64_t kvm_eq_idx;
     uint8_t priority;
     uint32_t server;
-    Error *local_err = NULL;
 
     assert(xive_end_is_valid(end));
 
@@ -394,9 +388,8 @@ void kvmppc_xive_get_queue_config(SpaprXive *xive, uint8_t end_blk,
         KVM_XIVE_EQ_SERVER_MASK;
 
     kvm_device_access(xive->fd, KVM_DEV_XIVE_GRP_EQ_CONFIG, kvm_eq_idx,
-                      &kvm_eq, false, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                      &kvm_eq, false, errp);
+    if (*errp) {
         return;
     }
 
@@ -417,7 +410,6 @@ void kvmppc_xive_set_queue_config(SpaprXive *xive, uint8_t end_blk,
     uint64_t kvm_eq_idx;
     uint8_t priority;
     uint32_t server;
-    Error *local_err = NULL;
 
     /*
      * Build the KVM state from the local END structure.
@@ -456,9 +448,8 @@ void kvmppc_xive_set_queue_config(SpaprXive *xive, uint8_t end_blk,
         KVM_XIVE_EQ_SERVER_MASK;
 
     kvm_device_access(xive->fd, KVM_DEV_XIVE_GRP_EQ_CONFIG, kvm_eq_idx,
-                      &kvm_eq, true, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                      &kvm_eq, true, errp);
+    if (*errp) {
         return;
     }
 }
@@ -471,7 +462,6 @@ void kvmppc_xive_reset(SpaprXive *xive, Error **errp)
 
 static void kvmppc_xive_get_queues(SpaprXive *xive, Error **errp)
 {
-    Error *local_err = NULL;
     int i;
 
     for (i = 0; i < xive->nr_ends; i++) {
@@ -480,9 +470,8 @@ static void kvmppc_xive_get_queues(SpaprXive *xive, Error **errp)
         }
 
         kvmppc_xive_get_queue_config(xive, SPAPR_XIVE_BLOCK_ID, i,
-                                     &xive->endt[i], &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                                     &xive->endt[i], errp);
+        if (*errp) {
             return;
         }
     }
@@ -709,7 +698,6 @@ static void *kvmppc_xive_mmap(SpaprXive *xive, int pgoff, size_t len,
 void kvmppc_xive_connect(SpaprXive *xive, Error **errp)
 {
     XiveSource *xsrc = &xive->source;
-    Error *local_err = NULL;
     size_t esb_len = (1ull << xsrc->esb_shift) * xsrc->nr_irqs;
     size_t tima_len = 4ull << TM_SHIFT;
     CPUState *cs;
@@ -738,8 +726,8 @@ void kvmppc_xive_connect(SpaprXive *xive, Error **errp)
      * 1. Source ESB pages - KVM mapping
      */
     xsrc->esb_mmap = kvmppc_xive_mmap(xive, KVM_XIVE_ESB_PAGE_OFFSET, esb_len,
-                                      &local_err);
-    if (local_err) {
+                                      errp);
+    if (*errp) {
         goto fail;
     }
 
@@ -756,8 +744,8 @@ void kvmppc_xive_connect(SpaprXive *xive, Error **errp)
      * 3. TIMA pages - KVM mapping
      */
     xive->tm_mmap = kvmppc_xive_mmap(xive, KVM_XIVE_TIMA_PAGE_OFFSET, tima_len,
-                                     &local_err);
-    if (local_err) {
+                                     errp);
+    if (*errp) {
         goto fail;
     }
     memory_region_init_ram_device_ptr(&xive->tm_mmio_kvm, OBJECT(xive),
@@ -772,15 +760,15 @@ void kvmppc_xive_connect(SpaprXive *xive, Error **errp)
     CPU_FOREACH(cs) {
         PowerPCCPU *cpu = POWERPC_CPU(cs);
 
-        kvmppc_xive_cpu_connect(spapr_cpu_state(cpu)->tctx, &local_err);
-        if (local_err) {
+        kvmppc_xive_cpu_connect(spapr_cpu_state(cpu)->tctx, errp);
+        if (*errp) {
             goto fail;
         }
     }
 
     /* Update the KVM sources */
-    kvmppc_xive_source_reset(xsrc, &local_err);
-    if (local_err) {
+    kvmppc_xive_source_reset(xsrc, errp);
+    if (*errp) {
         goto fail;
     }
 
@@ -790,7 +778,6 @@ void kvmppc_xive_connect(SpaprXive *xive, Error **errp)
     return;
 
 fail:
-    error_propagate(errp, local_err);
     kvmppc_xive_disconnect(xive, NULL);
 }
 
diff --git a/hw/intc/xics.c b/hw/intc/xics.c
index b2fca2975c..60523f0241 100644
--- a/hw/intc/xics.c
+++ b/hw/intc/xics.c
@@ -325,11 +325,10 @@ static void icp_realize(DeviceState *dev, Error **errp)
     PowerPCCPU *cpu;
     CPUPPCState *env;
     Object *obj;
-    Error *err = NULL;
 
-    obj = object_property_get_link(OBJECT(dev), ICP_PROP_XICS, &err);
+    obj = object_property_get_link(OBJECT(dev), ICP_PROP_XICS, errp);
     if (!obj) {
-        error_propagate_prepend(errp, err,
+        error_propagate_prepend(errp, *errp,
                                 "required link '" ICP_PROP_XICS
                                 "' not found: ");
         return;
@@ -337,9 +336,9 @@ static void icp_realize(DeviceState *dev, Error **errp)
 
     icp->xics = XICS_FABRIC(obj);
 
-    obj = object_property_get_link(OBJECT(dev), ICP_PROP_CPU, &err);
+    obj = object_property_get_link(OBJECT(dev), ICP_PROP_CPU, errp);
     if (!obj) {
-        error_propagate_prepend(errp, err,
+        error_propagate_prepend(errp, *errp,
                                 "required link '" ICP_PROP_CPU
                                 "' not found: ");
         return;
@@ -368,9 +367,8 @@ static void icp_realize(DeviceState *dev, Error **errp)
 
     /* Connect the presenter to the VCPU (required for CPU hotplug) */
     if (kvm_irqchip_in_kernel()) {
-        icp_kvm_realize(dev, &err);
-        if (err) {
-            error_propagate(errp, err);
+        icp_kvm_realize(dev, errp);
+        if (*errp) {
             return;
         }
     }
@@ -405,7 +403,6 @@ static const TypeInfo icp_info = {
 
 Object *icp_create(Object *cpu, const char *type, XICSFabric *xi, Error **errp)
 {
-    Error *local_err = NULL;
     Object *obj;
 
     obj = object_new(type);
@@ -414,10 +411,9 @@ Object *icp_create(Object *cpu, const char *type, XICSFabric *xi, Error **errp)
     object_property_add_const_link(obj, ICP_PROP_XICS, OBJECT(xi),
                                    &error_abort);
     object_property_add_const_link(obj, ICP_PROP_CPU, cpu, &error_abort);
-    object_property_set_bool(obj, true, "realized", &local_err);
-    if (local_err) {
+    object_property_set_bool(obj, true, "realized", errp);
+    if (*errp) {
         object_unparent(obj);
-        error_propagate(errp, local_err);
         obj = NULL;
     }
 
@@ -597,11 +593,9 @@ static void ics_simple_realize(DeviceState *dev, Error **errp)
 {
     ICSState *ics = ICS_SIMPLE(dev);
     ICSStateClass *icsc = ICS_BASE_GET_CLASS(ics);
-    Error *local_err = NULL;
 
-    icsc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    icsc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
@@ -659,11 +653,10 @@ static void ics_base_realize(DeviceState *dev, Error **errp)
 {
     ICSState *ics = ICS_BASE(dev);
     Object *obj;
-    Error *err = NULL;
 
-    obj = object_property_get_link(OBJECT(dev), ICS_PROP_XICS, &err);
+    obj = object_property_get_link(OBJECT(dev), ICS_PROP_XICS, errp);
     if (!obj) {
-        error_propagate_prepend(errp, err,
+        error_propagate_prepend(errp, *errp,
                                 "required link '" ICS_PROP_XICS
                                 "' not found: ");
         return;
diff --git a/hw/intc/xics_kvm.c b/hw/intc/xics_kvm.c
index a4d2e876cc..a51f2fe4e8 100644
--- a/hw/intc/xics_kvm.c
+++ b/hw/intc/xics_kvm.c
@@ -298,12 +298,10 @@ int ics_set_kvm_state(ICSState *ics, Error **errp)
     }
 
     for (i = 0; i < ics->nr_irqs; i++) {
-        Error *local_err = NULL;
         int ret;
 
-        ret = ics_set_kvm_state_one(ics, i, &local_err);
+        ret = ics_set_kvm_state_one(ics, i, errp);
         if (ret < 0) {
-            error_propagate(errp, local_err);
             return ret;
         }
     }
@@ -338,7 +336,6 @@ int xics_kvm_connect(SpaprMachineState *spapr, Error **errp)
 {
     int rc;
     CPUState *cs;
-    Error *local_err = NULL;
 
     /*
      * The KVM XICS device already in use. This is the case when
@@ -356,28 +353,28 @@ int xics_kvm_connect(SpaprMachineState *spapr, Error **errp)
 
     rc = kvmppc_define_rtas_kernel_token(RTAS_IBM_SET_XIVE, "ibm,set-xive");
     if (rc < 0) {
-        error_setg_errno(&local_err, -rc,
+        error_setg_errno(errp, -rc,
                          "kvmppc_define_rtas_kernel_token: ibm,set-xive");
         goto fail;
     }
 
     rc = kvmppc_define_rtas_kernel_token(RTAS_IBM_GET_XIVE, "ibm,get-xive");
     if (rc < 0) {
-        error_setg_errno(&local_err, -rc,
+        error_setg_errno(errp, -rc,
                          "kvmppc_define_rtas_kernel_token: ibm,get-xive");
         goto fail;
     }
 
     rc = kvmppc_define_rtas_kernel_token(RTAS_IBM_INT_ON, "ibm,int-on");
     if (rc < 0) {
-        error_setg_errno(&local_err, -rc,
+        error_setg_errno(errp, -rc,
                          "kvmppc_define_rtas_kernel_token: ibm,int-on");
         goto fail;
     }
 
     rc = kvmppc_define_rtas_kernel_token(RTAS_IBM_INT_OFF, "ibm,int-off");
     if (rc < 0) {
-        error_setg_errno(&local_err, -rc,
+        error_setg_errno(errp, -rc,
                          "kvmppc_define_rtas_kernel_token: ibm,int-off");
         goto fail;
     }
@@ -385,7 +382,7 @@ int xics_kvm_connect(SpaprMachineState *spapr, Error **errp)
     /* Create the KVM XICS device */
     rc = kvm_create_device(kvm_state, KVM_DEV_TYPE_XICS, false);
     if (rc < 0) {
-        error_setg_errno(&local_err, -rc, "Error on KVM_CREATE_DEVICE for XICS");
+        error_setg_errno(errp, -rc, "Error on KVM_CREATE_DEVICE for XICS");
         goto fail;
     }
 
@@ -398,23 +395,23 @@ int xics_kvm_connect(SpaprMachineState *spapr, Error **errp)
     CPU_FOREACH(cs) {
         PowerPCCPU *cpu = POWERPC_CPU(cs);
 
-        icp_kvm_realize(DEVICE(spapr_cpu_state(cpu)->icp), &local_err);
-        if (local_err) {
+        icp_kvm_realize(DEVICE(spapr_cpu_state(cpu)->icp), errp);
+        if (*errp) {
             goto fail;
         }
     }
 
     /* Update the KVM sources */
-    ics_set_kvm_state(spapr->ics, &local_err);
-    if (local_err) {
+    ics_set_kvm_state(spapr->ics, errp);
+    if (*errp) {
         goto fail;
     }
 
     /* Connect the presenters to the initial VCPUs of the machine */
     CPU_FOREACH(cs) {
         PowerPCCPU *cpu = POWERPC_CPU(cs);
-        icp_set_kvm_state(spapr_cpu_state(cpu)->icp, &local_err);
-        if (local_err) {
+        icp_set_kvm_state(spapr_cpu_state(cpu)->icp, errp);
+        if (*errp) {
             goto fail;
         }
     }
@@ -422,7 +419,6 @@ int xics_kvm_connect(SpaprMachineState *spapr, Error **errp)
     return 0;
 
 fail:
-    error_propagate(errp, local_err);
     xics_kvm_disconnect(spapr, NULL);
     return -1;
 }
diff --git a/hw/intc/xics_pnv.c b/hw/intc/xics_pnv.c
index 35f3811264..5028e5897d 100644
--- a/hw/intc/xics_pnv.c
+++ b/hw/intc/xics_pnv.c
@@ -164,11 +164,9 @@ static void pnv_icp_realize(DeviceState *dev, Error **errp)
     ICPState *icp = ICP(dev);
     PnvICPState *pnv_icp = PNV_ICP(icp);
     ICPStateClass *icpc = ICP_GET_CLASS(icp);
-    Error *local_err = NULL;
 
-    icpc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    icpc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/intc/xive.c b/hw/intc/xive.c
index b7417210d8..f161e1d650 100644
--- a/hw/intc/xive.c
+++ b/hw/intc/xive.c
@@ -574,11 +574,9 @@ static void xive_tctx_realize(DeviceState *dev, Error **errp)
     PowerPCCPU *cpu;
     CPUPPCState *env;
     Object *obj;
-    Error *local_err = NULL;
 
-    obj = object_property_get_link(OBJECT(dev), "cpu", &local_err);
+    obj = object_property_get_link(OBJECT(dev), "cpu", errp);
     if (!obj) {
-        error_propagate(errp, local_err);
         error_prepend(errp, "required link 'cpu' not found: ");
         return;
     }
@@ -601,9 +599,8 @@ static void xive_tctx_realize(DeviceState *dev, Error **errp)
 
     /* Connect the presenter to the VCPU (required for CPU hotplug) */
     if (kvm_irqchip_in_kernel()) {
-        kvmppc_xive_cpu_connect(tctx, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        kvmppc_xive_cpu_connect(tctx, errp);
+        if (*errp) {
             return;
         }
     }
@@ -681,15 +678,14 @@ static const TypeInfo xive_tctx_info = {
 
 Object *xive_tctx_create(Object *cpu, XiveRouter *xrtr, Error **errp)
 {
-    Error *local_err = NULL;
     Object *obj;
 
     obj = object_new(TYPE_XIVE_TCTX);
     object_property_add_child(cpu, TYPE_XIVE_TCTX, obj, &error_abort);
     object_unref(obj);
     object_property_add_const_link(obj, "cpu", cpu, &error_abort);
-    object_property_set_bool(obj, true, "realized", &local_err);
-    if (local_err) {
+    object_property_set_bool(obj, true, "realized", errp);
+    if (*errp) {
         goto error;
     }
 
@@ -697,7 +693,6 @@ Object *xive_tctx_create(Object *cpu, XiveRouter *xrtr, Error **errp)
 
 error:
     object_unparent(obj);
-    error_propagate(errp, local_err);
     return NULL;
 }
 
@@ -1052,11 +1047,9 @@ static void xive_source_realize(DeviceState *dev, Error **errp)
 {
     XiveSource *xsrc = XIVE_SOURCE(dev);
     Object *obj;
-    Error *local_err = NULL;
 
-    obj = object_property_get_link(OBJECT(dev), "xive", &local_err);
+    obj = object_property_get_link(OBJECT(dev), "xive", errp);
     if (!obj) {
-        error_propagate(errp, local_err);
         error_prepend(errp, "required link 'xive' not found: ");
         return;
     }
@@ -1800,11 +1793,9 @@ static void xive_end_source_realize(DeviceState *dev, Error **errp)
 {
     XiveENDSource *xsrc = XIVE_END_SOURCE(dev);
     Object *obj;
-    Error *local_err = NULL;
 
-    obj = object_property_get_link(OBJECT(dev), "xive", &local_err);
+    obj = object_property_get_link(OBJECT(dev), "xive", errp);
     if (!obj) {
-        error_propagate(errp, local_err);
         error_prepend(errp, "required link 'xive' not found: ");
         return;
     }
diff --git a/hw/ipack/ipack.c b/hw/ipack/ipack.c
index 30e16696c0..dc66fe62d8 100644
--- a/hw/ipack/ipack.c
+++ b/hw/ipack/ipack.c
@@ -64,11 +64,9 @@ static void ipack_device_unrealize(DeviceState *dev, Error **errp)
 {
     IPackDevice *idev = IPACK_DEVICE(dev);
     IPackDeviceClass *k = IPACK_DEVICE_GET_CLASS(dev);
-    Error *err = NULL;
 
     if (k->unrealize) {
-        k->unrealize(dev, &err);
-        error_propagate(errp, err);
+        k->unrealize(dev, errp);
         return;
     }
 
diff --git a/hw/isa/pc87312.c b/hw/isa/pc87312.c
index b9bd57471e..acef6fd670 100644
--- a/hw/isa/pc87312.c
+++ b/hw/isa/pc87312.c
@@ -293,16 +293,14 @@ static void pc87312_realize(DeviceState *dev, Error **errp)
 {
     PC87312State *s;
     ISADevice *isa;
-    Error *local_err = NULL;
 
     s = PC87312(dev);
     isa = ISA_DEVICE(dev);
     isa_register_ioport(isa, &s->io, s->iobase);
     pc87312_hard_reset(s);
 
-    ISA_SUPERIO_GET_CLASS(dev)->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ISA_SUPERIO_GET_CLASS(dev)->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 }
diff --git a/hw/mem/memory-device.c b/hw/mem/memory-device.c
index 53953fdc3a..ed9c421150 100644
--- a/hw/mem/memory-device.c
+++ b/hw/mem/memory-device.c
@@ -254,29 +254,26 @@ void memory_device_pre_plug(MemoryDeviceState *md, MachineState *ms,
                             const uint64_t *legacy_align, Error **errp)
 {
     const MemoryDeviceClass *mdc = MEMORY_DEVICE_GET_CLASS(md);
-    Error *local_err = NULL;
     uint64_t addr, align;
     MemoryRegion *mr;
 
-    mr = mdc->get_memory_region(md, &local_err);
-    if (local_err) {
-        goto out;
+    mr = mdc->get_memory_region(md, errp);
+    if (*errp) {
+        return;
     }
 
     align = legacy_align ? *legacy_align : memory_region_get_alignment(mr);
     addr = mdc->get_addr(md);
     addr = memory_device_get_free_addr(ms, !addr ? NULL : &addr, align,
-                                       memory_region_size(mr), &local_err);
-    if (local_err) {
-        goto out;
+                                       memory_region_size(mr), errp);
+    if (*errp) {
+        return;
     }
-    mdc->set_addr(md, addr, &local_err);
-    if (!local_err) {
+    mdc->set_addr(md, addr, errp);
+    if (!*errp) {
         trace_memory_device_pre_plug(DEVICE(md)->id ? DEVICE(md)->id : "",
                                      addr);
     }
-out:
-    error_propagate(errp, local_err);
 }
 
 void memory_device_plug(MemoryDeviceState *md, MachineState *ms)
diff --git a/hw/mem/nvdimm.c b/hw/mem/nvdimm.c
index 375f9a588a..5b0a969d83 100644
--- a/hw/mem/nvdimm.c
+++ b/hw/mem/nvdimm.c
@@ -45,28 +45,25 @@ static void nvdimm_set_label_size(Object *obj, Visitor *v, const char *name,
                                   void *opaque, Error **errp)
 {
     NVDIMMDevice *nvdimm = NVDIMM(obj);
-    Error *local_err = NULL;
     uint64_t value;
 
     if (nvdimm->nvdimm_mr) {
-        error_setg(&local_err, "cannot change property value");
-        goto out;
+        error_setg(errp, "cannot change property value");
+        return;
     }
 
-    visit_type_size(v, name, &value, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_size(v, name, &value, errp);
+    if (*errp) {
+        return;
     }
     if (value < MIN_NAMESPACE_LABEL_SIZE) {
-        error_setg(&local_err, "Property '%s.%s' (0x%" PRIx64 ") is required"
+        error_setg(errp, "Property '%s.%s' (0x%" PRIx64 ") is required"
                    " at least 0x%lx", object_get_typename(obj),
                    name, value, MIN_NAMESPACE_LABEL_SIZE);
-        goto out;
+        return;
     }
 
     nvdimm->label_size = value;
-out:
-    error_propagate(errp, local_err);
 }
 
 static void nvdimm_init(Object *obj)
@@ -127,12 +124,10 @@ static MemoryRegion *nvdimm_md_get_memory_region(MemoryDeviceState *md,
                                                  Error **errp)
 {
     NVDIMMDevice *nvdimm = NVDIMM(md);
-    Error *local_err = NULL;
 
     if (!nvdimm->nvdimm_mr) {
-        nvdimm_prepare_memory_region(nvdimm, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        nvdimm_prepare_memory_region(nvdimm, errp);
+        if (*errp) {
             return NULL;
         }
     }
diff --git a/hw/mem/pc-dimm.c b/hw/mem/pc-dimm.c
index 99e2faf01b..3f0d696cf8 100644
--- a/hw/mem/pc-dimm.c
+++ b/hw/mem/pc-dimm.c
@@ -37,31 +37,28 @@ static int pc_dimm_get_free_slot(const int *hint, int max_slots, Error **errp);
 void pc_dimm_pre_plug(PCDIMMDevice *dimm, MachineState *machine,
                       const uint64_t *legacy_align, Error **errp)
 {
-    Error *local_err = NULL;
     int slot;
 
     slot = object_property_get_int(OBJECT(dimm), PC_DIMM_SLOT_PROP,
                                    &error_abort);
     if ((slot < 0 || slot >= machine->ram_slots) &&
          slot != PC_DIMM_UNASSIGNED_SLOT) {
-        error_setg(&local_err, "invalid slot number, valid range is [0-%"
+        error_setg(errp, "invalid slot number, valid range is [0-%"
                    PRIu64 "]", machine->ram_slots - 1);
-        goto out;
+        return;
     }
 
     slot = pc_dimm_get_free_slot(slot == PC_DIMM_UNASSIGNED_SLOT ? NULL : &slot,
-                                 machine->ram_slots, &local_err);
-    if (local_err) {
-        goto out;
+                                 machine->ram_slots, errp);
+    if (*errp) {
+        return;
     }
     object_property_set_int(OBJECT(dimm), slot, PC_DIMM_SLOT_PROP,
                             &error_abort);
     trace_mhp_pc_dimm_assigned_slot(slot);
 
     memory_device_pre_plug(MEMORY_DEVICE(dimm), machine, legacy_align,
-                           &local_err);
-out:
-    error_propagate(errp, local_err);
+                           errp);
 }
 
 void pc_dimm_plug(PCDIMMDevice *dimm, MachineState *machine, Error **errp)
@@ -150,12 +147,10 @@ static Property pc_dimm_properties[] = {
 static void pc_dimm_get_size(Object *obj, Visitor *v, const char *name,
                              void *opaque, Error **errp)
 {
-    Error *local_err = NULL;
     uint64_t value;
 
-    value = memory_device_get_region_size(MEMORY_DEVICE(obj), &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    value = memory_device_get_region_size(MEMORY_DEVICE(obj), errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/microblaze/xlnx-zynqmp-pmu.c b/hw/microblaze/xlnx-zynqmp-pmu.c
index 028f31894d..f8edb32c8c 100644
--- a/hw/microblaze/xlnx-zynqmp-pmu.c
+++ b/hw/microblaze/xlnx-zynqmp-pmu.c
@@ -79,7 +79,6 @@ static void xlnx_zynqmp_pmu_soc_init(Object *obj)
 static void xlnx_zynqmp_pmu_soc_realize(DeviceState *dev, Error **errp)
 {
     XlnxZynqMPPMUSoCState *s = XLNX_ZYNQMP_PMU_SOC(dev);
-    Error *err = NULL;
 
     object_property_set_uint(OBJECT(&s->cpu), XLNX_ZYNQMP_PMU_ROM_ADDR,
                              "base-vectors", &error_abort);
@@ -99,9 +98,8 @@ static void xlnx_zynqmp_pmu_soc_realize(DeviceState *dev, Error **errp)
     object_property_set_str(OBJECT(&s->cpu), "8.40.b", "version",
                             &error_abort);
     object_property_set_uint(OBJECT(&s->cpu), 0, "pvr", &error_abort);
-    object_property_set_bool(OBJECT(&s->cpu), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->cpu), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -111,9 +109,8 @@ static void xlnx_zynqmp_pmu_soc_realize(DeviceState *dev, Error **errp)
                              &error_abort);
     object_property_set_uint(OBJECT(&s->intc), 0xffff, "intc-positive",
                              &error_abort);
-    object_property_set_bool(OBJECT(&s->intc), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->intc), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->intc), 0, XLNX_ZYNQMP_PMU_INTC_ADDR);
diff --git a/hw/mips/cps.c b/hw/mips/cps.c
index 1660f86908..ced373d852 100644
--- a/hw/mips/cps.c
+++ b/hw/mips/cps.c
@@ -71,7 +71,6 @@ static void mips_cps_realize(DeviceState *dev, Error **errp)
     CPUMIPSState *env;
     MIPSCPU *cpu;
     int i;
-    Error *err = NULL;
     target_ulong gcr_base;
     bool itu_present = false;
     bool saar_present = false;
@@ -101,16 +100,15 @@ static void mips_cps_realize(DeviceState *dev, Error **errp)
     if (itu_present) {
         sysbus_init_child_obj(OBJECT(dev), "itu", &s->itu, sizeof(s->itu),
                               TYPE_MIPS_ITU);
-        object_property_set_int(OBJECT(&s->itu), 16, "num-fifo", &err);
-        object_property_set_int(OBJECT(&s->itu), 16, "num-semaphores", &err);
+        object_property_set_int(OBJECT(&s->itu), 16, "num-fifo", errp);
+        object_property_set_int(OBJECT(&s->itu), 16, "num-semaphores", errp);
         object_property_set_bool(OBJECT(&s->itu), saar_present, "saar-present",
-                                 &err);
+                                 errp);
         if (saar_present) {
             qdev_prop_set_ptr(DEVICE(&s->itu), "saar", (void *)&env->CP0_SAAR);
         }
-        object_property_set_bool(OBJECT(&s->itu), true, "realized", &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->itu), true, "realized", errp);
+        if (*errp != NULL) {
             return;
         }
 
@@ -121,11 +119,10 @@ static void mips_cps_realize(DeviceState *dev, Error **errp)
     /* Cluster Power Controller */
     sysbus_init_child_obj(OBJECT(dev), "cpc", &s->cpc, sizeof(s->cpc),
                           TYPE_MIPS_CPC);
-    object_property_set_int(OBJECT(&s->cpc), s->num_vp, "num-vp", &err);
-    object_property_set_int(OBJECT(&s->cpc), 1, "vp-start-running", &err);
-    object_property_set_bool(OBJECT(&s->cpc), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_int(OBJECT(&s->cpc), s->num_vp, "num-vp", errp);
+    object_property_set_int(OBJECT(&s->cpc), 1, "vp-start-running", errp);
+    object_property_set_bool(OBJECT(&s->cpc), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
@@ -135,11 +132,10 @@ static void mips_cps_realize(DeviceState *dev, Error **errp)
     /* Global Interrupt Controller */
     sysbus_init_child_obj(OBJECT(dev), "gic", &s->gic, sizeof(s->gic),
                           TYPE_MIPS_GIC);
-    object_property_set_int(OBJECT(&s->gic), s->num_vp, "num-vp", &err);
-    object_property_set_int(OBJECT(&s->gic), 128, "num-irq", &err);
-    object_property_set_bool(OBJECT(&s->gic), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_int(OBJECT(&s->gic), s->num_vp, "num-vp", errp);
+    object_property_set_int(OBJECT(&s->gic), 128, "num-irq", errp);
+    object_property_set_bool(OBJECT(&s->gic), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
@@ -151,14 +147,13 @@ static void mips_cps_realize(DeviceState *dev, Error **errp)
 
     sysbus_init_child_obj(OBJECT(dev), "gcr", &s->gcr, sizeof(s->gcr),
                           TYPE_MIPS_GCR);
-    object_property_set_int(OBJECT(&s->gcr), s->num_vp, "num-vp", &err);
-    object_property_set_int(OBJECT(&s->gcr), 0x800, "gcr-rev", &err);
-    object_property_set_int(OBJECT(&s->gcr), gcr_base, "gcr-base", &err);
-    object_property_set_link(OBJECT(&s->gcr), OBJECT(&s->gic.mr), "gic", &err);
-    object_property_set_link(OBJECT(&s->gcr), OBJECT(&s->cpc.mr), "cpc", &err);
-    object_property_set_bool(OBJECT(&s->gcr), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_int(OBJECT(&s->gcr), s->num_vp, "num-vp", errp);
+    object_property_set_int(OBJECT(&s->gcr), 0x800, "gcr-rev", errp);
+    object_property_set_int(OBJECT(&s->gcr), gcr_base, "gcr-base", errp);
+    object_property_set_link(OBJECT(&s->gcr), OBJECT(&s->gic.mr), "gic", errp);
+    object_property_set_link(OBJECT(&s->gcr), OBJECT(&s->cpc.mr), "cpc", errp);
+    object_property_set_bool(OBJECT(&s->gcr), true, "realized", errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/hw/misc/arm11scu.c b/hw/misc/arm11scu.c
index 3023284d6f..befc85f321 100644
--- a/hw/misc/arm11scu.c
+++ b/hw/misc/arm11scu.c
@@ -63,6 +63,7 @@ static const MemoryRegionOps mpcore_scu_ops = {
 
 static void arm11_scu_realize(DeviceState *dev, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static void arm11_scu_init(Object *obj)
diff --git a/hw/misc/bcm2835_mbox.c b/hw/misc/bcm2835_mbox.c
index 79bad11631..ab59d874cb 100644
--- a/hw/misc/bcm2835_mbox.c
+++ b/hw/misc/bcm2835_mbox.c
@@ -300,12 +300,11 @@ static void bcm2835_mbox_realize(DeviceState *dev, Error **errp)
 {
     BCM2835MboxState *s = BCM2835_MBOX(dev);
     Object *obj;
-    Error *err = NULL;
 
-    obj = object_property_get_link(OBJECT(dev), "mbox-mr", &err);
+    obj = object_property_get_link(OBJECT(dev), "mbox-mr", errp);
     if (obj == NULL) {
         error_setg(errp, "%s: required mbox-mr link not found: %s",
-                   __func__, error_get_pretty(err));
+                   __func__, error_get_pretty(*errp));
         return;
     }
 
diff --git a/hw/misc/bcm2835_property.c b/hw/misc/bcm2835_property.c
index d86d510572..eebda73a94 100644
--- a/hw/misc/bcm2835_property.c
+++ b/hw/misc/bcm2835_property.c
@@ -384,21 +384,20 @@ static void bcm2835_property_realize(DeviceState *dev, Error **errp)
 {
     BCM2835PropertyState *s = BCM2835_PROPERTY(dev);
     Object *obj;
-    Error *err = NULL;
 
-    obj = object_property_get_link(OBJECT(dev), "fb", &err);
+    obj = object_property_get_link(OBJECT(dev), "fb", errp);
     if (obj == NULL) {
         error_setg(errp, "%s: required fb link not found: %s",
-                   __func__, error_get_pretty(err));
+                   __func__, error_get_pretty(*errp));
         return;
     }
 
     s->fbdev = BCM2835_FB(obj);
 
-    obj = object_property_get_link(OBJECT(dev), "dma-mr", &err);
+    obj = object_property_get_link(OBJECT(dev), "dma-mr", errp);
     if (obj == NULL) {
         error_setg(errp, "%s: required dma-mr link not found: %s",
-                   __func__, error_get_pretty(err));
+                   __func__, error_get_pretty(*errp));
         return;
     }
 
diff --git a/hw/misc/ivshmem.c b/hw/misc/ivshmem.c
index 5e3b05eae0..136a8874ed 100644
--- a/hw/misc/ivshmem.c
+++ b/hw/misc/ivshmem.c
@@ -478,7 +478,6 @@ static void setup_interrupt(IVShmemState *s, int vector, Error **errp)
     bool with_irqfd = kvm_msi_via_irqfd_enabled() &&
         ivshmem_has_feature(s, IVSHMEM_MSI);
     PCIDevice *pdev = PCI_DEVICE(s);
-    Error *err = NULL;
 
     IVSHMEM_DPRINTF("setting up interrupt for vector: %d\n", vector);
 
@@ -487,9 +486,8 @@ static void setup_interrupt(IVShmemState *s, int vector, Error **errp)
         watch_vector_notifier(s, n, vector);
     } else if (msix_enabled(pdev)) {
         IVSHMEM_DPRINTF("with irqfd\n");
-        ivshmem_add_kvm_msi_virq(s, vector, &err);
-        if (err) {
-            error_propagate(errp, err);
+        ivshmem_add_kvm_msi_virq(s, vector, errp);
+        if (*errp) {
             return;
         }
 
@@ -506,7 +504,6 @@ static void setup_interrupt(IVShmemState *s, int vector, Error **errp)
 
 static void process_msg_shmem(IVShmemState *s, int fd, Error **errp)
 {
-    Error *local_err = NULL;
     struct stat buf;
     size_t size;
 
@@ -527,9 +524,8 @@ static void process_msg_shmem(IVShmemState *s, int fd, Error **errp)
 
     /* mmap the region and map into the BAR2 */
     memory_region_init_ram_from_fd(&s->server_bar2, OBJECT(s),
-                                   "ivshmem.bar2", size, true, fd, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                   "ivshmem.bar2", size, true, fd, errp);
+    if (*errp) {
         return;
     }
 
@@ -662,13 +658,11 @@ static int64_t ivshmem_recv_msg(IVShmemState *s, int *pfd, Error **errp)
 
 static void ivshmem_recv_setup(IVShmemState *s, Error **errp)
 {
-    Error *err = NULL;
     int64_t msg;
     int fd;
 
-    msg = ivshmem_recv_msg(s, &fd, &err);
-    if (err) {
-        error_propagate(errp, err);
+    msg = ivshmem_recv_msg(s, &fd, errp);
+    if (*errp) {
         return;
     }
     if (msg != IVSHMEM_PROTOCOL_VERSION) {
@@ -694,9 +688,8 @@ static void ivshmem_recv_setup(IVShmemState *s, Error **errp)
      * older versions of the device accepted it out of order, but
      * broke when an interrupt setup message arrived before it.
      */
-    msg = ivshmem_recv_msg(s, &fd, &err);
-    if (err) {
-        error_propagate(errp, err);
+    msg = ivshmem_recv_msg(s, &fd, errp);
+    if (*errp) {
         return;
     }
     if (fd != -1 || msg < 0 || msg > IVSHMEM_MAX_PEERS) {
@@ -709,14 +702,12 @@ static void ivshmem_recv_setup(IVShmemState *s, Error **errp)
      * Receive more messages until we got shared memory.
      */
     do {
-        msg = ivshmem_recv_msg(s, &fd, &err);
-        if (err) {
-            error_propagate(errp, err);
+        msg = ivshmem_recv_msg(s, &fd, errp);
+        if (*errp) {
             return;
         }
-        process_msg(s, msg, fd, &err);
-        if (err) {
-            error_propagate(errp, err);
+        process_msg(s, msg, fd, errp);
+        if (*errp) {
             return;
         }
     } while (msg != -1);
diff --git a/hw/misc/macio/macio.c b/hw/misc/macio/macio.c
index 50f20d8206..2bfdfe62f3 100644
--- a/hw/misc/macio/macio.c
+++ b/hw/misc/macio/macio.c
@@ -107,11 +107,9 @@ static void macio_common_realize(PCIDevice *d, Error **errp)
 {
     MacIOState *s = MACIO(d);
     SysBusDevice *sysbus_dev;
-    Error *err = NULL;
 
-    object_property_set_bool(OBJECT(&s->dbdma), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->dbdma), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_dev = SYS_BUS_DEVICE(&s->dbdma);
@@ -125,9 +123,8 @@ static void macio_common_realize(PCIDevice *d, Error **errp)
     qdev_prop_set_chr(DEVICE(&s->escc), "chrB", serial_hd(1));
     qdev_prop_set_uint32(DEVICE(&s->escc), "chnBtype", escc_serial);
     qdev_prop_set_uint32(DEVICE(&s->escc), "chnAtype", escc_serial);
-    object_property_set_bool(OBJECT(&s->escc), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->escc), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -156,20 +153,17 @@ static void macio_oldworld_realize(PCIDevice *d, Error **errp)
     MacIOState *s = MACIO(d);
     OldWorldMacIOState *os = OLDWORLD_MACIO(d);
     DeviceState *pic_dev = DEVICE(os->pic);
-    Error *err = NULL;
     SysBusDevice *sysbus_dev;
 
-    macio_common_realize(d, &err);
-    if (err) {
-        error_propagate(errp, err);
+    macio_common_realize(d, errp);
+    if (*errp) {
         return;
     }
 
     qdev_prop_set_uint64(DEVICE(&s->cuda), "timebase-frequency",
                          s->frequency);
-    object_property_set_bool(OBJECT(&s->cuda), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->cuda), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_dev = SYS_BUS_DEVICE(&s->cuda);
@@ -184,9 +178,8 @@ static void macio_oldworld_realize(PCIDevice *d, Error **errp)
     sysbus_connect_irq(sysbus_dev, 1, qdev_get_gpio_in(pic_dev,
                                                        OLDWORLD_ESCCA_IRQ));
 
-    object_property_set_bool(OBJECT(&os->nvram), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&os->nvram), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_dev = SYS_BUS_DEVICE(&os->nvram);
@@ -203,18 +196,16 @@ static void macio_oldworld_realize(PCIDevice *d, Error **errp)
     macio_realize_ide(s, &os->ide[0],
                       qdev_get_gpio_in(pic_dev, OLDWORLD_IDE0_IRQ),
                       qdev_get_gpio_in(pic_dev, OLDWORLD_IDE0_DMA_IRQ),
-                      0x16, &err);
-    if (err) {
-        error_propagate(errp, err);
+                      0x16, errp);
+    if (*errp) {
         return;
     }
 
     macio_realize_ide(s, &os->ide[1],
                       qdev_get_gpio_in(pic_dev, OLDWORLD_IDE1_IRQ),
                       qdev_get_gpio_in(pic_dev, OLDWORLD_IDE1_DMA_IRQ),
-                      0x1a, &err);
-    if (err) {
-        error_propagate(errp, err);
+                      0x1a, errp);
+    if (*errp) {
         return;
     }
 }
@@ -294,13 +285,11 @@ static void macio_newworld_realize(PCIDevice *d, Error **errp)
     MacIOState *s = MACIO(d);
     NewWorldMacIOState *ns = NEWWORLD_MACIO(d);
     DeviceState *pic_dev = DEVICE(ns->pic);
-    Error *err = NULL;
     SysBusDevice *sysbus_dev;
     MemoryRegion *timer_memory = NULL;
 
-    macio_common_realize(d, &err);
-    if (err) {
-        error_propagate(errp, err);
+    macio_common_realize(d, errp);
+    if (*errp) {
         return;
     }
 
@@ -319,18 +308,16 @@ static void macio_newworld_realize(PCIDevice *d, Error **errp)
     macio_realize_ide(s, &ns->ide[0],
                       qdev_get_gpio_in(pic_dev, NEWWORLD_IDE0_IRQ),
                       qdev_get_gpio_in(pic_dev, NEWWORLD_IDE0_DMA_IRQ),
-                      0x16, &err);
-    if (err) {
-        error_propagate(errp, err);
+                      0x16, errp);
+    if (*errp) {
         return;
     }
 
     macio_realize_ide(s, &ns->ide[1],
                       qdev_get_gpio_in(pic_dev, NEWWORLD_IDE1_IRQ),
                       qdev_get_gpio_in(pic_dev, NEWWORLD_IDE1_DMA_IRQ),
-                      0x1a, &err);
-    if (err) {
-        error_propagate(errp, err);
+                      0x1a, errp);
+    if (*errp) {
         return;
     }
 
@@ -347,7 +334,7 @@ static void macio_newworld_realize(PCIDevice *d, Error **errp)
                                  &error_abort);
         memory_region_add_subregion(&s->bar, 0x50,
                                     sysbus_mmio_get_region(sysbus_dev, 0));
-        object_property_set_bool(OBJECT(&ns->gpio), true, "realized", &err);
+        object_property_set_bool(OBJECT(&ns->gpio), true, "realized", errp);
 
         /* PMU */
         object_initialize_child(OBJECT(s), "pmu", &s->pmu, sizeof(s->pmu),
@@ -357,9 +344,8 @@ static void macio_newworld_realize(PCIDevice *d, Error **errp)
         qdev_prop_set_bit(DEVICE(&s->pmu), "has-adb", ns->has_adb);
         qdev_set_parent_bus(DEVICE(&s->pmu), BUS(&s->macio_bus));
 
-        object_property_set_bool(OBJECT(&s->pmu), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->pmu), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_dev = SYS_BUS_DEVICE(&s->pmu);
@@ -375,9 +361,8 @@ static void macio_newworld_realize(PCIDevice *d, Error **errp)
         qdev_prop_set_uint64(DEVICE(&s->cuda), "timebase-frequency",
                              s->frequency);
 
-        object_property_set_bool(OBJECT(&s->cuda), true, "realized", &err);
-        if (err) {
-            error_propagate(errp, err);
+        object_property_set_bool(OBJECT(&s->cuda), true, "realized", errp);
+        if (*errp) {
             return;
         }
         sysbus_dev = SYS_BUS_DEVICE(&s->cuda);
diff --git a/hw/misc/mps2-scc.c b/hw/misc/mps2-scc.c
index 25779a1dca..f2a00d3235 100644
--- a/hw/misc/mps2-scc.c
+++ b/hw/misc/mps2-scc.c
@@ -249,6 +249,7 @@ static void mps2_scc_init(Object *obj)
 
 static void mps2_scc_realize(DeviceState *dev, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static const VMStateDescription mps2_scc_vmstate = {
diff --git a/hw/misc/tmp105.c b/hw/misc/tmp105.c
index 75ddad3a12..480eae23dd 100644
--- a/hw/misc/tmp105.c
+++ b/hw/misc/tmp105.c
@@ -72,12 +72,10 @@ static void tmp105_set_temperature(Object *obj, Visitor *v, const char *name,
                                    void *opaque, Error **errp)
 {
     TMP105State *s = TMP105(obj);
-    Error *local_err = NULL;
     int64_t temp;
 
-    visit_type_int(v, name, &temp, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_int(v, name, &temp, errp);
+    if (*errp) {
         return;
     }
     if (temp >= 128000 || temp < -128000) {
diff --git a/hw/misc/tmp421.c b/hw/misc/tmp421.c
index 9f044705fa..cdb42379c4 100644
--- a/hw/misc/tmp421.c
+++ b/hw/misc/tmp421.c
@@ -141,15 +141,13 @@ static void tmp421_set_temperature(Object *obj, Visitor *v, const char *name,
                                    void *opaque, Error **errp)
 {
     TMP421State *s = TMP421(obj);
-    Error *local_err = NULL;
     int64_t temp;
     bool ext_range = (s->config[0] & TMP421_CONFIG_RANGE);
     int offset = ext_range * 64 * 256;
     int tempid;
 
-    visit_type_int(v, name, &temp, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_int(v, name, &temp, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/net/dp8393x.c b/hw/net/dp8393x.c
index a5678e11fa..9c4cd39083 100644
--- a/hw/net/dp8393x.c
+++ b/hw/net/dp8393x.c
@@ -877,7 +877,6 @@ static void dp8393x_realize(DeviceState *dev, Error **errp)
     dp8393xState *s = DP8393X(dev);
     int i, checksum;
     uint8_t *prom;
-    Error *local_err = NULL;
 
     address_space_init(&s->as, s->dma_mr, "dp8393x");
     memory_region_init_io(&s->mmio, OBJECT(dev), &dp8393x_ops, s,
@@ -891,9 +890,8 @@ static void dp8393x_realize(DeviceState *dev, Error **errp)
     s->regs[SONIC_SR] = 0x0004; /* only revision recognized by Linux */
 
     memory_region_init_ram(&s->prom, OBJECT(dev),
-                           "dp8393x-prom", SONIC_PROM_SIZE, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                           "dp8393x-prom", SONIC_PROM_SIZE, errp);
+    if (*errp) {
         return;
     }
     memory_region_set_readonly(&s->prom, true);
diff --git a/hw/net/eepro100.c b/hw/net/eepro100.c
index cc2dd8b1c9..616083b662 100644
--- a/hw/net/eepro100.c
+++ b/hw/net/eepro100.c
@@ -1831,15 +1831,13 @@ static void e100_nic_realize(PCIDevice *pci_dev, Error **errp)
 {
     EEPRO100State *s = DO_UPCAST(EEPRO100State, dev, pci_dev);
     E100PCIDeviceInfo *info = eepro100_get_class(s);
-    Error *local_err = NULL;
 
     TRACE(OTHER, logout("\n"));
 
     s->device = info->device;
 
-    e100_pci_reset(s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    e100_pci_reset(s, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/net/ne2000-isa.c b/hw/net/ne2000-isa.c
index 6fcf3d5cd9..43a6ee7f3d 100644
--- a/hw/net/ne2000-isa.c
+++ b/hw/net/ne2000-isa.c
@@ -111,22 +111,18 @@ static void isa_ne2000_set_bootindex(Object *obj, Visitor *v,
     ISANE2000State *isa = ISA_NE2000(obj);
     NE2000State *s = &isa->ne2000;
     int32_t boot_index;
-    Error *local_err = NULL;
 
-    visit_type_int32(v, name, &boot_index, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_int32(v, name, &boot_index, errp);
+    if (*errp) {
+        return;
     }
     /* check whether bootindex is present in fw_boot_order list  */
-    check_boot_index(boot_index, &local_err);
-    if (local_err) {
-        goto out;
+    check_boot_index(boot_index, errp);
+    if (*errp) {
+        return;
     }
     /* change bootindex to a new one */
     s->c.bootindex = boot_index;
-
-out:
-    error_propagate(errp, local_err);
 }
 
 static void isa_ne2000_instance_init(Object *obj)
diff --git a/hw/net/xilinx_axienet.c b/hw/net/xilinx_axienet.c
index 2c8c065401..5f87a6336b 100644
--- a/hw/net/xilinx_axienet.c
+++ b/hw/net/xilinx_axienet.c
@@ -951,24 +951,23 @@ static void xilinx_enet_realize(DeviceState *dev, Error **errp)
     XilinxAXIEnetStreamSlave *ds = XILINX_AXI_ENET_DATA_STREAM(&s->rx_data_dev);
     XilinxAXIEnetStreamSlave *cs = XILINX_AXI_ENET_CONTROL_STREAM(
                                                             &s->rx_control_dev);
-    Error *local_err = NULL;
 
     object_property_add_link(OBJECT(ds), "enet", "xlnx.axi-ethernet",
                              (Object **) &ds->enet,
                              object_property_allow_set_link,
                              OBJ_PROP_LINK_STRONG,
-                             &local_err);
+                             errp);
     object_property_add_link(OBJECT(cs), "enet", "xlnx.axi-ethernet",
                              (Object **) &cs->enet,
                              object_property_allow_set_link,
                              OBJ_PROP_LINK_STRONG,
-                             &local_err);
-    if (local_err) {
+                             errp);
+    if (*errp) {
         goto xilinx_enet_realize_fail;
     }
-    object_property_set_link(OBJECT(ds), OBJECT(s), "enet", &local_err);
-    object_property_set_link(OBJECT(cs), OBJECT(s), "enet", &local_err);
-    if (local_err) {
+    object_property_set_link(OBJECT(ds), OBJECT(s), "enet", errp);
+    object_property_set_link(OBJECT(cs), OBJECT(s), "enet", errp);
+    if (*errp) {
         goto xilinx_enet_realize_fail;
     }
 
@@ -986,7 +985,6 @@ static void xilinx_enet_realize(DeviceState *dev, Error **errp)
     return;
 
 xilinx_enet_realize_fail:
-    error_propagate(errp, local_err);
 }
 
 static void xilinx_enet_init(Object *obj)
diff --git a/hw/nvram/fw_cfg.c b/hw/nvram/fw_cfg.c
index 7dc3ac378e..6f4d102cf3 100644
--- a/hw/nvram/fw_cfg.c
+++ b/hw/nvram/fw_cfg.c
@@ -1105,11 +1105,9 @@ static Property fw_cfg_io_properties[] = {
 static void fw_cfg_io_realize(DeviceState *dev, Error **errp)
 {
     FWCfgIoState *s = FW_CFG_IO(dev);
-    Error *local_err = NULL;
 
-    fw_cfg_file_slots_allocate(FW_CFG(s), &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    fw_cfg_file_slots_allocate(FW_CFG(s), errp);
+    if (*errp) {
         return;
     }
 
@@ -1158,11 +1156,9 @@ static void fw_cfg_mem_realize(DeviceState *dev, Error **errp)
     FWCfgMemState *s = FW_CFG_MEM(dev);
     SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
     const MemoryRegionOps *data_ops = &fw_cfg_data_mem_ops;
-    Error *local_err = NULL;
 
-    fw_cfg_file_slots_allocate(FW_CFG(s), &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    fw_cfg_file_slots_allocate(FW_CFG(s), errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/nvram/nrf51_nvm.c b/hw/nvram/nrf51_nvm.c
index 4d678f994e..396f72b2b0 100644
--- a/hw/nvram/nrf51_nvm.c
+++ b/hw/nvram/nrf51_nvm.c
@@ -327,12 +327,10 @@ static void nrf51_nvm_init(Object *obj)
 static void nrf51_nvm_realize(DeviceState *dev, Error **errp)
 {
     NRF51NVMState *s = NRF51_NVM(dev);
-    Error *err = NULL;
 
     memory_region_init_rom_device(&s->flash, OBJECT(dev), &flash_ops, s,
-        "nrf51_soc.flash", s->flash_size, &err);
-    if (err) {
-        error_propagate(errp, err);
+        "nrf51_soc.flash", s->flash_size, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/pci-bridge/dec.c b/hw/pci-bridge/dec.c
index 3ae2f788a4..fbe781474e 100644
--- a/hw/pci-bridge/dec.c
+++ b/hw/pci-bridge/dec.c
@@ -116,6 +116,7 @@ static void pci_dec_21154_device_realize(DeviceState *dev, Error **errp)
 
 static void dec_21154_pci_host_realize(PCIDevice *d, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
     /* PCI2PCI bridge same values as PearPC - check this */
 }
 
diff --git a/hw/pci-bridge/gen_pcie_root_port.c b/hw/pci-bridge/gen_pcie_root_port.c
index 9eaefebca8..bfb288ccf7 100644
--- a/hw/pci-bridge/gen_pcie_root_port.c
+++ b/hw/pci-bridge/gen_pcie_root_port.c
@@ -76,11 +76,9 @@ static void gen_rp_realize(DeviceState *dev, Error **errp)
     PCIDevice *d = PCI_DEVICE(dev);
     GenPCIERootPort *grp = GEN_PCIE_ROOT_PORT(d);
     PCIERootPortClass *rpc = PCIE_ROOT_PORT_GET_CLASS(d);
-    Error *local_err = NULL;
 
-    rpc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    rpc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/pci-bridge/pci_bridge_dev.c b/hw/pci-bridge/pci_bridge_dev.c
index cc80cb4898..0069322a3a 100644
--- a/hw/pci-bridge/pci_bridge_dev.c
+++ b/hw/pci-bridge/pci_bridge_dev.c
@@ -59,7 +59,6 @@ static void pci_bridge_dev_realize(PCIDevice *dev, Error **errp)
     PCIBridge *br = PCI_BRIDGE(dev);
     PCIBridgeDev *bridge_dev = PCI_BRIDGE_DEV(dev);
     int err;
-    Error *local_err = NULL;
 
     pci_bridge_initfn(dev, TYPE_PCI_BUS);
 
@@ -84,20 +83,19 @@ static void pci_bridge_dev_realize(PCIDevice *dev, Error **errp)
     if (bridge_dev->msi != ON_OFF_AUTO_OFF) {
         /* it means SHPC exists, because MSI is needed by SHPC */
 
-        err = msi_init(dev, 0, 1, true, true, &local_err);
+        err = msi_init(dev, 0, 1, true, true, errp);
         /* Any error other than -ENOTSUP(board's MSI support is broken)
          * is a programming error */
         assert(!err || err == -ENOTSUP);
         if (err && bridge_dev->msi == ON_OFF_AUTO_ON) {
             /* Can't satisfy user's explicit msi=on request, fail */
-            error_append_hint(&local_err, "You have to use msi=auto (default) "
-                    "or msi=off with this machine type.\n");
-            error_propagate(errp, local_err);
+            error_append_hint(errp, "You have to use msi=auto (default) "
+                              "or msi=off with this machine type.\n");
             goto msi_error;
         }
-        assert(!local_err || bridge_dev->msi == ON_OFF_AUTO_AUTO);
+        assert(!*errp || bridge_dev->msi == ON_OFF_AUTO_AUTO);
         /* With msi=auto, we fall back to MSI off silently */
-        error_free(local_err);
+        error_free_errp(errp);
     }
 
     err = pci_bridge_qemu_reserve_cap_init(dev, 0,
diff --git a/hw/pci-bridge/pci_expander_bridge.c b/hw/pci-bridge/pci_expander_bridge.c
index 0592818447..b9e87e8158 100644
--- a/hw/pci-bridge/pci_expander_bridge.c
+++ b/hw/pci-bridge/pci_expander_bridge.c
@@ -213,7 +213,6 @@ static void pxb_dev_realize_common(PCIDevice *dev, bool pcie, Error **errp)
     DeviceState *ds, *bds = NULL;
     PCIBus *bus;
     const char *dev_name = NULL;
-    Error *local_err = NULL;
     MachineState *ms = MACHINE(qdev_get_machine());
 
     if (ms->numa_state == NULL) {
@@ -249,9 +248,8 @@ static void pxb_dev_realize_common(PCIDevice *dev, bool pcie, Error **errp)
 
     PCI_HOST_BRIDGE(ds)->bus = bus;
 
-    pxb_register_bus(dev, bus, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pxb_register_bus(dev, bus, errp);
+    if (*errp) {
         goto err_register_bus;
     }
 
diff --git a/hw/pci-bridge/pcie_pci_bridge.c b/hw/pci-bridge/pcie_pci_bridge.c
index 7679bef6c1..00065c3aa8 100644
--- a/hw/pci-bridge/pcie_pci_bridge.c
+++ b/hw/pci-bridge/pcie_pci_bridge.c
@@ -66,17 +66,14 @@ static void pcie_pci_bridge_realize(PCIDevice *d, Error **errp)
     if (rc < 0) {
         goto aer_error;
     }
-
-    Error *local_err = NULL;
     if (pcie_br->msi != ON_OFF_AUTO_OFF) {
-        rc = msi_init(d, 0, 1, true, true, &local_err);
+        rc = msi_init(d, 0, 1, true, true, errp);
         if (rc < 0) {
             assert(rc == -ENOTSUP);
             if (pcie_br->msi != ON_OFF_AUTO_ON) {
-                error_free(local_err);
+                error_free_errp(errp);
             } else {
                 /* failed to satisfy user's explicit request for MSI */
-                error_propagate(errp, local_err);
                 goto msi_error;
             }
         }
diff --git a/hw/pci-host/piix.c b/hw/pci-host/piix.c
index 135c645535..319fa71e52 100644
--- a/hw/pci-host/piix.c
+++ b/hw/pci-host/piix.c
@@ -858,15 +858,13 @@ static void igd_pt_i440fx_realize(PCIDevice *pci_dev, Error **errp)
     uint32_t val = 0;
     int i, num;
     int pos, len;
-    Error *local_err = NULL;
 
     num = ARRAY_SIZE(igd_host_bridge_infos);
     for (i = 0; i < num; i++) {
         pos = igd_host_bridge_infos[i].offset;
         len = igd_host_bridge_infos[i].len;
-        host_pci_config_read(pos, len, &val, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        host_pci_config_read(pos, len, &val, errp);
+        if (*errp) {
             return;
         }
         pci_default_write_config(pci_dev, pos, val, len);
diff --git a/hw/pci/pci.c b/hw/pci/pci.c
index aa05c2b9b2..42f5fb49fa 100644
--- a/hw/pci/pci.c
+++ b/hw/pci/pci.c
@@ -998,7 +998,6 @@ static PCIDevice *do_pci_register_device(PCIDevice *pci_dev,
     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev);
     PCIConfigReadFunc *config_read = pc->config_read;
     PCIConfigWriteFunc *config_write = pc->config_write;
-    Error *local_err = NULL;
     DeviceState *dev = DEVICE(pci_dev);
     PCIBus *bus = pci_get_bus(pci_dev);
 
@@ -1084,9 +1083,8 @@ static PCIDevice *do_pci_register_device(PCIDevice *pci_dev,
     if (pc->is_bridge) {
         pci_init_mask_bridge(pci_dev);
     }
-    pci_init_multifunction(bus, pci_dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pci_init_multifunction(bus, pci_dev, errp);
+    if (*errp) {
         do_pci_unregister_device(pci_dev);
         return NULL;
     }
@@ -2075,7 +2073,6 @@ static void pci_qdev_realize(DeviceState *qdev, Error **errp)
     PCIDevice *pci_dev = (PCIDevice *)qdev;
     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(pci_dev);
     ObjectClass *klass = OBJECT_CLASS(pc);
-    Error *local_err = NULL;
     bool is_default_rom;
 
     /* initialize cap_present for pci_is_express() and pci_config_size(),
@@ -2093,9 +2090,8 @@ static void pci_qdev_realize(DeviceState *qdev, Error **errp)
         return;
 
     if (pc->realize) {
-        pc->realize(pci_dev, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        pc->realize(pci_dev, errp);
+        if (*errp) {
             do_pci_unregister_device(pci_dev);
             return;
         }
@@ -2108,9 +2104,8 @@ static void pci_qdev_realize(DeviceState *qdev, Error **errp)
         is_default_rom = true;
     }
 
-    pci_add_option_rom(pci_dev, is_default_rom, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pci_add_option_rom(pci_dev, is_default_rom, errp);
+    if (*errp) {
         pci_qdev_unrealize(DEVICE(pci_dev), NULL);
         return;
     }
diff --git a/hw/pci/pcie.c b/hw/pci/pcie.c
index a6beb567bd..3a688d54b0 100644
--- a/hw/pci/pcie.c
+++ b/hw/pci/pcie.c
@@ -463,13 +463,11 @@ static void pcie_unplug_device(PCIBus *bus, PCIDevice *dev, void *opaque)
 void pcie_cap_slot_unplug_request_cb(HotplugHandler *hotplug_dev,
                                      DeviceState *dev, Error **errp)
 {
-    Error *local_err = NULL;
     PCIDevice *pci_dev = PCI_DEVICE(dev);
     PCIBus *bus = pci_get_bus(pci_dev);
 
-    pcie_cap_slot_plug_common(PCI_DEVICE(hotplug_dev), dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pcie_cap_slot_plug_common(PCI_DEVICE(hotplug_dev), dev, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/pci/shpc.c b/hw/pci/shpc.c
index 7f0aa28e44..2cfb7942da 100644
--- a/hw/pci/shpc.c
+++ b/hw/pci/shpc.c
@@ -504,14 +504,12 @@ static void shpc_device_plug_common(PCIDevice *affected_dev, int *slot,
 void shpc_device_plug_cb(HotplugHandler *hotplug_dev, DeviceState *dev,
                             Error **errp)
 {
-    Error *local_err = NULL;
     PCIDevice *pci_hotplug_dev = PCI_DEVICE(hotplug_dev);
     SHPCDevice *shpc = pci_hotplug_dev->shpc;
     int slot;
 
-    shpc_device_plug_common(PCI_DEVICE(dev), &slot, shpc, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    shpc_device_plug_common(PCI_DEVICE(dev), &slot, shpc, errp);
+    if (*errp) {
         return;
     }
 
@@ -553,16 +551,14 @@ void shpc_device_unplug_cb(HotplugHandler *hotplug_dev, DeviceState *dev,
 void shpc_device_unplug_request_cb(HotplugHandler *hotplug_dev,
                                    DeviceState *dev, Error **errp)
 {
-    Error *local_err = NULL;
     PCIDevice *pci_hotplug_dev = PCI_DEVICE(hotplug_dev);
     SHPCDevice *shpc = pci_hotplug_dev->shpc;
     uint8_t state;
     uint8_t led;
     int slot;
 
-    shpc_device_plug_common(PCI_DEVICE(dev), &slot, shpc, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    shpc_device_plug_common(PCI_DEVICE(dev), &slot, shpc, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/ppc/e500.c b/hw/ppc/e500.c
index 91cd4c26f9..7b79a18a9f 100644
--- a/hw/ppc/e500.c
+++ b/hw/ppc/e500.c
@@ -764,16 +764,14 @@ static DeviceState *ppce500_init_mpic_qemu(PPCE500MachineState *pms,
 static DeviceState *ppce500_init_mpic_kvm(const PPCE500MachineClass *pmc,
                                           IrqLines *irqs, Error **errp)
 {
-    Error *err = NULL;
     DeviceState *dev;
     CPUState *cs;
 
     dev = qdev_create(NULL, TYPE_KVM_OPENPIC);
     qdev_prop_set_uint32(dev, "model", pmc->mpic_version);
 
-    object_property_set_bool(OBJECT(dev), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(dev), true, "realized", errp);
+    if (*errp) {
         object_unparent(OBJECT(dev));
         return NULL;
     }
diff --git a/hw/ppc/pnv.c b/hw/ppc/pnv.c
index 3f08db7b9e..049155b4ec 100644
--- a/hw/ppc/pnv.c
+++ b/hw/ppc/pnv.c
@@ -752,14 +752,12 @@ static uint32_t pnv_chip_core_pir_p8(PnvChip *chip, uint32_t core_id)
 static void pnv_chip_power8_intc_create(PnvChip *chip, PowerPCCPU *cpu,
                                         Error **errp)
 {
-    Error *local_err = NULL;
     Object *obj;
     PnvCPUState *pnv_cpu = pnv_cpu_state(cpu);
 
     obj = icp_create(OBJECT(cpu), TYPE_PNV_ICP, XICS_FABRIC(qdev_get_machine()),
-                     &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                     errp);
+    if (*errp) {
         return;
     }
 
@@ -785,7 +783,6 @@ static void pnv_chip_power9_intc_create(PnvChip *chip, PowerPCCPU *cpu,
                                         Error **errp)
 {
     Pnv9Chip *chip9 = PNV9_CHIP(chip);
-    Error *local_err = NULL;
     Object *obj;
     PnvCPUState *pnv_cpu = pnv_cpu_state(cpu);
 
@@ -794,9 +791,8 @@ static void pnv_chip_power9_intc_create(PnvChip *chip, PowerPCCPU *cpu,
      * controller object is initialized afterwards. Hopefully, it's
      * only used at runtime.
      */
-    obj = xive_tctx_create(OBJECT(cpu), XIVE_ROUTER(&chip9->xive), &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    obj = xive_tctx_create(OBJECT(cpu), XIVE_ROUTER(&chip9->xive), errp);
+    if (*errp) {
         return;
     }
 
@@ -887,28 +883,24 @@ static void pnv_chip_power8_realize(DeviceState *dev, Error **errp)
     PnvChip *chip = PNV_CHIP(dev);
     Pnv8Chip *chip8 = PNV8_CHIP(dev);
     Pnv8Psi *psi8 = &chip8->psi;
-    Error *local_err = NULL;
 
     /* XSCOM bridge is first */
-    pnv_xscom_realize(chip, PNV_XSCOM_SIZE, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pnv_xscom_realize(chip, PNV_XSCOM_SIZE, errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(chip), 0, PNV_XSCOM_BASE(chip));
 
-    pcc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pcc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
     /* Processor Service Interface (PSI) Host Bridge */
     object_property_set_int(OBJECT(&chip8->psi), PNV_PSIHB_BASE(chip),
                             "bar", &error_fatal);
-    object_property_set_bool(OBJECT(&chip8->psi), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(&chip8->psi), true, "realized", errp);
+    if (*errp) {
         return;
     }
     pnv_xscom_add_subregion(chip, PNV_XSCOM_PSIHB_BASE,
@@ -925,16 +917,14 @@ static void pnv_chip_power8_realize(DeviceState *dev, Error **errp)
 
     /* Interrupt Management Area. This is the memory region holding
      * all the Interrupt Control Presenter (ICP) registers */
-    pnv_chip_icp_realize(chip8, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pnv_chip_icp_realize(chip8, errp);
+    if (*errp) {
         return;
     }
 
     /* Create the simplified OCC model */
-    object_property_set_bool(OBJECT(&chip8->occ), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(&chip8->occ), true, "realized", errp);
+    if (*errp) {
         return;
     }
     pnv_xscom_add_subregion(chip, PNV_XSCOM_OCC_BASE, &chip8->occ.xscom_regs);
@@ -1056,25 +1046,21 @@ static void pnv_chip_power9_realize(DeviceState *dev, Error **errp)
     Pnv9Chip *chip9 = PNV9_CHIP(dev);
     PnvChip *chip = PNV_CHIP(dev);
     Pnv9Psi *psi9 = &chip9->psi;
-    Error *local_err = NULL;
 
     /* XSCOM bridge is first */
-    pnv_xscom_realize(chip, PNV9_XSCOM_SIZE, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pnv_xscom_realize(chip, PNV9_XSCOM_SIZE, errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(chip), 0, PNV9_XSCOM_BASE(chip));
 
-    pcc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pcc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
-    pnv_chip_quad_realize(chip9, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pnv_chip_quad_realize(chip9, errp);
+    if (*errp) {
         return;
     }
 
@@ -1088,9 +1074,8 @@ static void pnv_chip_power9_realize(DeviceState *dev, Error **errp)
     object_property_set_int(OBJECT(&chip9->xive), PNV9_XIVE_TM_BASE(chip),
                             "tm-bar", &error_fatal);
     object_property_set_bool(OBJECT(&chip9->xive), true, "realized",
-                             &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                             errp);
+    if (*errp) {
         return;
     }
     pnv_xscom_add_subregion(chip, PNV9_XSCOM_XIVE_BASE,
@@ -1099,18 +1084,16 @@ static void pnv_chip_power9_realize(DeviceState *dev, Error **errp)
     /* Processor Service Interface (PSI) Host Bridge */
     object_property_set_int(OBJECT(&chip9->psi), PNV9_PSIHB_BASE(chip),
                             "bar", &error_fatal);
-    object_property_set_bool(OBJECT(&chip9->psi), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(&chip9->psi), true, "realized", errp);
+    if (*errp) {
         return;
     }
     pnv_xscom_add_subregion(chip, PNV9_XSCOM_PSIHB_BASE,
                             &PNV_PSI(psi9)->xscom_regs);
 
     /* LPC */
-    object_property_set_bool(OBJECT(&chip9->lpc), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(&chip9->lpc), true, "realized", errp);
+    if (*errp) {
         return;
     }
     memory_region_add_subregion(get_system_memory(), PNV9_LPCM_BASE(chip),
@@ -1120,9 +1103,8 @@ static void pnv_chip_power9_realize(DeviceState *dev, Error **errp)
                                             (uint64_t) PNV9_LPCM_BASE(chip));
 
     /* Create the simplified OCC model */
-    object_property_set_bool(OBJECT(&chip9->occ), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(&chip9->occ), true, "realized", errp);
+    if (*errp) {
         return;
     }
     pnv_xscom_add_subregion(chip, PNV9_XSCOM_OCC_BASE, &chip9->occ.xscom_regs);
@@ -1180,7 +1162,6 @@ static void pnv_chip_core_sanitize(PnvChip *chip, Error **errp)
 static void pnv_chip_core_realize(PnvChip *chip, Error **errp)
 {
     MachineState *ms = MACHINE(qdev_get_machine());
-    Error *error = NULL;
     PnvChipClass *pcc = PNV_CHIP_GET_CLASS(chip);
     const char *typename = pnv_chip_core_typename(chip);
     size_t typesize = object_type_get_instance_size(typename);
@@ -1192,9 +1173,8 @@ static void pnv_chip_core_realize(PnvChip *chip, Error **errp)
     }
 
     /* Cores */
-    pnv_chip_core_sanitize(chip, &error);
-    if (error) {
-        error_propagate(errp, error);
+    pnv_chip_core_sanitize(chip, errp);
+    if (*errp) {
         return;
     }
 
@@ -1241,12 +1221,10 @@ static void pnv_chip_core_realize(PnvChip *chip, Error **errp)
 static void pnv_chip_realize(DeviceState *dev, Error **errp)
 {
     PnvChip *chip = PNV_CHIP(dev);
-    Error *error = NULL;
 
     /* Cores */
-    pnv_chip_core_realize(chip, &error);
-    if (error) {
-        error_propagate(errp, error);
+    pnv_chip_core_realize(chip, errp);
+    if (*errp) {
         return;
     }
 }
@@ -1336,11 +1314,9 @@ static void pnv_set_num_chips(Object *obj, Visitor *v, const char *name,
 {
     PnvMachineState *pnv = PNV_MACHINE(obj);
     uint32_t num_chips;
-    Error *local_err = NULL;
 
-    visit_type_uint32(v, name, &num_chips, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_uint32(v, name, &num_chips, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/ppc/pnv_core.c b/hw/ppc/pnv_core.c
index b1a7489e7a..ac7bc78e3a 100644
--- a/hw/ppc/pnv_core.c
+++ b/hw/ppc/pnv_core.c
@@ -166,18 +166,15 @@ static void pnv_realize_vcpu(PowerPCCPU *cpu, PnvChip *chip, Error **errp)
     int core_pir;
     int thread_index = 0; /* TODO: TCG supports only one thread */
     ppc_spr_t *pir = &env->spr_cb[SPR_PIR];
-    Error *local_err = NULL;
     PnvChipClass *pcc = PNV_CHIP_GET_CLASS(chip);
 
-    object_property_set_bool(OBJECT(cpu), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(cpu), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
-    pcc->intc_create(chip, cpu, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    pcc->intc_create(chip, cpu, errp);
+    if (*errp) {
         return;
     }
 
@@ -202,15 +199,14 @@ static void pnv_core_realize(DeviceState *dev, Error **errp)
     PnvCoreClass *pcc = PNV_CORE_GET_CLASS(pc);
     CPUCore *cc = CPU_CORE(OBJECT(dev));
     const char *typename = pnv_core_cpu_typename(pc);
-    Error *local_err = NULL;
     void *obj;
     int i, j;
     char name[32];
     Object *chip;
 
-    chip = object_property_get_link(OBJECT(dev), "chip", &local_err);
+    chip = object_property_get_link(OBJECT(dev), "chip", errp);
     if (!chip) {
-        error_propagate_prepend(errp, local_err,
+        error_propagate_prepend(errp, *errp,
                                 "required link 'chip' not found: ");
         return;
     }
@@ -235,8 +231,8 @@ static void pnv_core_realize(DeviceState *dev, Error **errp)
     }
 
     for (j = 0; j < cc->nr_threads; j++) {
-        pnv_realize_vcpu(pc->threads[j], PNV_CHIP(chip), &local_err);
-        if (local_err) {
+        pnv_realize_vcpu(pc->threads[j], PNV_CHIP(chip), errp);
+        if (*errp) {
             goto err;
         }
     }
@@ -252,7 +248,6 @@ err:
         object_unparent(obj);
     }
     g_free(pc->threads);
-    error_propagate(errp, local_err);
 }
 
 static void pnv_unrealize_vcpu(PowerPCCPU *cpu)
diff --git a/hw/ppc/pnv_lpc.c b/hw/ppc/pnv_lpc.c
index 9466d4a1be..68dd4b720f 100644
--- a/hw/ppc/pnv_lpc.c
+++ b/hw/ppc/pnv_lpc.c
@@ -601,11 +601,9 @@ static void pnv_lpc_power8_realize(DeviceState *dev, Error **errp)
 {
     PnvLpcController *lpc = PNV_LPC(dev);
     PnvLpcClass *plc = PNV_LPC_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    plc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    plc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
@@ -646,11 +644,9 @@ static void pnv_lpc_power9_realize(DeviceState *dev, Error **errp)
 {
     PnvLpcController *lpc = PNV_LPC(dev);
     PnvLpcClass *plc = PNV_LPC_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    plc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    plc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
@@ -683,11 +679,9 @@ static void pnv_lpc_realize(DeviceState *dev, Error **errp)
 {
     PnvLpcController *lpc = PNV_LPC(dev);
     Object *obj;
-    Error *local_err = NULL;
 
-    obj = object_property_get_link(OBJECT(dev), "psi", &local_err);
+    obj = object_property_get_link(OBJECT(dev), "psi", errp);
     if (!obj) {
-        error_propagate(errp, local_err);
         error_prepend(errp, "required link 'psi' not found: ");
         return;
     }
@@ -797,7 +791,6 @@ static void pnv_lpc_isa_irq_handler(void *opaque, int n, int level)
 
 ISABus *pnv_lpc_isa_create(PnvLpcController *lpc, bool use_cpld, Error **errp)
 {
-    Error *local_err = NULL;
     ISABus *isa_bus;
     qemu_irq *irqs;
     qemu_irq_handler handler;
@@ -806,9 +799,8 @@ ISABus *pnv_lpc_isa_create(PnvLpcController *lpc, bool use_cpld, Error **errp)
      * devices speficied on the command line won't find the bus and
      * will fail to create.
      */
-    isa_bus = isa_bus_new(NULL, &lpc->isa_mem, &lpc->isa_io, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    isa_bus = isa_bus_new(NULL, &lpc->isa_mem, &lpc->isa_io, errp);
+    if (*errp) {
         return NULL;
     }
 
diff --git a/hw/ppc/pnv_occ.c b/hw/ppc/pnv_occ.c
index 8bead2c930..248aac6757 100644
--- a/hw/ppc/pnv_occ.c
+++ b/hw/ppc/pnv_occ.c
@@ -184,13 +184,11 @@ static void pnv_occ_realize(DeviceState *dev, Error **errp)
     PnvOCC *occ = PNV_OCC(dev);
     PnvOCCClass *poc = PNV_OCC_GET_CLASS(occ);
     Object *obj;
-    Error *local_err = NULL;
 
     occ->occmisc = 0;
 
-    obj = object_property_get_link(OBJECT(dev), "psi", &local_err);
+    obj = object_property_get_link(OBJECT(dev), "psi", errp);
     if (!obj) {
-        error_propagate(errp, local_err);
         error_prepend(errp, "required link 'psi' not found: ");
         return;
     }
diff --git a/hw/ppc/pnv_psi.c b/hw/ppc/pnv_psi.c
index 88ba8e7b9b..7e31712a31 100644
--- a/hw/ppc/pnv_psi.c
+++ b/hw/ppc/pnv_psi.c
@@ -486,27 +486,24 @@ static void pnv_psi_power8_realize(DeviceState *dev, Error **errp)
     PnvPsi *psi = PNV_PSI(dev);
     ICSState *ics = &PNV8_PSI(psi)->ics;
     Object *obj;
-    Error *err = NULL;
     unsigned int i;
 
-    obj = object_property_get_link(OBJECT(dev), "xics", &err);
+    obj = object_property_get_link(OBJECT(dev), "xics", errp);
     if (!obj) {
         error_setg(errp, "%s: required link 'xics' not found: %s",
-                   __func__, error_get_pretty(err));
+                   __func__, error_get_pretty(*errp));
         return;
     }
 
     /* Create PSI interrupt control source */
     object_property_add_const_link(OBJECT(ics), ICS_PROP_XICS, obj,
                                    &error_abort);
-    object_property_set_int(OBJECT(ics), PSI_NUM_INTERRUPTS, "nr-irqs", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_int(OBJECT(ics), PSI_NUM_INTERRUPTS, "nr-irqs", errp);
+    if (*errp) {
         return;
     }
-    object_property_set_bool(OBJECT(ics), true, "realized",  &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(ics), true, "realized",  errp);
+    if (*errp) {
         return;
     }
 
@@ -834,7 +831,6 @@ static void pnv_psi_power9_realize(DeviceState *dev, Error **errp)
 {
     PnvPsi *psi = PNV_PSI(dev);
     XiveSource *xsrc = &PNV9_PSI(psi)->source;
-    Error *local_err = NULL;
     int i;
 
     /* This is the only device with 4k ESB pages */
@@ -844,9 +840,8 @@ static void pnv_psi_power9_realize(DeviceState *dev, Error **errp)
                             &error_fatal);
     object_property_add_const_link(OBJECT(xsrc), "xive", OBJECT(psi),
                                    &error_fatal);
-    object_property_set_bool(OBJECT(xsrc), true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(OBJECT(xsrc), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/ppc/spapr.c b/hw/ppc/spapr.c
index 08a2a5a770..5ef043bd72 100644
--- a/hw/ppc/spapr.c
+++ b/hw/ppc/spapr.c
@@ -2575,30 +2575,29 @@ static CPUArchId *spapr_find_cpu_slot(MachineState *ms, uint32_t id, int *idx)
 static void spapr_set_vsmt_mode(SpaprMachineState *spapr, Error **errp)
 {
     MachineState *ms = MACHINE(spapr);
-    Error *local_err = NULL;
     bool vsmt_user = !!spapr->vsmt;
     int kvm_smt = kvmppc_smt_threads();
     int ret;
     unsigned int smp_threads = ms->smp.threads;
 
     if (!kvm_enabled() && (smp_threads > 1)) {
-        error_setg(&local_err, "TCG cannot support more than 1 thread/core "
+        error_setg(errp, "TCG cannot support more than 1 thread/core "
                      "on a pseries machine");
-        goto out;
+        return;
     }
     if (!is_power_of_2(smp_threads)) {
-        error_setg(&local_err, "Cannot support %d threads/core on a pseries "
+        error_setg(errp, "Cannot support %d threads/core on a pseries "
                      "machine because it must be a power of 2", smp_threads);
-        goto out;
+        return;
     }
 
     /* Detemine the VSMT mode to use: */
     if (vsmt_user) {
         if (spapr->vsmt < smp_threads) {
-            error_setg(&local_err, "Cannot support VSMT mode %d"
+            error_setg(errp, "Cannot support VSMT mode %d"
                          " because it must be >= threads/core (%d)",
                          spapr->vsmt, smp_threads);
-            goto out;
+            return;
         }
         /* In this case, spapr->vsmt has been set by the command line */
     } else {
@@ -2617,7 +2616,7 @@ static void spapr_set_vsmt_mode(SpaprMachineState *spapr, Error **errp)
         ret = kvmppc_set_smt_threads(spapr->vsmt);
         if (ret) {
             /* Looks like KVM isn't able to change VSMT mode */
-            error_setg(&local_err,
+            error_setg(errp,
                        "Failed to set KVM's VSMT mode to %d (errno %d)",
                        spapr->vsmt, ret);
             /* We can live with that if the default one is big enough
@@ -2625,25 +2624,22 @@ static void spapr_set_vsmt_mode(SpaprMachineState *spapr, Error **errp)
              * we want.  In this case we'll waste some vcpu ids, but
              * behaviour will be correct */
             if ((kvm_smt >= smp_threads) && ((spapr->vsmt % kvm_smt) == 0)) {
-                warn_report_err(local_err);
-                local_err = NULL;
-                goto out;
+                warn_report_errp(errp);
+                *errp = NULL;
+                return;
             } else {
                 if (!vsmt_user) {
-                    error_append_hint(&local_err,
+                    error_append_hint(errp,
                                       "On PPC, a VM with %d threads/core"
                                       " on a host with %d threads/core"
                                       " requires the use of VSMT mode %d.\n",
                                       smp_threads, kvm_smt, spapr->vsmt);
                 }
-                kvmppc_hint_smt_possible(&local_err);
-                goto out;
+                kvmppc_hint_smt_possible(errp);
+                return;
             }
         }
     }
-    /* else TCG: nothing to do currently */
-out:
-    error_propagate(errp, local_err);
 }
 
 static void spapr_init_cpus(SpaprMachineState *spapr)
@@ -3458,22 +3454,20 @@ static void spapr_add_lmbs(DeviceState *dev, uint64_t addr_start, uint64_t size,
     int i;
     uint64_t addr = addr_start;
     bool hotplugged = spapr_drc_hotplugged(dev);
-    Error *local_err = NULL;
 
     for (i = 0; i < nr_lmbs; i++) {
         drc = spapr_drc_by_id(TYPE_SPAPR_DRC_LMB,
                               addr / SPAPR_MEMORY_BLOCK_SIZE);
         g_assert(drc);
 
-        spapr_drc_attach(drc, dev, &local_err);
-        if (local_err) {
+        spapr_drc_attach(drc, dev, errp);
+        if (*errp) {
             while (addr > addr_start) {
                 addr -= SPAPR_MEMORY_BLOCK_SIZE;
                 drc = spapr_drc_by_id(TYPE_SPAPR_DRC_LMB,
                                       addr / SPAPR_MEMORY_BLOCK_SIZE);
                 spapr_drc_detach(drc);
             }
-            error_propagate(errp, local_err);
             return;
         }
         if (!hotplugged) {
@@ -3501,27 +3495,26 @@ static void spapr_add_lmbs(DeviceState *dev, uint64_t addr_start, uint64_t size,
 static void spapr_memory_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
                               Error **errp)
 {
-    Error *local_err = NULL;
     SpaprMachineState *ms = SPAPR_MACHINE(hotplug_dev);
     PCDIMMDevice *dimm = PC_DIMM(dev);
     uint64_t size, addr;
 
     size = memory_device_get_region_size(MEMORY_DEVICE(dev), &error_abort);
 
-    pc_dimm_plug(dimm, MACHINE(ms), &local_err);
-    if (local_err) {
+    pc_dimm_plug(dimm, MACHINE(ms), errp);
+    if (*errp) {
         goto out;
     }
 
     addr = object_property_get_uint(OBJECT(dimm),
-                                    PC_DIMM_ADDR_PROP, &local_err);
-    if (local_err) {
+                                    PC_DIMM_ADDR_PROP, errp);
+    if (*errp) {
         goto out_unplug;
     }
 
     spapr_add_lmbs(dev, addr, size, spapr_ovec_test(ms->ov5_cas, OV5_HP_EVT),
-                   &local_err);
-    if (local_err) {
+                   errp);
+    if (*errp) {
         goto out_unplug;
     }
 
@@ -3530,7 +3523,6 @@ static void spapr_memory_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
 out_unplug:
     pc_dimm_unplug(dimm, MACHINE(ms));
 out:
-    error_propagate(errp, local_err);
 }
 
 static void spapr_memory_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
@@ -3539,7 +3531,6 @@ static void spapr_memory_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
     const SpaprMachineClass *smc = SPAPR_MACHINE_GET_CLASS(hotplug_dev);
     SpaprMachineState *spapr = SPAPR_MACHINE(hotplug_dev);
     PCDIMMDevice *dimm = PC_DIMM(dev);
-    Error *local_err = NULL;
     uint64_t size;
     Object *memdev;
     hwaddr pagesize;
@@ -3549,9 +3540,8 @@ static void spapr_memory_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
         return;
     }
 
-    size = memory_device_get_region_size(MEMORY_DEVICE(dimm), &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    size = memory_device_get_region_size(MEMORY_DEVICE(dimm), errp);
+    if (*errp) {
         return;
     }
 
@@ -3564,9 +3554,8 @@ static void spapr_memory_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
     memdev = object_property_get_link(OBJECT(dimm), PC_DIMM_MEMDEV_PROP,
                                       &error_abort);
     pagesize = host_memory_backend_pagesize(MEMORY_BACKEND(memdev));
-    spapr_check_pagesize(spapr, pagesize, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    spapr_check_pagesize(spapr, pagesize, errp);
+    if (*errp) {
         return;
     }
 
@@ -3691,7 +3680,6 @@ static void spapr_memory_unplug_request(HotplugHandler *hotplug_dev,
                                         DeviceState *dev, Error **errp)
 {
     SpaprMachineState *spapr = SPAPR_MACHINE(hotplug_dev);
-    Error *local_err = NULL;
     PCDIMMDevice *dimm = PC_DIMM(dev);
     uint32_t nr_lmbs;
     uint64_t size, addr_start, addr;
@@ -3702,9 +3690,9 @@ static void spapr_memory_unplug_request(HotplugHandler *hotplug_dev,
     nr_lmbs = size / SPAPR_MEMORY_BLOCK_SIZE;
 
     addr_start = object_property_get_uint(OBJECT(dimm), PC_DIMM_ADDR_PROP,
-                                         &local_err);
-    if (local_err) {
-        goto out;
+                                         errp);
+    if (*errp) {
+        return;
     }
 
     /*
@@ -3714,10 +3702,10 @@ static void spapr_memory_unplug_request(HotplugHandler *hotplug_dev,
      * bail out to avoid detaching DRCs that were already released.
      */
     if (spapr_pending_dimm_unplugs_find(spapr, dimm)) {
-        error_setg(&local_err,
+        error_setg(errp,
                    "Memory unplug already in progress for device %s",
                    dev->id);
-        goto out;
+        return;
     }
 
     spapr_pending_dimm_unplugs_add(spapr, nr_lmbs, dimm);
@@ -3736,8 +3724,6 @@ static void spapr_memory_unplug_request(HotplugHandler *hotplug_dev,
                           addr_start / SPAPR_MEMORY_BLOCK_SIZE);
     spapr_hotplug_req_remove_by_count_indexed(SPAPR_DR_CONNECTOR_TYPE_LMB,
                                               nr_lmbs, spapr_drc_index(drc));
-out:
-    error_propagate(errp, local_err);
 }
 
 /* Callback to be called during DRC release. */
@@ -3832,7 +3818,6 @@ static void spapr_core_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
     CPUCore *cc = CPU_CORE(dev);
     CPUState *cs;
     SpaprDrc *drc;
-    Error *local_err = NULL;
     CPUArchId *core_slot;
     int index;
     bool hotplugged = spapr_drc_hotplugged(dev);
@@ -3850,9 +3835,8 @@ static void spapr_core_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
     g_assert(drc || !mc->has_hotpluggable_cpus);
 
     if (drc) {
-        spapr_drc_attach(drc, dev, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        spapr_drc_attach(drc, dev, errp);
+        if (*errp) {
             return;
         }
 
@@ -3883,9 +3867,8 @@ static void spapr_core_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
     if (hotplugged) {
         for (i = 0; i < cc->nr_threads; i++) {
             ppc_set_compat(core->threads[i], POWERPC_CPU(first_cpu)->compat_pvr,
-                           &local_err);
-            if (local_err) {
-                error_propagate(errp, local_err);
+                           errp);
+            if (*errp) {
                 return;
             }
         }
@@ -3897,7 +3880,6 @@ static void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
 {
     MachineState *machine = MACHINE(OBJECT(hotplug_dev));
     MachineClass *mc = MACHINE_GET_CLASS(hotplug_dev);
-    Error *local_err = NULL;
     CPUCore *cc = CPU_CORE(dev);
     const char *base_core_type = spapr_get_cpu_core_type(machine->cpu_type);
     const char *type = object_get_typename(OBJECT(dev));
@@ -3906,18 +3888,18 @@ static void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
     unsigned int smp_threads = machine->smp.threads;
 
     if (dev->hotplugged && !mc->has_hotpluggable_cpus) {
-        error_setg(&local_err, "CPU hotplug not supported for this machine");
-        goto out;
+        error_setg(errp, "CPU hotplug not supported for this machine");
+        return;
     }
 
     if (strcmp(base_core_type, type)) {
-        error_setg(&local_err, "CPU core type should be %s", base_core_type);
-        goto out;
+        error_setg(errp, "CPU core type should be %s", base_core_type);
+        return;
     }
 
     if (cc->core_id % smp_threads) {
-        error_setg(&local_err, "invalid core id %d", cc->core_id);
-        goto out;
+        error_setg(errp, "invalid core id %d", cc->core_id);
+        return;
     }
 
     /*
@@ -3927,26 +3909,23 @@ static void spapr_core_pre_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
      * total vcpus not a multiple of threads-per-core.
      */
     if (mc->has_hotpluggable_cpus && (cc->nr_threads != smp_threads)) {
-        error_setg(&local_err, "invalid nr-threads %d, must be %d",
+        error_setg(errp, "invalid nr-threads %d, must be %d",
                    cc->nr_threads, smp_threads);
-        goto out;
+        return;
     }
 
     core_slot = spapr_find_cpu_slot(MACHINE(hotplug_dev), cc->core_id, &index);
     if (!core_slot) {
-        error_setg(&local_err, "core id %d out of range", cc->core_id);
-        goto out;
+        error_setg(errp, "core id %d out of range", cc->core_id);
+        return;
     }
 
     if (core_slot->cpu) {
-        error_setg(&local_err, "core %d already populated", cc->core_id);
-        goto out;
+        error_setg(errp, "core %d already populated", cc->core_id);
+        return;
     }
 
-    numa_cpu_pre_plug(core_slot, dev, &local_err);
-
-out:
-    error_propagate(errp, local_err);
+    numa_cpu_pre_plug(core_slot, dev, errp);
 }
 
 int spapr_phb_dt_populate(SpaprDrc *drc, SpaprMachineState *spapr,
@@ -4010,7 +3989,6 @@ static void spapr_phb_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
     SpaprPhbState *sphb = SPAPR_PCI_HOST_BRIDGE(dev);
     SpaprDrc *drc;
     bool hotplugged = spapr_drc_hotplugged(dev);
-    Error *local_err = NULL;
 
     if (!smc->dr_phb_enabled) {
         return;
@@ -4020,9 +3998,8 @@ static void spapr_phb_plug(HotplugHandler *hotplug_dev, DeviceState *dev,
     /* hotplug hooks should check it's enabled before getting this far */
     assert(drc);
 
-    spapr_drc_attach(drc, DEVICE(dev), &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    spapr_drc_attach(drc, DEVICE(dev), errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/ppc/spapr_caps.c b/hw/ppc/spapr_caps.c
index 481dfd2a27..513a5dad34 100644
--- a/hw/ppc/spapr_caps.c
+++ b/hw/ppc/spapr_caps.c
@@ -86,11 +86,9 @@ static void spapr_cap_set_bool(Object *obj, Visitor *v, const char *name,
     SpaprCapabilityInfo *cap = opaque;
     SpaprMachineState *spapr = SPAPR_MACHINE(obj);
     bool value;
-    Error *local_err = NULL;
 
-    visit_type_bool(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_bool(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
@@ -123,13 +121,11 @@ static void spapr_cap_set_string(Object *obj, Visitor *v, const char *name,
 {
     SpaprCapabilityInfo *cap = opaque;
     SpaprMachineState *spapr = SPAPR_MACHINE(obj);
-    Error *local_err = NULL;
     uint8_t i;
     char *val;
 
-    visit_type_str(v, name, &val, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &val, errp);
+    if (*errp) {
         return;
     }
 
@@ -169,11 +165,9 @@ static void spapr_cap_set_pagesize(Object *obj, Visitor *v, const char *name,
     SpaprMachineState *spapr = SPAPR_MACHINE(obj);
     uint64_t pagesize;
     uint8_t val;
-    Error *local_err = NULL;
 
-    visit_type_size(v, name, &pagesize, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_size(v, name, &pagesize, errp);
+    if (*errp) {
         return;
     }
 
@@ -248,12 +242,11 @@ SpaprCapPossible cap_cfpc_possible = {
 static void cap_safe_cache_apply(SpaprMachineState *spapr, uint8_t val,
                                  Error **errp)
 {
-    Error *local_err = NULL;
     uint8_t kvm_val =  kvmppc_get_cap_safe_cache();
 
     if (tcg_enabled() && val) {
         /* TCG only supports broken, allow other values and print a warning */
-        error_setg(&local_err,
+        error_setg(errp,
                    "TCG doesn't support requested feature, cap-cfpc=%s",
                    cap_cfpc_possible.vals[val]);
     } else if (kvm_enabled() && (val > kvm_val)) {
@@ -263,8 +256,8 @@ static void cap_safe_cache_apply(SpaprMachineState *spapr, uint8_t val,
                    cap_cfpc_possible.vals[kvm_val]);
     }
 
-    if (local_err != NULL)
-        warn_report_err(local_err);
+    if (*errp != NULL)
+        warn_report_errp(errp);
 }
 
 SpaprCapPossible cap_sbbc_possible = {
@@ -277,12 +270,11 @@ SpaprCapPossible cap_sbbc_possible = {
 static void cap_safe_bounds_check_apply(SpaprMachineState *spapr, uint8_t val,
                                         Error **errp)
 {
-    Error *local_err = NULL;
     uint8_t kvm_val =  kvmppc_get_cap_safe_bounds_check();
 
     if (tcg_enabled() && val) {
         /* TCG only supports broken, allow other values and print a warning */
-        error_setg(&local_err,
+        error_setg(errp,
                    "TCG doesn't support requested feature, cap-sbbc=%s",
                    cap_sbbc_possible.vals[val]);
     } else if (kvm_enabled() && (val > kvm_val)) {
@@ -292,8 +284,8 @@ static void cap_safe_bounds_check_apply(SpaprMachineState *spapr, uint8_t val,
                    cap_sbbc_possible.vals[kvm_val]);
     }
 
-    if (local_err != NULL)
-        warn_report_err(local_err);
+    if (*errp != NULL)
+        warn_report_errp(errp);
 }
 
 SpaprCapPossible cap_ibs_possible = {
@@ -309,12 +301,11 @@ SpaprCapPossible cap_ibs_possible = {
 static void cap_safe_indirect_branch_apply(SpaprMachineState *spapr,
                                            uint8_t val, Error **errp)
 {
-    Error *local_err = NULL;
     uint8_t kvm_val = kvmppc_get_cap_safe_indirect_branch();
 
     if (tcg_enabled() && val) {
         /* TCG only supports broken, allow other values and print a warning */
-        error_setg(&local_err,
+        error_setg(errp,
                    "TCG doesn't support requested feature, cap-ibs=%s",
                    cap_ibs_possible.vals[val]);
     } else if (kvm_enabled() && (val > kvm_val)) {
@@ -324,8 +315,8 @@ static void cap_safe_indirect_branch_apply(SpaprMachineState *spapr,
                    cap_ibs_possible.vals[kvm_val]);
     }
 
-    if (local_err != NULL) {
-        warn_report_err(local_err);
+    if (*errp != NULL) {
+        warn_report_errp(errp);
     }
 }
 
@@ -787,7 +778,6 @@ void spapr_caps_cpu_apply(SpaprMachineState *spapr, PowerPCCPU *cpu)
 
 void spapr_caps_add_properties(SpaprMachineClass *smc, Error **errp)
 {
-    Error *local_err = NULL;
     ObjectClass *klass = OBJECT_CLASS(smc);
     int i;
 
@@ -798,19 +788,17 @@ void spapr_caps_add_properties(SpaprMachineClass *smc, Error **errp)
 
         object_class_property_add(klass, name, cap->type,
                                   cap->get, cap->set,
-                                  NULL, cap, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                                  NULL, cap, errp);
+        if (*errp) {
             g_free(name);
             return;
         }
 
         desc = g_strdup_printf("%s", cap->description);
-        object_class_property_set_description(klass, name, desc, &local_err);
+        object_class_property_set_description(klass, name, desc, errp);
         g_free(name);
         g_free(desc);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             return;
         }
     }
diff --git a/hw/ppc/spapr_cpu_core.c b/hw/ppc/spapr_cpu_core.c
index 1d93de8161..93f9b0e0c9 100644
--- a/hw/ppc/spapr_cpu_core.c
+++ b/hw/ppc/spapr_cpu_core.c
@@ -221,10 +221,9 @@ static void spapr_realize_vcpu(PowerPCCPU *cpu, SpaprMachineState *spapr,
 {
     CPUPPCState *env = &cpu->env;
     CPUState *cs = CPU(cpu);
-    Error *local_err = NULL;
 
-    object_property_set_bool(OBJECT(cpu), true, "realized", &local_err);
-    if (local_err) {
+    object_property_set_bool(OBJECT(cpu), true, "realized", errp);
+    if (*errp) {
         goto error;
     }
 
@@ -237,8 +236,8 @@ static void spapr_realize_vcpu(PowerPCCPU *cpu, SpaprMachineState *spapr,
     qemu_register_reset(spapr_cpu_reset, cpu);
     spapr_cpu_reset(cpu);
 
-    spapr->irq->cpu_intc_create(spapr, cpu, &local_err);
-    if (local_err) {
+    spapr->irq->cpu_intc_create(spapr, cpu, errp);
+    if (*errp) {
         goto error_unregister;
     }
 
@@ -253,7 +252,6 @@ error_unregister:
     qemu_unregister_reset(spapr_cpu_reset, cpu);
     cpu_remove_sync(CPU(cpu));
 error:
-    error_propagate(errp, local_err);
 }
 
 static PowerPCCPU *spapr_create_vcpu(SpaprCpuCore *sc, int i, Error **errp)
@@ -264,24 +262,23 @@ static PowerPCCPU *spapr_create_vcpu(SpaprCpuCore *sc, int i, Error **errp)
     char *id;
     CPUState *cs;
     PowerPCCPU *cpu;
-    Error *local_err = NULL;
 
     obj = object_new(scc->cpu_type);
 
     cs = CPU(obj);
     cpu = POWERPC_CPU(obj);
     cs->cpu_index = cc->core_id + i;
-    spapr_set_vcpu_id(cpu, cs->cpu_index, &local_err);
-    if (local_err) {
+    spapr_set_vcpu_id(cpu, cs->cpu_index, errp);
+    if (*errp) {
         goto err;
     }
 
     cpu->node_id = sc->node_id;
 
     id = g_strdup_printf("thread[%d]", i);
-    object_property_add_child(OBJECT(sc), id, obj, &local_err);
+    object_property_add_child(OBJECT(sc), id, obj, errp);
     g_free(id);
-    if (local_err) {
+    if (*errp) {
         goto err;
     }
 
@@ -292,7 +289,6 @@ static PowerPCCPU *spapr_create_vcpu(SpaprCpuCore *sc, int i, Error **errp)
 
 err:
     object_unref(obj);
-    error_propagate(errp, local_err);
     return NULL;
 }
 
@@ -315,7 +311,6 @@ static void spapr_cpu_core_realize(DeviceState *dev, Error **errp)
                                                   TYPE_SPAPR_MACHINE);
     SpaprCpuCore *sc = SPAPR_CPU_CORE(OBJECT(dev));
     CPUCore *cc = CPU_CORE(OBJECT(dev));
-    Error *local_err = NULL;
     int i, j;
 
     if (!spapr) {
@@ -325,15 +320,15 @@ static void spapr_cpu_core_realize(DeviceState *dev, Error **errp)
 
     sc->threads = g_new(PowerPCCPU *, cc->nr_threads);
     for (i = 0; i < cc->nr_threads; i++) {
-        sc->threads[i] = spapr_create_vcpu(sc, i, &local_err);
-        if (local_err) {
+        sc->threads[i] = spapr_create_vcpu(sc, i, errp);
+        if (*errp) {
             goto err;
         }
     }
 
     for (j = 0; j < cc->nr_threads; j++) {
-        spapr_realize_vcpu(sc->threads[j], spapr, sc, &local_err);
-        if (local_err) {
+        spapr_realize_vcpu(sc->threads[j], spapr, sc, errp);
+        if (*errp) {
             goto err_unrealize;
         }
     }
@@ -348,7 +343,6 @@ err:
         spapr_delete_vcpu(sc->threads[i], sc);
     }
     g_free(sc->threads);
-    error_propagate(errp, local_err);
 }
 
 static Property spapr_cpu_core_properties[] = {
diff --git a/hw/ppc/spapr_drc.c b/hw/ppc/spapr_drc.c
index 62f1a42592..76d81d0238 100644
--- a/hw/ppc/spapr_drc.c
+++ b/hw/ppc/spapr_drc.c
@@ -301,7 +301,6 @@ static void prop_get_fdt(Object *obj, Visitor *v, const char *name,
 {
     SpaprDrc *drc = SPAPR_DR_CONNECTOR(obj);
     QNull *null = NULL;
-    Error *err = NULL;
     int fdt_offset_next, fdt_offset, fdt_depth;
     void *fdt;
 
@@ -326,19 +325,17 @@ static void prop_get_fdt(Object *obj, Visitor *v, const char *name,
         case FDT_BEGIN_NODE:
             fdt_depth++;
             name = fdt_get_name(fdt, fdt_offset, &name_len);
-            visit_start_struct(v, name, NULL, 0, &err);
-            if (err) {
-                error_propagate(errp, err);
+            visit_start_struct(v, name, NULL, 0, errp);
+            if (*errp) {
                 return;
             }
             break;
         case FDT_END_NODE:
             /* shouldn't ever see an FDT_END_NODE before FDT_BEGIN_NODE */
             g_assert(fdt_depth > 0);
-            visit_check_struct(v, &err);
+            visit_check_struct(v, errp);
             visit_end_struct(v, NULL);
-            if (err) {
-                error_propagate(errp, err);
+            if (*errp) {
                 return;
             }
             fdt_depth--;
@@ -347,22 +344,19 @@ static void prop_get_fdt(Object *obj, Visitor *v, const char *name,
             int i;
             prop = fdt_get_property_by_offset(fdt, fdt_offset, &prop_len);
             name = fdt_string(fdt, fdt32_to_cpu(prop->nameoff));
-            visit_start_list(v, name, NULL, 0, &err);
-            if (err) {
-                error_propagate(errp, err);
+            visit_start_list(v, name, NULL, 0, errp);
+            if (*errp) {
                 return;
             }
             for (i = 0; i < prop_len; i++) {
-                visit_type_uint8(v, NULL, (uint8_t *)&prop->data[i], &err);
-                if (err) {
-                    error_propagate(errp, err);
+                visit_type_uint8(v, NULL, (uint8_t *)&prop->data[i], errp);
+                if (*errp) {
                     return;
                 }
             }
-            visit_check_list(v, &err);
+            visit_check_list(v, errp);
             visit_end_list(v, NULL);
-            if (err) {
-                error_propagate(errp, err);
+            if (*errp) {
                 return;
             }
             break;
@@ -489,7 +483,6 @@ static void realize(DeviceState *d, Error **errp)
     Object *root_container;
     gchar *link_name;
     gchar *child_name;
-    Error *err = NULL;
 
     trace_spapr_drc_realize(spapr_drc_index(drc));
     /* NOTE: we do this as part of realize/unrealize due to the fact
@@ -504,11 +497,10 @@ static void realize(DeviceState *d, Error **errp)
     child_name = object_get_canonical_path_component(OBJECT(drc));
     trace_spapr_drc_realize_child(spapr_drc_index(drc), child_name);
     object_property_add_alias(root_container, link_name,
-                              drc->owner, child_name, &err);
+                              drc->owner, child_name, errp);
     g_free(child_name);
     g_free(link_name);
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         return;
     }
     vmstate_register(DEVICE(drc), spapr_drc_index(drc), &vmstate_spapr_drc,
@@ -611,11 +603,9 @@ static void drc_physical_reset(void *opaque)
 static void realize_physical(DeviceState *d, Error **errp)
 {
     SpaprDrcPhysical *drcp = SPAPR_DRC_PHYSICAL(d);
-    Error *local_err = NULL;
 
-    realize(d, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    realize(d, errp);
+    if (*errp) {
         return;
     }
 
@@ -627,11 +617,9 @@ static void realize_physical(DeviceState *d, Error **errp)
 static void unrealize_physical(DeviceState *d, Error **errp)
 {
     SpaprDrcPhysical *drcp = SPAPR_DRC_PHYSICAL(d);
-    Error *local_err = NULL;
 
-    unrealize(d, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    unrealize(d, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/ppc/spapr_irq.c b/hw/ppc/spapr_irq.c
index 06fe2432ba..7f6d2c458d 100644
--- a/hw/ppc/spapr_irq.c
+++ b/hw/ppc/spapr_irq.c
@@ -63,18 +63,16 @@ static void spapr_irq_init_kvm(SpaprMachineState *spapr,
                                   SpaprIrq *irq, Error **errp)
 {
     MachineState *machine = MACHINE(spapr);
-    Error *local_err = NULL;
 
     if (kvm_enabled() && machine_kernel_irqchip_allowed(machine)) {
-        irq->init_kvm(spapr, &local_err);
-        if (local_err && machine_kernel_irqchip_required(machine)) {
-            error_prepend(&local_err,
+        irq->init_kvm(spapr, errp);
+        if (*errp && machine_kernel_irqchip_required(machine)) {
+            error_prepend(errp,
                           "kernel_irqchip requested but unavailable: ");
-            error_propagate(errp, local_err);
             return;
         }
 
-        if (!local_err) {
+        if (!*errp) {
             return;
         }
 
@@ -82,9 +80,9 @@ static void spapr_irq_init_kvm(SpaprMachineState *spapr,
          * We failed to initialize the KVM device, fallback to
          * emulated mode
          */
-        error_prepend(&local_err, "kernel_irqchip allowed but unavailable: ");
-        error_append_hint(&local_err, "Falling back to kernel-irqchip=off\n");
-        warn_report_err(local_err);
+        error_prepend(errp, "kernel_irqchip allowed but unavailable: ");
+        error_append_hint(errp, "Falling back to kernel-irqchip=off\n");
+        warn_report_errp(errp);
     }
 }
 
@@ -96,16 +94,14 @@ static void spapr_irq_init_xics(SpaprMachineState *spapr, int nr_irqs,
                                 Error **errp)
 {
     Object *obj;
-    Error *local_err = NULL;
 
     obj = object_new(TYPE_ICS_SIMPLE);
     object_property_add_child(OBJECT(spapr), "ics", obj, &error_abort);
     object_property_add_const_link(obj, ICS_PROP_XICS, OBJECT(spapr),
                                    &error_fatal);
     object_property_set_int(obj, nr_irqs, "nr-irqs",  &error_fatal);
-    object_property_set_bool(obj, true, "realized", &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_set_bool(obj, true, "realized", errp);
+    if (*errp) {
         return;
     }
 
@@ -183,14 +179,12 @@ static void spapr_irq_print_info_xics(SpaprMachineState *spapr, Monitor *mon)
 static void spapr_irq_cpu_intc_create_xics(SpaprMachineState *spapr,
                                            PowerPCCPU *cpu, Error **errp)
 {
-    Error *local_err = NULL;
     Object *obj;
     SpaprCpuState *spapr_cpu = spapr_cpu_state(cpu);
 
     obj = icp_create(OBJECT(cpu), TYPE_ICP, XICS_FABRIC(spapr),
-                     &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                     errp);
+    if (*errp) {
         return;
     }
 
@@ -218,11 +212,8 @@ static void spapr_irq_set_irq_xics(void *opaque, int srcno, int val)
 
 static void spapr_irq_reset_xics(SpaprMachineState *spapr, Error **errp)
 {
-    Error *local_err = NULL;
-
-    spapr_irq_init_kvm(spapr, &spapr_irq_xics, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    spapr_irq_init_kvm(spapr, &spapr_irq_xics, errp);
+    if (*errp) {
         return;
     }
 }
@@ -340,13 +331,11 @@ static void spapr_irq_print_info_xive(SpaprMachineState *spapr,
 static void spapr_irq_cpu_intc_create_xive(SpaprMachineState *spapr,
                                            PowerPCCPU *cpu, Error **errp)
 {
-    Error *local_err = NULL;
     Object *obj;
     SpaprCpuState *spapr_cpu = spapr_cpu_state(cpu);
 
-    obj = xive_tctx_create(OBJECT(cpu), XIVE_ROUTER(spapr->xive), &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    obj = xive_tctx_create(OBJECT(cpu), XIVE_ROUTER(spapr->xive), errp);
+    if (*errp) {
         return;
     }
 
@@ -367,7 +356,6 @@ static int spapr_irq_post_load_xive(SpaprMachineState *spapr, int version_id)
 static void spapr_irq_reset_xive(SpaprMachineState *spapr, Error **errp)
 {
     CPUState *cs;
-    Error *local_err = NULL;
 
     CPU_FOREACH(cs) {
         PowerPCCPU *cpu = POWERPC_CPU(cs);
@@ -376,9 +364,8 @@ static void spapr_irq_reset_xive(SpaprMachineState *spapr, Error **errp)
         spapr_xive_set_tctx_os_cam(spapr_cpu_state(cpu)->tctx);
     }
 
-    spapr_irq_init_kvm(spapr, &spapr_irq_xive, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    spapr_irq_init_kvm(spapr, &spapr_irq_xive, errp);
+    if (*errp) {
         return;
     }
 
@@ -458,17 +445,13 @@ static SpaprIrq *spapr_irq_current(SpaprMachineState *spapr)
 static void spapr_irq_init_dual(SpaprMachineState *spapr, int nr_irqs,
                                 Error **errp)
 {
-    Error *local_err = NULL;
-
-    spapr_irq_xics.init(spapr, spapr_irq_xics.nr_irqs, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    spapr_irq_xics.init(spapr, spapr_irq_xics.nr_irqs, errp);
+    if (*errp) {
         return;
     }
 
-    spapr_irq_xive.init(spapr, spapr_irq_xive.nr_irqs, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    spapr_irq_xive.init(spapr, spapr_irq_xive.nr_irqs, errp);
+    if (*errp) {
         return;
     }
 }
@@ -476,18 +459,15 @@ static void spapr_irq_init_dual(SpaprMachineState *spapr, int nr_irqs,
 static int spapr_irq_claim_dual(SpaprMachineState *spapr, int irq, bool lsi,
                                 Error **errp)
 {
-    Error *local_err = NULL;
     int ret;
 
-    ret = spapr_irq_xics.claim(spapr, irq, lsi, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ret = spapr_irq_xics.claim(spapr, irq, lsi, errp);
+    if (*errp) {
         return ret;
     }
 
-    ret = spapr_irq_xive.claim(spapr, irq, lsi, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ret = spapr_irq_xive.claim(spapr, irq, lsi, errp);
+    if (*errp) {
         return ret;
     }
 
@@ -520,11 +500,8 @@ static void spapr_irq_dt_populate_dual(SpaprMachineState *spapr,
 static void spapr_irq_cpu_intc_create_dual(SpaprMachineState *spapr,
                                            PowerPCCPU *cpu, Error **errp)
 {
-    Error *local_err = NULL;
-
-    spapr_irq_xive.cpu_intc_create(spapr, cpu, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    spapr_irq_xive.cpu_intc_create(spapr, cpu, errp);
+    if (*errp) {
         return;
     }
 
@@ -549,8 +526,6 @@ static int spapr_irq_post_load_dual(SpaprMachineState *spapr, int version_id)
 
 static void spapr_irq_reset_dual(SpaprMachineState *spapr, Error **errp)
 {
-    Error *local_err = NULL;
-
     /*
      * Deactivate the XIVE MMIOs. The XIVE backend will reenable them
      * if selected.
@@ -559,15 +534,13 @@ static void spapr_irq_reset_dual(SpaprMachineState *spapr, Error **errp)
 
     /* Destroy all KVM devices */
     if (kvm_irqchip_in_kernel()) {
-        xics_kvm_disconnect(spapr, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        xics_kvm_disconnect(spapr, errp);
+        if (*errp) {
             error_prepend(errp, "KVM XICS disconnect failed: ");
             return;
         }
-        kvmppc_xive_disconnect(spapr->xive, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        kvmppc_xive_disconnect(spapr->xive, errp);
+        if (*errp) {
             error_prepend(errp, "KVM XIVE disconnect failed: ");
             return;
         }
@@ -674,7 +647,6 @@ static void spapr_irq_check(SpaprMachineState *spapr, Error **errp)
 void spapr_irq_init(SpaprMachineState *spapr, Error **errp)
 {
     MachineState *machine = MACHINE(spapr);
-    Error *local_err = NULL;
 
     if (machine_kernel_irqchip_split(machine)) {
         error_setg(errp, "kernel_irqchip split mode not supported on pseries");
@@ -687,9 +659,8 @@ void spapr_irq_init(SpaprMachineState *spapr, Error **errp)
         return;
     }
 
-    spapr_irq_check(spapr, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    spapr_irq_check(spapr, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/ppc/spapr_pci.c b/hw/ppc/spapr_pci.c
index 7b71ad7c74..4391d54c6e 100644
--- a/hw/ppc/spapr_pci.c
+++ b/hw/ppc/spapr_pci.c
@@ -1257,15 +1257,13 @@ static void add_drcs(SpaprPhbState *phb, PCIBus *bus, Error **errp)
     Object *owner;
     int i;
     uint8_t chassis;
-    Error *local_err = NULL;
 
     if (!phb->dr_enabled) {
         return;
     }
 
-    chassis = chassis_from_bus(bus, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    chassis = chassis_from_bus(bus, errp);
+    if (*errp) {
         return;
     }
 
@@ -1285,15 +1283,13 @@ static void remove_drcs(SpaprPhbState *phb, PCIBus *bus, Error **errp)
 {
     int i;
     uint8_t chassis;
-    Error *local_err = NULL;
 
     if (!phb->dr_enabled) {
         return;
     }
 
-    chassis = chassis_from_bus(bus, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    chassis = chassis_from_bus(bus, errp);
+    if (*errp) {
         return;
     }
 
@@ -1518,12 +1514,10 @@ static void spapr_pci_bridge_plug(SpaprPhbState *phb,
                                   PCIBridge *bridge,
                                   Error **errp)
 {
-    Error *local_err = NULL;
     PCIBus *bus = pci_bridge_get_sec_bus(bridge);
 
-    add_drcs(phb, bus, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    add_drcs(phb, bus, errp);
+    if (*errp) {
         return;
     }
 }
@@ -1535,7 +1529,6 @@ static void spapr_pci_plug(HotplugHandler *plug_handler,
     PCIDevice *pdev = PCI_DEVICE(plugged_dev);
     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(plugged_dev);
     SpaprDrc *drc = drc_from_dev(phb, pdev);
-    Error *local_err = NULL;
     PCIBus *bus = PCI_BUS(qdev_get_parent_bus(DEVICE(pdev)));
     uint32_t slotnr = PCI_SLOT(pdev->devfn);
 
@@ -1547,18 +1540,17 @@ static void spapr_pci_plug(HotplugHandler *plug_handler,
          * we need to let them know it's not enabled
          */
         if (plugged_dev->hotplugged) {
-            error_setg(&local_err, QERR_BUS_NO_HOTPLUG,
+            error_setg(errp, QERR_BUS_NO_HOTPLUG,
                        object_get_typename(OBJECT(phb)));
         }
-        goto out;
+        return;
     }
 
     g_assert(drc);
 
     if (pc->is_bridge) {
-        spapr_pci_bridge_plug(phb, PCI_BRIDGE(plugged_dev), &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        spapr_pci_bridge_plug(phb, PCI_BRIDGE(plugged_dev), errp);
+        if (*errp) {
             return;
         }
     }
@@ -1569,15 +1561,15 @@ static void spapr_pci_plug(HotplugHandler *plug_handler,
      */
     if (plugged_dev->hotplugged && bus->devices[PCI_DEVFN(slotnr, 0)] &&
         PCI_FUNC(pdev->devfn) != 0) {
-        error_setg(&local_err, "PCI: slot %d function 0 already ocuppied by %s,"
+        error_setg(errp, "PCI: slot %d function 0 already ocuppied by %s,"
                    " additional functions can no longer be exposed to guest.",
                    slotnr, bus->devices[PCI_DEVFN(slotnr, 0)]->name);
-        goto out;
+        return;
     }
 
-    spapr_drc_attach(drc, DEVICE(pdev), &local_err);
-    if (local_err) {
-        goto out;
+    spapr_drc_attach(drc, DEVICE(pdev), errp);
+    if (*errp) {
+        return;
     }
 
     /* If this is function 0, signal hotplug for all the device functions.
@@ -1587,10 +1579,9 @@ static void spapr_pci_plug(HotplugHandler *plug_handler,
         spapr_drc_reset(drc);
     } else if (PCI_FUNC(pdev->devfn) == 0) {
         int i;
-        uint8_t chassis = chassis_from_bus(pci_get_bus(pdev), &local_err);
+        uint8_t chassis = chassis_from_bus(pci_get_bus(pdev), errp);
 
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             return;
         }
 
@@ -1608,21 +1599,16 @@ static void spapr_pci_plug(HotplugHandler *plug_handler,
             }
         }
     }
-
-out:
-    error_propagate(errp, local_err);
 }
 
 static void spapr_pci_bridge_unplug(SpaprPhbState *phb,
                                     PCIBridge *bridge,
                                     Error **errp)
 {
-    Error *local_err = NULL;
     PCIBus *bus = pci_bridge_get_sec_bus(bridge);
 
-    remove_drcs(phb, bus, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    remove_drcs(phb, bus, errp);
+    if (*errp) {
         return;
     }
 }
@@ -1646,10 +1632,8 @@ static void spapr_pci_unplug(HotplugHandler *plug_handler,
     pci_device_reset(PCI_DEVICE(plugged_dev));
 
     if (pc->is_bridge) {
-        Error *local_err = NULL;
-        spapr_pci_bridge_unplug(phb, PCI_BRIDGE(plugged_dev), &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        spapr_pci_bridge_unplug(phb, PCI_BRIDGE(plugged_dev), errp);
+        if (*errp) {
         }
         return;
     }
@@ -1680,11 +1664,9 @@ static void spapr_pci_unplug_request(HotplugHandler *plug_handler,
         SpaprDrcClass *func_drck;
         SpaprDREntitySense state;
         int i;
-        Error *local_err = NULL;
-        uint8_t chassis = chassis_from_bus(pci_get_bus(pdev), &local_err);
+        uint8_t chassis = chassis_from_bus(pci_get_bus(pdev), errp);
 
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             return;
         }
 
@@ -1746,7 +1728,6 @@ static void spapr_phb_unrealize(DeviceState *dev, Error **errp)
     SpaprTceTable *tcet;
     int i;
     const unsigned windows_supported = spapr_phb_windows_supported(sphb);
-    Error *local_err = NULL;
 
     spapr_phb_nvgpu_free(sphb);
 
@@ -1767,9 +1748,8 @@ static void spapr_phb_unrealize(DeviceState *dev, Error **errp)
         }
     }
 
-    remove_drcs(sphb, phb->bus, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    remove_drcs(sphb, phb->bus, errp);
+    if (*errp) {
         return;
     }
 
@@ -1834,7 +1814,6 @@ static void spapr_phb_realize(DeviceState *dev, Error **errp)
     uint64_t msi_window_size = 4096;
     SpaprTceTable *tcet;
     const unsigned windows_supported = spapr_phb_windows_supported(sphb);
-    Error *local_err = NULL;
 
     if (!spapr) {
         error_setg(errp, TYPE_SPAPR_PCI_HOST_BRIDGE " needs a pseries machine");
@@ -1988,9 +1967,9 @@ static void spapr_phb_realize(DeviceState *dev, Error **errp)
         uint32_t irq = SPAPR_IRQ_PCI_LSI + sphb->index * PCI_NUM_PINS + i;
 
         if (smc->legacy_irq_allocation) {
-            irq = spapr_irq_findone(spapr, &local_err);
-            if (local_err) {
-                error_propagate_prepend(errp, local_err,
+            irq = spapr_irq_findone(spapr, errp);
+            if (*errp) {
+                error_propagate_prepend(errp, *errp,
                                         "can't allocate LSIs: ");
                 /*
                  * Older machines will never support PHB hotplug, ie, this is an
@@ -2000,9 +1979,9 @@ static void spapr_phb_realize(DeviceState *dev, Error **errp)
             }
         }
 
-        spapr_irq_claim(spapr, irq, true, &local_err);
-        if (local_err) {
-            error_propagate_prepend(errp, local_err, "can't allocate LSIs: ");
+        spapr_irq_claim(spapr, irq, true, errp);
+        if (*errp) {
+            error_propagate_prepend(errp, *errp, "can't allocate LSIs: ");
             goto unrealize;
         }
 
@@ -2010,9 +1989,8 @@ static void spapr_phb_realize(DeviceState *dev, Error **errp)
     }
 
     /* allocate connectors for child PCI devices */
-    add_drcs(sphb, phb->bus, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    add_drcs(sphb, phb->bus, errp);
+    if (*errp) {
         goto unrealize;
     }
 
diff --git a/hw/ppc/spapr_vio.c b/hw/ppc/spapr_vio.c
index 0803649658..625957a2cd 100644
--- a/hw/ppc/spapr_vio.c
+++ b/hw/ppc/spapr_vio.c
@@ -468,7 +468,6 @@ static void spapr_vio_busdev_realize(DeviceState *qdev, Error **errp)
     SpaprVioDevice *dev = (SpaprVioDevice *)qdev;
     SpaprVioDeviceClass *pc = VIO_SPAPR_DEVICE_GET_CLASS(dev);
     char *id;
-    Error *local_err = NULL;
 
     if (dev->reg != -1) {
         /*
@@ -504,16 +503,14 @@ static void spapr_vio_busdev_realize(DeviceState *qdev, Error **errp)
     dev->irq = spapr_vio_reg_to_irq(dev->reg);
 
     if (SPAPR_MACHINE_GET_CLASS(spapr)->legacy_irq_allocation) {
-        dev->irq = spapr_irq_findone(spapr, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        dev->irq = spapr_irq_findone(spapr, errp);
+        if (*errp) {
             return;
         }
     }
 
-    spapr_irq_claim(spapr, dev->irq, false, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    spapr_irq_claim(spapr, dev->irq, false, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/riscv/riscv_hart.c b/hw/riscv/riscv_hart.c
index 5b98227db6..7e21738bbb 100644
--- a/hw/riscv/riscv_hart.c
+++ b/hw/riscv/riscv_hart.c
@@ -43,17 +43,14 @@ static void riscv_harts_cpu_reset(void *opaque)
 static void riscv_hart_realize(RISCVHartArrayState *s, int idx,
                                char *cpu_type, Error **errp)
 {
-    Error *err = NULL;
-
     object_initialize_child(OBJECT(s), "harts[*]", &s->harts[idx],
                             sizeof(RISCVCPU), cpu_type,
                             &error_abort, NULL);
     s->harts[idx].env.mhartid = s->hartid_base + idx;
     qemu_register_reset(riscv_harts_cpu_reset, &s->harts[idx]);
     object_property_set_bool(OBJECT(&s->harts[idx]), true,
-                             "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+                             "realized", errp);
+    if (*errp) {
         return;
     }
 }
diff --git a/hw/riscv/sifive_e.c b/hw/riscv/sifive_e.c
index 0f9d641a0e..17f19ff338 100644
--- a/hw/riscv/sifive_e.c
+++ b/hw/riscv/sifive_e.c
@@ -136,7 +136,6 @@ static void riscv_sifive_e_soc_realize(DeviceState *dev, Error **errp)
 {
     MachineState *ms = MACHINE(qdev_get_machine());
     const struct MemmapEntry *memmap = sifive_e_memmap;
-    Error *err = NULL;
 
     SiFiveESoCState *s = RISCV_E_SOC(dev);
     MemoryRegion *sys_mem = get_system_memory();
@@ -171,9 +170,8 @@ static void riscv_sifive_e_soc_realize(DeviceState *dev, Error **errp)
 
     /* GPIO */
 
-    object_property_set_bool(OBJECT(&s->gpio), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gpio), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/riscv/sifive_u.c b/hw/riscv/sifive_u.c
index 9f8e84bf2e..7eecf31a3d 100644
--- a/hw/riscv/sifive_u.c
+++ b/hw/riscv/sifive_u.c
@@ -435,7 +435,6 @@ static void riscv_sifive_u_soc_realize(DeviceState *dev, Error **errp)
     char *plic_hart_config;
     size_t plic_hart_config_len;
     int i;
-    Error *err = NULL;
     NICInfo *nd = &nd_table[0];
 
     object_property_set_bool(OBJECT(&s->e_cpus), true, "realized",
@@ -493,10 +492,10 @@ static void riscv_sifive_u_soc_realize(DeviceState *dev, Error **errp)
         memmap[SIFIVE_U_CLINT].size, ms->smp.cpus,
         SIFIVE_SIP_BASE, SIFIVE_TIMECMP_BASE, SIFIVE_TIME_BASE);
 
-    object_property_set_bool(OBJECT(&s->prci), true, "realized", &err);
+    object_property_set_bool(OBJECT(&s->prci), true, "realized", errp);
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->prci), 0, memmap[SIFIVE_U_PRCI].base);
 
-    object_property_set_bool(OBJECT(&s->otp), true, "realized", &err);
+    object_property_set_bool(OBJECT(&s->otp), true, "realized", errp);
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->otp), 0, memmap[SIFIVE_U_OTP].base);
 
     for (i = 0; i < SIFIVE_U_PLIC_NUM_SOURCES; i++) {
@@ -509,9 +508,8 @@ static void riscv_sifive_u_soc_realize(DeviceState *dev, Error **errp)
     }
     object_property_set_int(OBJECT(&s->gem), GEM_REVISION, "revision",
                             &error_abort);
-    object_property_set_bool(OBJECT(&s->gem), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(&s->gem), true, "realized", errp);
+    if (*errp) {
         return;
     }
     sysbus_mmio_map(SYS_BUS_DEVICE(&s->gem), 0, memmap[SIFIVE_U_GEM].base);
diff --git a/hw/s390x/3270-ccw.c b/hw/s390x/3270-ccw.c
index c19a75b9b7..fb954bd952 100644
--- a/hw/s390x/3270-ccw.c
+++ b/hw/s390x/3270-ccw.c
@@ -101,7 +101,6 @@ static void emulated_ccw_3270_realize(DeviceState *ds, Error **errp)
     CcwDevice *cdev = CCW_DEVICE(ds);
     CCWDeviceClass *cdk = CCW_DEVICE_GET_CLASS(cdev);
     SubchDev *sch;
-    Error *err = NULL;
 
     sch = css_create_sch(cdev->devno, errp);
     if (!sch) {
@@ -117,7 +116,7 @@ static void emulated_ccw_3270_realize(DeviceState *ds, Error **errp)
     chpid = css_find_free_chpid(sch->cssid);
 
     if (chpid > MAX_CHPID) {
-        error_setg(&err, "No available chpid to use.");
+        error_setg(errp, "No available chpid to use.");
         goto out_err;
     }
 
@@ -128,20 +127,19 @@ static void emulated_ccw_3270_realize(DeviceState *ds, Error **errp)
     sch->do_subchannel_work = do_subchannel_work_virtual;
     sch->ccw_cb = emulated_ccw_3270_cb;
 
-    ck->init(dev, &err);
-    if (err) {
+    ck->init(dev, errp);
+    if (*errp) {
         goto out_err;
     }
 
-    cdk->realize(cdev, &err);
-    if (err) {
+    cdk->realize(cdev, errp);
+    if (*errp) {
         goto out_err;
     }
 
     return;
 
 out_err:
-    error_propagate(errp, err);
     css_subch_assign(sch->cssid, sch->ssid, sch->schid, sch->devno, NULL);
     cdev->sch = NULL;
     g_free(sch);
diff --git a/hw/s390x/css-bridge.c b/hw/s390x/css-bridge.c
index 15a8ed96de..c423c43e6d 100644
--- a/hw/s390x/css-bridge.c
+++ b/hw/s390x/css-bridge.c
@@ -33,12 +33,10 @@ static void ccw_device_unplug(HotplugHandler *hotplug_dev,
     CcwDevice *ccw_dev = CCW_DEVICE(dev);
     CCWDeviceClass *k = CCW_DEVICE_GET_CLASS(ccw_dev);
     SubchDev *sch = ccw_dev->sch;
-    Error *err = NULL;
 
     if (k->unplug) {
-        k->unplug(hotplug_dev, dev, &err);
-        if (err) {
-            error_propagate(errp, err);
+        k->unplug(hotplug_dev, dev, errp);
+        if (*errp) {
             return;
         }
     }
diff --git a/hw/s390x/css.c b/hw/s390x/css.c
index 844caab408..d201aed5cc 100644
--- a/hw/s390x/css.c
+++ b/hw/s390x/css.c
@@ -2354,7 +2354,6 @@ static void set_css_devid(Object *obj, Visitor *v, const char *name,
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
     CssDevId *dev_id = qdev_get_prop_ptr(dev, prop);
-    Error *local_err = NULL;
     char *str;
     int num, n1, n2;
     unsigned int cssid, ssid, devid;
@@ -2364,9 +2363,8 @@ static void set_css_devid(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/s390x/ipl.c b/hw/s390x/ipl.c
index ca544d64c5..d25f2ca200 100644
--- a/hw/s390x/ipl.c
+++ b/hw/s390x/ipl.c
@@ -115,7 +115,6 @@ static void s390_ipl_realize(DeviceState *dev, Error **errp)
     uint64_t pentry;
     char *magic;
     int kernel_size;
-    Error *err = NULL;
 
     int bios_size;
     char *bios_filename;
@@ -133,8 +132,8 @@ static void s390_ipl_realize(DeviceState *dev, Error **errp)
 
         bios_filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
         if (bios_filename == NULL) {
-            error_setg(&err, "could not find stage1 bootloader");
-            goto error;
+            error_setg(errp, "could not find stage1 bootloader");
+            return;
         }
 
         bios_size = load_elf(bios_filename, NULL,
@@ -153,8 +152,8 @@ static void s390_ipl_realize(DeviceState *dev, Error **errp)
         g_free(bios_filename);
 
         if (bios_size == -1) {
-            error_setg(&err, "could not load bootloader '%s'", bios_name);
-            goto error;
+            error_setg(errp, "could not load bootloader '%s'", bios_name);
+            return;
         }
 
         /* default boot target is the bios */
@@ -168,8 +167,8 @@ static void s390_ipl_realize(DeviceState *dev, Error **errp)
         if (kernel_size < 0) {
             kernel_size = load_image_targphys(ipl->kernel, 0, ram_size);
             if (kernel_size < 0) {
-                error_setg(&err, "could not load kernel '%s'", ipl->kernel);
-                goto error;
+                error_setg(errp, "could not load kernel '%s'", ipl->kernel);
+                return;
             }
             /* if this is Linux use KERN_IMAGE_START */
             magic = rom_ptr(LINUX_MAGIC_ADDR, 6);
@@ -181,8 +180,8 @@ static void s390_ipl_realize(DeviceState *dev, Error **errp)
                 if (ipl_psw) {
                     pentry = be32_to_cpu(*ipl_psw) & 0x7fffffffUL;
                 } else {
-                    error_setg(&err, "Could not get IPL PSW");
-                    goto error;
+                    error_setg(errp, "Could not get IPL PSW");
+                    return;
                 }
             }
         }
@@ -215,8 +214,8 @@ static void s390_ipl_realize(DeviceState *dev, Error **errp)
             initrd_size = load_image_targphys(ipl->initrd, initrd_offset,
                                               ram_size - initrd_offset);
             if (initrd_size == -1) {
-                error_setg(&err, "could not load initrd '%s'", ipl->initrd);
-                goto error;
+                error_setg(errp, "could not load initrd '%s'", ipl->initrd);
+                return;
             }
 
             /*
@@ -238,8 +237,6 @@ static void s390_ipl_realize(DeviceState *dev, Error **errp)
     ipl->compat_start_addr = ipl->start_addr;
     ipl->compat_bios_start_addr = ipl->bios_start_addr;
     qemu_register_reset(qdev_reset_all_fn, dev);
-error:
-    error_propagate(errp, err);
 }
 
 static Property s390_ipl_properties[] = {
diff --git a/hw/s390x/s390-ccw.c b/hw/s390x/s390-ccw.c
index 0c5a5b60bd..0ae1951507 100644
--- a/hw/s390x/s390-ccw.c
+++ b/hw/s390x/s390-ccw.c
@@ -91,14 +91,13 @@ static void s390_ccw_realize(S390CCWDevice *cdev, char *sysfsdev, Error **errp)
     DeviceState *parent = DEVICE(ccw_dev);
     SubchDev *sch;
     int ret;
-    Error *err = NULL;
 
-    s390_ccw_get_dev_info(cdev, sysfsdev, &err);
-    if (err) {
+    s390_ccw_get_dev_info(cdev, sysfsdev, errp);
+    if (*errp) {
         goto out_err_propagate;
     }
 
-    sch = css_create_sch(ccw_dev->devno, &err);
+    sch = css_create_sch(ccw_dev->devno, errp);
     if (!sch) {
         goto out_mdevid_free;
     }
@@ -108,13 +107,13 @@ static void s390_ccw_realize(S390CCWDevice *cdev, char *sysfsdev, Error **errp)
     ccw_dev->sch = sch;
     ret = css_sch_build_schib(sch, &cdev->hostid);
     if (ret) {
-        error_setg_errno(&err, -ret, "%s: Failed to build initial schib",
+        error_setg_errno(errp, -ret, "%s: Failed to build initial schib",
                          __func__);
         goto out_err;
     }
 
-    ck->realize(ccw_dev, &err);
-    if (err) {
+    ck->realize(ccw_dev, errp);
+    if (*errp) {
         goto out_err;
     }
 
@@ -129,7 +128,6 @@ out_err:
 out_mdevid_free:
     g_free(cdev->mdevid);
 out_err_propagate:
-    error_propagate(errp, err);
 }
 
 static void s390_ccw_unrealize(S390CCWDevice *cdev, Error **errp)
diff --git a/hw/s390x/s390-pci-bus.c b/hw/s390x/s390-pci-bus.c
index 963a41c7f5..200b9626dd 100644
--- a/hw/s390x/s390-pci-bus.c
+++ b/hw/s390x/s390-pci-bus.c
@@ -736,7 +736,6 @@ static void s390_pcihost_realize(DeviceState *dev, Error **errp)
     BusState *bus;
     PCIHostState *phb = PCI_HOST_BRIDGE(dev);
     S390pciState *s = S390_PCI_HOST_BRIDGE(dev);
-    Error *local_err = NULL;
 
     DPRINTF("host_init\n");
 
@@ -746,17 +745,15 @@ static void s390_pcihost_realize(DeviceState *dev, Error **errp)
     pci_setup_iommu(b, s390_pci_dma_iommu, s);
 
     bus = BUS(b);
-    qbus_set_hotplug_handler(bus, OBJECT(dev), &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qbus_set_hotplug_handler(bus, OBJECT(dev), errp);
+    if (*errp) {
         return;
     }
     phb->bus = b;
 
     s->bus = S390_PCI_BUS(qbus_create(TYPE_S390_PCI_BUS, dev, NULL));
-    qbus_set_hotplug_handler(BUS(s->bus), OBJECT(dev), &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qbus_set_hotplug_handler(BUS(s->bus), OBJECT(dev), errp);
+    if (*errp) {
         return;
     }
 
@@ -768,8 +765,7 @@ static void s390_pcihost_realize(DeviceState *dev, Error **errp)
     QTAILQ_INIT(&s->zpci_devs);
 
     css_register_io_adapters(CSS_IO_ADAPTER_PCI, true, false,
-                             S390_ADAPTER_SUPPRESSIBLE, &local_err);
-    error_propagate(errp, local_err);
+                             S390_ADAPTER_SUPPRESSIBLE, errp);
 }
 
 static int s390_pci_msix_init(S390PCIBusDevice *pbdev)
@@ -816,7 +812,6 @@ static void s390_pci_msix_free(S390PCIBusDevice *pbdev)
 static S390PCIBusDevice *s390_pci_device_new(S390pciState *s,
                                              const char *target, Error **errp)
 {
-    Error *local_err = NULL;
     DeviceState *dev;
 
     dev = qdev_try_create(BUS(s->bus), TYPE_S390_PCI_DEVICE);
@@ -825,17 +820,17 @@ static S390PCIBusDevice *s390_pci_device_new(S390pciState *s,
         return NULL;
     }
 
-    object_property_set_str(OBJECT(dev), target, "target", &local_err);
-    if (local_err) {
+    object_property_set_str(OBJECT(dev), target, "target", errp);
+    if (*errp) {
         object_unparent(OBJECT(dev));
-        error_propagate_prepend(errp, local_err,
+        error_propagate_prepend(errp, *errp,
                                 "zPCI device could not be created: ");
         return NULL;
     }
-    object_property_set_bool(OBJECT(dev), true, "realized", &local_err);
-    if (local_err) {
+    object_property_set_bool(OBJECT(dev), true, "realized", errp);
+    if (*errp) {
         object_unparent(OBJECT(dev));
-        error_propagate_prepend(errp, local_err,
+        error_propagate_prepend(errp, *errp,
                                 "zPCI device could not be created: ");
         return NULL;
     }
@@ -1208,11 +1203,8 @@ static void s390_pci_device_realize(DeviceState *dev, Error **errp)
     }
 
     if (!zpci->fid_defined) {
-        Error *local_error = NULL;
-
-        zpci->fid = s390_pci_generate_fid(s, &local_error);
-        if (local_error) {
-            error_propagate(errp, local_error);
+        zpci->fid = s390_pci_generate_fid(s, errp);
+        if (*errp) {
             return;
         }
     } else if (s390_pci_find_dev_by_fid(s, zpci->fid)) {
diff --git a/hw/s390x/s390-skeys.c b/hw/s390x/s390-skeys.c
index bd37f39120..6963ff9cde 100644
--- a/hw/s390x/s390-skeys.c
+++ b/hw/s390x/s390-skeys.c
@@ -111,7 +111,6 @@ void qmp_dump_skeys(const char *filename, Error **errp)
     S390SKeysClass *skeyclass = S390_SKEYS_GET_CLASS(ss);
     const uint64_t total_count = ram_size / TARGET_PAGE_SIZE;
     uint64_t handled_count = 0, cur_count;
-    Error *lerr = NULL;
     vaddr cur_gfn = 0;
     uint8_t *buf;
     int ret;
@@ -155,8 +154,8 @@ void qmp_dump_skeys(const char *filename, Error **errp)
         }
 
         /* write keys to stream */
-        write_keys(f, buf, cur_gfn, cur_count, &lerr);
-        if (lerr) {
+        write_keys(f, buf, cur_gfn, cur_count, errp);
+        if (*errp) {
             goto out_free;
         }
 
@@ -165,7 +164,6 @@ void qmp_dump_skeys(const char *filename, Error **errp)
     }
 
 out_free:
-    error_propagate(errp, lerr);
     g_free(buf);
 out:
     fclose(f);
diff --git a/hw/s390x/s390-virtio-ccw.c b/hw/s390x/s390-virtio-ccw.c
index 8bfb6684cb..966de57826 100644
--- a/hw/s390x/s390-virtio-ccw.c
+++ b/hw/s390x/s390-virtio-ccw.c
@@ -62,18 +62,16 @@ static S390CPU *s390x_new_cpu(const char *typename, uint32_t core_id,
                               Error **errp)
 {
     S390CPU *cpu = S390_CPU(object_new(typename));
-    Error *err = NULL;
 
-    object_property_set_int(OBJECT(cpu), core_id, "core-id", &err);
-    if (err != NULL) {
+    object_property_set_int(OBJECT(cpu), core_id, "core-id", errp);
+    if (*errp != NULL) {
         goto out;
     }
-    object_property_set_bool(OBJECT(cpu), true, "realized", &err);
+    object_property_set_bool(OBJECT(cpu), true, "realized", errp);
 
 out:
     object_unref(OBJECT(cpu));
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         cpu = NULL;
     }
     return cpu;
diff --git a/hw/s390x/sclp.c b/hw/s390x/sclp.c
index fac7c3bb6c..5d8778bf2a 100644
--- a/hw/s390x/sclp.c
+++ b/hw/s390x/sclp.c
@@ -271,14 +271,13 @@ static void sclp_realize(DeviceState *dev, Error **errp)
 {
     MachineState *machine = MACHINE(qdev_get_machine());
     SCLPDevice *sclp = SCLP(dev);
-    Error *err = NULL;
     uint64_t hw_limit;
     int ret;
 
     object_property_set_bool(OBJECT(sclp->event_facility), true, "realized",
-                             &err);
-    if (err) {
-        goto out;
+                             errp);
+    if (*errp) {
+        return;
     }
     /*
      * qdev_device_add searches the sysbus for TYPE_SCLP_EVENTS_BUS. As long
@@ -289,14 +288,11 @@ static void sclp_realize(DeviceState *dev, Error **errp)
 
     ret = s390_set_memory_limit(machine->maxram_size, &hw_limit);
     if (ret == -E2BIG) {
-        error_setg(&err, "host supports a maximum of %" PRIu64 " GB",
+        error_setg(errp, "host supports a maximum of %" PRIu64 " GB",
                    hw_limit / GiB);
     } else if (ret) {
-        error_setg(&err, "setting the guest size failed");
+        error_setg(errp, "setting the guest size failed");
     }
-
-out:
-    error_propagate(errp, err);
 }
 
 static void sclp_memory_init(SCLPDevice *sclp)
diff --git a/hw/s390x/tod-kvm.c b/hw/s390x/tod-kvm.c
index 6e21d83181..096966521c 100644
--- a/hw/s390x/tod-kvm.c
+++ b/hw/s390x/tod-kvm.c
@@ -55,8 +55,6 @@ static void kvm_s390_set_tod_raw(const S390TOD *tod, Error **errp)
 
 static void kvm_s390_tod_set(S390TODState *td, const S390TOD *tod, Error **errp)
 {
-    Error *local_err = NULL;
-
     /*
      * Somebody (e.g. migration) set the TOD. We'll store it into KVM to
      * properly detect errors now but take a look at the runstate to decide
@@ -64,9 +62,8 @@ static void kvm_s390_tod_set(S390TODState *td, const S390TOD *tod, Error **errp)
      * is the point where we want to stop the initially running TOD to fire
      * it back up when actually starting the migrated guest.
      */
-    kvm_s390_set_tod_raw(tod, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    kvm_s390_set_tod_raw(tod, errp);
+    if (*errp) {
         return;
     }
 
@@ -108,11 +105,9 @@ static void kvm_s390_tod_realize(DeviceState *dev, Error **errp)
 {
     S390TODState *td = S390_TOD(dev);
     S390TODClass *tdc = S390_TOD_GET_CLASS(td);
-    Error *local_err = NULL;
 
-    tdc->parent_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    tdc->parent_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/s390x/virtio-ccw-crypto.c b/hw/s390x/virtio-ccw-crypto.c
index 086b397ad2..d042e74bcd 100644
--- a/hw/s390x/virtio-ccw-crypto.c
+++ b/hw/s390x/virtio-ccw-crypto.c
@@ -19,12 +19,10 @@ static void virtio_ccw_crypto_realize(VirtioCcwDevice *ccw_dev, Error **errp)
 {
     VirtIOCryptoCcw *dev = VIRTIO_CRYPTO_CCW(ccw_dev);
     DeviceState *vdev = DEVICE(&dev->vdev);
-    Error *err = NULL;
 
     qdev_set_parent_bus(vdev, BUS(&ccw_dev->bus));
-    object_property_set_bool(OBJECT(vdev), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(vdev), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/s390x/virtio-ccw-rng.c b/hw/s390x/virtio-ccw-rng.c
index 854254dd50..20b0e84250 100644
--- a/hw/s390x/virtio-ccw-rng.c
+++ b/hw/s390x/virtio-ccw-rng.c
@@ -20,12 +20,10 @@ static void virtio_ccw_rng_realize(VirtioCcwDevice *ccw_dev, Error **errp)
 {
     VirtIORNGCcw *dev = VIRTIO_RNG_CCW(ccw_dev);
     DeviceState *vdev = DEVICE(&dev->vdev);
-    Error *err = NULL;
 
     qdev_set_parent_bus(vdev, BUS(&ccw_dev->bus));
-    object_property_set_bool(OBJECT(vdev), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(vdev), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/s390x/virtio-ccw.c b/hw/s390x/virtio-ccw.c
index 6580ce5907..7cd1ec4862 100644
--- a/hw/s390x/virtio-ccw.c
+++ b/hw/s390x/virtio-ccw.c
@@ -696,14 +696,13 @@ static void virtio_ccw_device_realize(VirtioCcwDevice *dev, Error **errp)
     CcwDevice *ccw_dev = CCW_DEVICE(dev);
     CCWDeviceClass *ck = CCW_DEVICE_GET_CLASS(ccw_dev);
     SubchDev *sch;
-    Error *err = NULL;
 
     sch = css_create_sch(ccw_dev->devno, errp);
     if (!sch) {
         return;
     }
     if (!virtio_ccw_rev_max(dev) && dev->force_revision_1) {
-        error_setg(&err, "Invalid value of property max_rev "
+        error_setg(errp, "Invalid value of property max_rev "
                    "(is %d expected >= 1)", virtio_ccw_rev_max(dev));
         goto out_err;
     }
@@ -728,21 +727,20 @@ static void virtio_ccw_device_realize(VirtioCcwDevice *dev, Error **errp)
     }
 
     if (k->realize) {
-        k->realize(dev, &err);
-        if (err) {
+        k->realize(dev, errp);
+        if (*errp) {
             goto out_err;
         }
     }
 
-    ck->realize(ccw_dev, &err);
-    if (err) {
+    ck->realize(ccw_dev, errp);
+    if (*errp) {
         goto out_err;
     }
 
     return;
 
 out_err:
-    error_propagate(errp, err);
     css_subch_assign(sch->cssid, sch->ssid, sch->schid, sch->devno, NULL);
     ccw_dev->sch = NULL;
     g_free(sch);
diff --git a/hw/scsi/esp-pci.c b/hw/scsi/esp-pci.c
index d5a1f9e017..966b509ef0 100644
--- a/hw/scsi/esp-pci.c
+++ b/hw/scsi/esp-pci.c
@@ -469,15 +469,13 @@ static void dc390_write_config(PCIDevice *dev,
 static void dc390_scsi_realize(PCIDevice *dev, Error **errp)
 {
     DC390State *pci = DC390(dev);
-    Error *err = NULL;
     uint8_t *contents;
     uint16_t chksum = 0;
     int i;
 
     /* init base class */
-    esp_pci_scsi_realize(dev, &err);
-    if (err) {
-        error_propagate(errp, err);
+    esp_pci_scsi_realize(dev, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/scsi/megasas.c b/hw/scsi/megasas.c
index de9bd20887..8907915f49 100644
--- a/hw/scsi/megasas.c
+++ b/hw/scsi/megasas.c
@@ -2315,7 +2315,6 @@ static void megasas_scsi_realize(PCIDevice *dev, Error **errp)
     MegasasBaseClass *b = MEGASAS_DEVICE_GET_CLASS(s);
     uint8_t *pci_conf;
     int i, bar_type;
-    Error *err = NULL;
     int ret;
 
     pci_conf = dev->config;
@@ -2326,20 +2325,19 @@ static void megasas_scsi_realize(PCIDevice *dev, Error **errp)
     pci_conf[PCI_INTERRUPT_PIN] = 0x01;
 
     if (s->msi != ON_OFF_AUTO_OFF) {
-        ret = msi_init(dev, 0x50, 1, true, false, &err);
+        ret = msi_init(dev, 0x50, 1, true, false, errp);
         /* Any error other than -ENOTSUP(board's MSI support is broken)
          * is a programming error */
         assert(!ret || ret == -ENOTSUP);
         if (ret && s->msi == ON_OFF_AUTO_ON) {
             /* Can't satisfy user's explicit msi=on request, fail */
-            error_append_hint(&err, "You have to use msi=auto (default) or "
-                    "msi=off with this machine type.\n");
-            error_propagate(errp, err);
+            error_append_hint(errp, "You have to use msi=auto (default) or "
+                              "msi=off with this machine type.\n");
             return;
         } else if (ret) {
             /* With msi=auto, we fall back to MSI off silently */
             s->msi = ON_OFF_AUTO_OFF;
-            error_free(err);
+            error_free_errp(errp);
         }
     }
 
diff --git a/hw/scsi/mptsas.c b/hw/scsi/mptsas.c
index b8a4b37cf3..71edc9e38a 100644
--- a/hw/scsi/mptsas.c
+++ b/hw/scsi/mptsas.c
@@ -1273,27 +1273,25 @@ static const struct SCSIBusInfo mptsas_scsi_info = {
 static void mptsas_scsi_realize(PCIDevice *dev, Error **errp)
 {
     MPTSASState *s = MPT_SAS(dev);
-    Error *err = NULL;
     int ret;
 
     dev->config[PCI_LATENCY_TIMER] = 0;
     dev->config[PCI_INTERRUPT_PIN] = 0x01;
 
     if (s->msi != ON_OFF_AUTO_OFF) {
-        ret = msi_init(dev, 0, 1, true, false, &err);
+        ret = msi_init(dev, 0, 1, true, false, errp);
         /* Any error other than -ENOTSUP(board's MSI support is broken)
          * is a programming error */
         assert(!ret || ret == -ENOTSUP);
         if (ret && s->msi == ON_OFF_AUTO_ON) {
             /* Can't satisfy user's explicit msi=on request, fail */
-            error_append_hint(&err, "You have to use msi=auto (default) or "
-                    "msi=off with this machine type.\n");
-            error_propagate(errp, err);
+            error_append_hint(errp, "You have to use msi=auto (default) or "
+                              "msi=off with this machine type.\n");
             return;
         }
-        assert(!err || s->msi == ON_OFF_AUTO_AUTO);
+        assert(!*errp || s->msi == ON_OFF_AUTO_AUTO);
         /* With msi=auto, we fall back to MSI off silently */
-        error_free(err);
+        error_free_errp(errp);
 
         /* Only used for migration.  */
         s->msi_in_use = (ret == 0);
diff --git a/hw/scsi/scsi-bus.c b/hw/scsi/scsi-bus.c
index bccb7cc4c6..c238e8ea2d 100644
--- a/hw/scsi/scsi-bus.c
+++ b/hw/scsi/scsi-bus.c
@@ -157,7 +157,6 @@ static void scsi_qdev_realize(DeviceState *qdev, Error **errp)
     SCSIDevice *dev = SCSI_DEVICE(qdev);
     SCSIBus *bus = DO_UPCAST(SCSIBus, qbus, dev->qdev.parent_bus);
     SCSIDevice *d;
-    Error *local_err = NULL;
 
     if (dev->channel > bus->info->max_channel) {
         error_setg(errp, "bad scsi channel id: %d", dev->channel);
@@ -205,9 +204,8 @@ static void scsi_qdev_realize(DeviceState *qdev, Error **errp)
     }
 
     QTAILQ_INIT(&dev->requests);
-    scsi_device_realize(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    scsi_device_realize(dev, errp);
+    if (*errp) {
         return;
     }
     dev->vmsentry = qdev_add_vm_change_state_handler(DEVICE(dev),
@@ -237,7 +235,6 @@ SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, BlockBackend *blk,
     const char *driver;
     char *name;
     DeviceState *dev;
-    Error *err = NULL;
 
     driver = blk_is_sg(blk) ? "scsi-generic" : "scsi-disk";
     dev = qdev_create(&bus->qbus, driver);
@@ -256,15 +253,13 @@ SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, BlockBackend *blk,
     if (serial && object_property_find(OBJECT(dev), "serial", NULL)) {
         qdev_prop_set_string(dev, "serial", serial);
     }
-    qdev_prop_set_drive(dev, "drive", blk, &err);
-    if (err) {
-        error_propagate(errp, err);
+    qdev_prop_set_drive(dev, "drive", blk, errp);
+    if (*errp) {
         object_unparent(OBJECT(dev));
         return NULL;
     }
-    object_property_set_bool(OBJECT(dev), share_rw, "share-rw", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(dev), share_rw, "share-rw", errp);
+    if (*errp != NULL) {
         object_unparent(OBJECT(dev));
         return NULL;
     }
@@ -272,9 +267,8 @@ SCSIDevice *scsi_bus_legacy_add_drive(SCSIBus *bus, BlockBackend *blk,
     qdev_prop_set_enum(dev, "rerror", rerror);
     qdev_prop_set_enum(dev, "werror", werror);
 
-    object_property_set_bool(OBJECT(dev), true, "realized", &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(dev), true, "realized", errp);
+    if (*errp != NULL) {
         object_unparent(OBJECT(dev));
         return NULL;
     }
diff --git a/hw/scsi/scsi-disk.c b/hw/scsi/scsi-disk.c
index 915641a0f1..bc6306d38e 100644
--- a/hw/scsi/scsi-disk.c
+++ b/hw/scsi/scsi-disk.c
@@ -2456,12 +2456,10 @@ static void scsi_cd_realize(SCSIDevice *dev, Error **errp)
 static void scsi_disk_realize(SCSIDevice *dev, Error **errp)
 {
     DriveInfo *dinfo;
-    Error *local_err = NULL;
 
     if (!dev->conf.blk) {
-        scsi_realize(dev, &local_err);
-        assert(local_err);
-        error_propagate(errp, local_err);
+        scsi_realize(dev, errp);
+        assert(*errp);
         return;
     }
 
diff --git a/hw/scsi/vhost-scsi.c b/hw/scsi/vhost-scsi.c
index c693fc748a..91783a91f7 100644
--- a/hw/scsi/vhost-scsi.c
+++ b/hw/scsi/vhost-scsi.c
@@ -167,7 +167,6 @@ static void vhost_scsi_realize(DeviceState *dev, Error **errp)
 {
     VirtIOSCSICommon *vs = VIRTIO_SCSI_COMMON(dev);
     VHostSCSICommon *vsc = VHOST_SCSI_COMMON(dev);
-    Error *err = NULL;
     int vhostfd = -1;
     int ret;
 
@@ -195,9 +194,8 @@ static void vhost_scsi_realize(DeviceState *dev, Error **errp)
                                vhost_dummy_handle_output,
                                vhost_dummy_handle_output,
                                vhost_dummy_handle_output,
-                               &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+                               errp);
+    if (*errp != NULL) {
         goto close_fd;
     }
 
@@ -207,9 +205,8 @@ static void vhost_scsi_realize(DeviceState *dev, Error **errp)
                 "When external environment supports it (Orchestrator migrates "
                 "target SCSI device state or use shared storage over network), "
                 "set 'migratable' property to true to enable migration.");
-        migrate_add_blocker(vsc->migration_blocker, &err);
-        if (err) {
-            error_propagate(errp, err);
+        migrate_add_blocker(vsc->migration_blocker, errp);
+        if (*errp) {
             error_free(vsc->migration_blocker);
             goto free_virtio;
         }
diff --git a/hw/scsi/vhost-user-scsi.c b/hw/scsi/vhost-user-scsi.c
index 6a6c15dd32..c211dc5998 100644
--- a/hw/scsi/vhost-user-scsi.c
+++ b/hw/scsi/vhost-user-scsi.c
@@ -72,7 +72,6 @@ static void vhost_user_scsi_realize(DeviceState *dev, Error **errp)
     VHostUserSCSI *s = VHOST_USER_SCSI(dev);
     VHostSCSICommon *vsc = VHOST_SCSI_COMMON(s);
     struct vhost_virtqueue *vqs = NULL;
-    Error *err = NULL;
     int ret;
 
     if (!vs->conf.chardev.chr) {
@@ -82,9 +81,8 @@ static void vhost_user_scsi_realize(DeviceState *dev, Error **errp)
 
     virtio_scsi_common_realize(dev, vhost_dummy_handle_output,
                                vhost_dummy_handle_output,
-                               vhost_dummy_handle_output, &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+                               vhost_dummy_handle_output, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/hw/scsi/virtio-scsi.c b/hw/scsi/virtio-scsi.c
index ee52aa7d17..aab0b318e7 100644
--- a/hw/scsi/virtio-scsi.c
+++ b/hw/scsi/virtio-scsi.c
@@ -907,15 +907,13 @@ static void virtio_scsi_device_realize(DeviceState *dev, Error **errp)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
     VirtIOSCSI *s = VIRTIO_SCSI(dev);
-    Error *err = NULL;
 
     virtio_scsi_common_realize(dev,
                                virtio_scsi_handle_ctrl,
                                virtio_scsi_handle_event,
                                virtio_scsi_handle_cmd,
-                               &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+                               errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/hw/sd/milkymist-memcard.c b/hw/sd/milkymist-memcard.c
index 926e1af475..8ac2c84515 100644
--- a/hw/sd/milkymist-memcard.c
+++ b/hw/sd/milkymist-memcard.c
@@ -269,7 +269,6 @@ static void milkymist_memcard_realize(DeviceState *dev, Error **errp)
     DeviceState *carddev;
     BlockBackend *blk;
     DriveInfo *dinfo;
-    Error *err = NULL;
 
     qbus_create_inplace(&s->sdbus, sizeof(s->sdbus), TYPE_SD_BUS,
                         dev, "sd-bus");
@@ -279,10 +278,11 @@ static void milkymist_memcard_realize(DeviceState *dev, Error **errp)
     dinfo = drive_get_next(IF_SD);
     blk = dinfo ? blk_by_legacy_dinfo(dinfo) : NULL;
     carddev = qdev_create(BUS(&s->sdbus), TYPE_SD_CARD);
-    qdev_prop_set_drive(carddev, "drive", blk, &err);
-    object_property_set_bool(OBJECT(carddev), true, "realized", &err);
-    if (err) {
-        error_setg(errp, "failed to init SD card: %s", error_get_pretty(err));
+    qdev_prop_set_drive(carddev, "drive", blk, errp);
+    object_property_set_bool(OBJECT(carddev), true, "realized", errp);
+    if (*errp) {
+        error_setg(errp, "failed to init SD card: %s",
+                   error_get_pretty(*errp));
         return;
     }
     s->enabled = blk && blk_is_inserted(blk);
diff --git a/hw/sd/sdhci-pci.c b/hw/sd/sdhci-pci.c
index 2c8d8f59b5..27470a1a8f 100644
--- a/hw/sd/sdhci-pci.c
+++ b/hw/sd/sdhci-pci.c
@@ -30,12 +30,10 @@ static Property sdhci_pci_properties[] = {
 static void sdhci_pci_realize(PCIDevice *dev, Error **errp)
 {
     SDHCIState *s = PCI_SDHCI(dev);
-    Error *local_err = NULL;
 
     sdhci_initfn(s);
-    sdhci_common_realize(s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    sdhci_common_realize(s, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/sd/sdhci.c b/hw/sd/sdhci.c
index e08ec3e398..f95a49619d 100644
--- a/hw/sd/sdhci.c
+++ b/hw/sd/sdhci.c
@@ -1293,8 +1293,6 @@ static const MemoryRegionOps sdhci_mmio_ops = {
 
 static void sdhci_init_readonly_registers(SDHCIState *s, Error **errp)
 {
-    Error *local_err = NULL;
-
     switch (s->sd_spec_version) {
     case 2 ... 3:
         break;
@@ -1304,9 +1302,8 @@ static void sdhci_init_readonly_registers(SDHCIState *s, Error **errp)
     }
     s->version = (SDHC_HCVER_VENDOR << 8) | (s->sd_spec_version - 1);
 
-    sdhci_check_capareg(s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    sdhci_check_capareg(s, errp);
+    if (*errp) {
         return;
     }
 }
@@ -1337,11 +1334,8 @@ void sdhci_uninitfn(SDHCIState *s)
 
 void sdhci_common_realize(SDHCIState *s, Error **errp)
 {
-    Error *local_err = NULL;
-
-    sdhci_init_readonly_registers(s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    sdhci_init_readonly_registers(s, errp);
+    if (*errp) {
         return;
     }
     s->buf_maxsz = sdhci_get_fifolen(s);
@@ -1463,11 +1457,9 @@ static void sdhci_sysbus_realize(DeviceState *dev, Error ** errp)
 {
     SDHCIState *s = SYSBUS_SDHCI(dev);
     SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
-    Error *local_err = NULL;
 
-    sdhci_common_realize(s, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    sdhci_common_realize(s, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/sd/ssi-sd.c b/hw/sd/ssi-sd.c
index 91db069212..1810d89f31 100644
--- a/hw/sd/ssi-sd.c
+++ b/hw/sd/ssi-sd.c
@@ -244,7 +244,6 @@ static void ssi_sd_realize(SSISlave *d, Error **errp)
     ssi_sd_state *s = FROM_SSI_SLAVE(ssi_sd_state, d);
     DeviceState *carddev;
     DriveInfo *dinfo;
-    Error *err = NULL;
 
     qbus_create_inplace(&s->sdbus, sizeof(s->sdbus), TYPE_SD_BUS,
                         DEVICE(d), "sd-bus");
@@ -254,12 +253,14 @@ static void ssi_sd_realize(SSISlave *d, Error **errp)
     dinfo = drive_get_next(IF_SD);
     carddev = qdev_create(BUS(&s->sdbus), TYPE_SD_CARD);
     if (dinfo) {
-        qdev_prop_set_drive(carddev, "drive", blk_by_legacy_dinfo(dinfo), &err);
+        qdev_prop_set_drive(carddev, "drive", blk_by_legacy_dinfo(dinfo),
+                            errp);
     }
-    object_property_set_bool(OBJECT(carddev), true, "spi", &err);
-    object_property_set_bool(OBJECT(carddev), true, "realized", &err);
-    if (err) {
-        error_setg(errp, "failed to init SD card: %s", error_get_pretty(err));
+    object_property_set_bool(OBJECT(carddev), true, "spi", errp);
+    object_property_set_bool(OBJECT(carddev), true, "realized", errp);
+    if (*errp) {
+        error_setg(errp, "failed to init SD card: %s",
+                   error_get_pretty(*errp));
         return;
     }
 }
diff --git a/hw/smbios/smbios.c b/hw/smbios/smbios.c
index 11d476c4a2..50375639dc 100644
--- a/hw/smbios/smbios.c
+++ b/hw/smbios/smbios.c
@@ -954,7 +954,6 @@ static void save_opt_list(size_t *ndest, const char ***dest,
 
 void smbios_entry_add(QemuOpts *opts, Error **errp)
 {
-    Error *err = NULL;
     const char *val;
 
     assert(!smbios_immutable);
@@ -965,9 +964,8 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
         int size;
         struct smbios_table *table; /* legacy mode only */
 
-        qemu_opts_validate(opts, qemu_smbios_file_opts, &err);
-        if (err) {
-            error_propagate(errp, err);
+        qemu_opts_validate(opts, qemu_smbios_file_opts, errp);
+        if (*errp) {
             return;
         }
 
@@ -1052,9 +1050,8 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
 
         switch (type) {
         case 0:
-            qemu_opts_validate(opts, qemu_smbios_type0_opts, &err);
-            if (err) {
-                error_propagate(errp, err);
+            qemu_opts_validate(opts, qemu_smbios_type0_opts, errp);
+            if (*errp) {
                 return;
             }
             save_opt(&type0.vendor, opts, "vendor");
@@ -1072,9 +1069,8 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
             }
             return;
         case 1:
-            qemu_opts_validate(opts, qemu_smbios_type1_opts, &err);
-            if (err) {
-                error_propagate(errp, err);
+            qemu_opts_validate(opts, qemu_smbios_type1_opts, errp);
+            if (*errp) {
                 return;
             }
             save_opt(&type1.manufacturer, opts, "manufacturer");
@@ -1094,9 +1090,8 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
             }
             return;
         case 2:
-            qemu_opts_validate(opts, qemu_smbios_type2_opts, &err);
-            if (err) {
-                error_propagate(errp, err);
+            qemu_opts_validate(opts, qemu_smbios_type2_opts, errp);
+            if (*errp) {
                 return;
             }
             save_opt(&type2.manufacturer, opts, "manufacturer");
@@ -1107,9 +1102,8 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
             save_opt(&type2.location, opts, "location");
             return;
         case 3:
-            qemu_opts_validate(opts, qemu_smbios_type3_opts, &err);
-            if (err) {
-                error_propagate(errp, err);
+            qemu_opts_validate(opts, qemu_smbios_type3_opts, errp);
+            if (*errp) {
                 return;
             }
             save_opt(&type3.manufacturer, opts, "manufacturer");
@@ -1119,9 +1113,8 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
             save_opt(&type3.sku, opts, "sku");
             return;
         case 4:
-            qemu_opts_validate(opts, qemu_smbios_type4_opts, &err);
-            if (err) {
-                error_propagate(errp, err);
+            qemu_opts_validate(opts, qemu_smbios_type4_opts, errp);
+            if (*errp) {
                 return;
             }
             save_opt(&type4.sock_pfx, opts, "sock_pfx");
@@ -1132,17 +1125,15 @@ void smbios_entry_add(QemuOpts *opts, Error **errp)
             save_opt(&type4.part, opts, "part");
             return;
         case 11:
-            qemu_opts_validate(opts, qemu_smbios_type11_opts, &err);
-            if (err) {
-                error_propagate(errp, err);
+            qemu_opts_validate(opts, qemu_smbios_type11_opts, errp);
+            if (*errp) {
                 return;
             }
             save_opt_list(&type11.nvalues, &type11.values, opts, "value");
             return;
         case 17:
-            qemu_opts_validate(opts, qemu_smbios_type17_opts, &err);
-            if (err) {
-                error_propagate(errp, err);
+            qemu_opts_validate(opts, qemu_smbios_type17_opts, errp);
+            if (*errp) {
                 return;
             }
             save_opt(&type17.loc_pfx, opts, "loc_pfx");
diff --git a/hw/sparc/sun4m.c b/hw/sparc/sun4m.c
index 6c5a17a020..806238798b 100644
--- a/hw/sparc/sun4m.c
+++ b/hw/sparc/sun4m.c
@@ -603,12 +603,10 @@ static void idreg_realize(DeviceState *ds, Error **errp)
 {
     IDRegState *s = MACIO_ID_REGISTER(ds);
     SysBusDevice *dev = SYS_BUS_DEVICE(ds);
-    Error *local_err = NULL;
 
     memory_region_init_ram_nomigrate(&s->mem, OBJECT(ds), "sun4m.idreg",
-                                     sizeof(idreg_data), &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                     sizeof(idreg_data), errp);
+    if (*errp) {
         return;
     }
 
@@ -657,12 +655,10 @@ static void afx_realize(DeviceState *ds, Error **errp)
 {
     AFXState *s = TCX_AFX(ds);
     SysBusDevice *dev = SYS_BUS_DEVICE(ds);
-    Error *local_err = NULL;
 
     memory_region_init_ram_nomigrate(&s->mem, OBJECT(ds), "sun4m.afx", 4,
-                                     &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                     errp);
+    if (*errp) {
         return;
     }
 
@@ -739,12 +735,10 @@ static void prom_realize(DeviceState *ds, Error **errp)
 {
     PROMState *s = OPENPROM(ds);
     SysBusDevice *dev = SYS_BUS_DEVICE(ds);
-    Error *local_err = NULL;
 
     memory_region_init_ram_nomigrate(&s->prom, OBJECT(ds), "sun4m.prom",
-                                     PROM_SIZE_MAX, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                     PROM_SIZE_MAX, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/sparc64/sun4u.c b/hw/sparc64/sun4u.c
index 1ded2a4c9a..9f1043f58e 100644
--- a/hw/sparc64/sun4u.c
+++ b/hw/sparc64/sun4u.c
@@ -457,12 +457,10 @@ static void prom_realize(DeviceState *ds, Error **errp)
 {
     PROMState *s = OPENPROM(ds);
     SysBusDevice *dev = SYS_BUS_DEVICE(ds);
-    Error *local_err = NULL;
 
     memory_region_init_ram_nomigrate(&s->prom, OBJECT(ds), "sun4u.prom",
-                                     PROM_SIZE_MAX, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                     PROM_SIZE_MAX, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/timer/aspeed_timer.c b/hw/timer/aspeed_timer.c
index 2bda826882..0ef8669aa6 100644
--- a/hw/timer/aspeed_timer.c
+++ b/hw/timer/aspeed_timer.c
@@ -486,11 +486,11 @@ static void aspeed_timer_realize(DeviceState *dev, Error **errp)
     SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
     AspeedTimerCtrlState *s = ASPEED_TIMER(dev);
     Object *obj;
-    Error *err = NULL;
 
-    obj = object_property_get_link(OBJECT(dev), "scu", &err);
+    obj = object_property_get_link(OBJECT(dev), "scu", errp);
     if (!obj) {
-        error_propagate_prepend(errp, err, "required link 'scu' not found: ");
+        error_propagate_prepend(errp, *errp,
+                                "required link 'scu' not found: ");
         return;
     }
     s->scu = ASPEED_SCU(obj);
diff --git a/hw/tpm/tpm_util.c b/hw/tpm/tpm_util.c
index 62b091f0c0..4e30235c5d 100644
--- a/hw/tpm/tpm_util.c
+++ b/hw/tpm/tpm_util.c
@@ -48,7 +48,6 @@ static void set_tpm(Object *obj, Visitor *v, const char *name, void *opaque,
                     Error **errp)
 {
     DeviceState *dev = DEVICE(obj);
-    Error *local_err = NULL;
     Property *prop = opaque;
     TPMBackend *s, **be = qdev_get_prop_ptr(dev, prop);
     char *str;
@@ -58,9 +57,8 @@ static void set_tpm(Object *obj, Visitor *v, const char *name, void *opaque,
         return;
     }
 
-    visit_type_str(v, name, &str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &str, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/usb/bus.c b/hw/usb/bus.c
index a6522f5429..8517f496fd 100644
--- a/hw/usb/bus.c
+++ b/hw/usb/bus.c
@@ -241,7 +241,6 @@ void usb_device_free_streams(USBDevice *dev, USBEndpoint **eps, int nr_eps)
 static void usb_qdev_realize(DeviceState *qdev, Error **errp)
 {
     USBDevice *dev = USB_DEVICE(qdev);
-    Error *local_err = NULL;
 
     pstrcpy(dev->product_desc, sizeof(dev->product_desc),
             usb_device_get_product_desc(dev));
@@ -249,24 +248,21 @@ static void usb_qdev_realize(DeviceState *qdev, Error **errp)
     QLIST_INIT(&dev->strings);
     usb_ep_init(dev);
 
-    usb_claim_port(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    usb_claim_port(dev, errp);
+    if (*errp) {
         return;
     }
 
-    usb_device_realize(dev, &local_err);
-    if (local_err) {
+    usb_device_realize(dev, errp);
+    if (*errp) {
         usb_release_port(dev);
-        error_propagate(errp, local_err);
         return;
     }
 
     if (dev->auto_attach) {
-        usb_device_attach(dev, &local_err);
-        if (local_err) {
+        usb_device_attach(dev, errp);
+        if (*errp) {
             usb_qdev_unrealize(qdev, NULL);
-            error_propagate(errp, local_err);
             return;
         }
     }
@@ -325,7 +321,6 @@ USBDevice *usb_create(USBBus *bus, const char *name)
 static USBDevice *usb_try_create_simple(USBBus *bus, const char *name,
                                         Error **errp)
 {
-    Error *err = NULL;
     USBDevice *dev;
 
     dev = USB_DEVICE(qdev_try_create(&bus->qbus, name));
@@ -333,9 +328,9 @@ static USBDevice *usb_try_create_simple(USBBus *bus, const char *name,
         error_setg(errp, "Failed to create USB device '%s'", name);
         return NULL;
     }
-    object_property_set_bool(OBJECT(dev), true, "realized", &err);
-    if (err) {
-        error_propagate_prepend(errp, err,
+    object_property_set_bool(OBJECT(dev), true, "realized", errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "Failed to initialize USB device '%s': ",
                                 name);
         return NULL;
@@ -533,11 +528,9 @@ void usb_check_attach(USBDevice *dev, Error **errp)
 void usb_device_attach(USBDevice *dev, Error **errp)
 {
     USBPort *port = dev->port;
-    Error *local_err = NULL;
 
-    usb_check_attach(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    usb_check_attach(dev, errp);
+    if (*errp) {
         return;
     }
 
@@ -732,15 +725,13 @@ static bool usb_get_attached(Object *obj, Error **errp)
 static void usb_set_attached(Object *obj, bool value, Error **errp)
 {
     USBDevice *dev = USB_DEVICE(obj);
-    Error *err = NULL;
 
     if (dev->attached == value) {
         return;
     }
 
     if (value) {
-        usb_device_attach(dev, &err);
-        error_propagate(errp, err);
+        usb_device_attach(dev, errp);
     } else {
         usb_device_detach(dev);
     }
diff --git a/hw/usb/dev-serial.c b/hw/usb/dev-serial.c
index 45cc74128a..d6ff55baf6 100644
--- a/hw/usb/dev-serial.c
+++ b/hw/usb/dev-serial.c
@@ -485,7 +485,6 @@ static void usb_serial_event(void *opaque, int event)
 static void usb_serial_realize(USBDevice *dev, Error **errp)
 {
     USBSerialState *s = USB_SERIAL_DEV(dev);
-    Error *local_err = NULL;
 
     usb_desc_create_serial(dev);
     usb_desc_init(dev);
@@ -496,9 +495,8 @@ static void usb_serial_realize(USBDevice *dev, Error **errp)
         return;
     }
 
-    usb_check_attach(dev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    usb_check_attach(dev, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/usb/dev-smartcard-reader.c b/hw/usb/dev-smartcard-reader.c
index 4568db2568..cbdf2d9658 100644
--- a/hw/usb/dev-smartcard-reader.c
+++ b/hw/usb/dev-smartcard-reader.c
@@ -1275,15 +1275,13 @@ static void ccid_card_unrealize(DeviceState *qdev, Error **errp)
     CCIDCardClass *cc = CCID_CARD_GET_CLASS(card);
     USBDevice *dev = USB_DEVICE(qdev->parent_bus->parent);
     USBCCIDState *s = USB_CCID_DEV(dev);
-    Error *local_err = NULL;
 
     if (ccid_card_inserted(s)) {
         ccid_card_card_removed(card);
     }
     if (cc->unrealize) {
-        cc->unrealize(card, &local_err);
-        if (local_err != NULL) {
-            error_propagate(errp, local_err);
+        cc->unrealize(card, errp);
+        if (*errp != NULL) {
             return;
         }
     }
@@ -1296,7 +1294,6 @@ static void ccid_card_realize(DeviceState *qdev, Error **errp)
     CCIDCardClass *cc = CCID_CARD_GET_CLASS(card);
     USBDevice *dev = USB_DEVICE(qdev->parent_bus->parent);
     USBCCIDState *s = USB_CCID_DEV(dev);
-    Error *local_err = NULL;
 
     if (card->slot != 0) {
         error_setg(errp, "usb-ccid supports one slot, can't add %d",
@@ -1308,9 +1305,8 @@ static void ccid_card_realize(DeviceState *qdev, Error **errp)
         return;
     }
     if (cc->realize) {
-        cc->realize(card, &local_err);
-        if (local_err != NULL) {
-            error_propagate(errp, local_err);
+        cc->realize(card, errp);
+        if (*errp != NULL) {
             return;
         }
     }
diff --git a/hw/usb/dev-storage.c b/hw/usb/dev-storage.c
index 8545193488..cd670f8e44 100644
--- a/hw/usb/dev-storage.c
+++ b/hw/usb/dev-storage.c
@@ -720,16 +720,15 @@ static void usb_msd_set_bootindex(Object *obj, Visitor *v, const char *name,
     USBDevice *dev = USB_DEVICE(obj);
     MSDState *s = USB_STORAGE_DEV(dev);
     int32_t boot_index;
-    Error *local_err = NULL;
 
-    visit_type_int32(v, name, &boot_index, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_int32(v, name, &boot_index, errp);
+    if (*errp) {
+        return;
     }
     /* check whether bootindex is present in fw_boot_order list  */
-    check_boot_index(boot_index, &local_err);
-    if (local_err) {
-        goto out;
+    check_boot_index(boot_index, errp);
+    if (*errp) {
+        return;
     }
     /* change bootindex to a new one */
     s->conf.bootindex = boot_index;
@@ -738,9 +737,6 @@ static void usb_msd_set_bootindex(Object *obj, Visitor *v, const char *name,
         object_property_set_int(OBJECT(s->scsi_dev), boot_index, "bootindex",
                                 &error_abort);
     }
-
-out:
-    error_propagate(errp, local_err);
 }
 
 static const TypeInfo usb_storage_dev_type_info = {
diff --git a/hw/usb/hcd-ohci-pci.c b/hw/usb/hcd-ohci-pci.c
index c052f10521..be76b441c4 100644
--- a/hw/usb/hcd-ohci-pci.c
+++ b/hw/usb/hcd-ohci-pci.c
@@ -60,7 +60,6 @@ static void ohci_pci_die(struct OHCIState *ohci)
 
 static void usb_ohci_realize_pci(PCIDevice *dev, Error **errp)
 {
-    Error *err = NULL;
     OHCIPCIState *ohci = PCI_OHCI(dev);
 
     dev->config[PCI_CLASS_PROG] = 0x10; /* OHCI */
@@ -68,9 +67,8 @@ static void usb_ohci_realize_pci(PCIDevice *dev, Error **errp)
 
     usb_ohci_init(&ohci->state, DEVICE(dev), ohci->num_ports, 0,
                   ohci->masterbus, ohci->firstport,
-                  pci_get_address_space(dev), ohci_pci_die, &err);
-    if (err) {
-        error_propagate(errp, err);
+                  pci_get_address_space(dev), ohci_pci_die, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/usb/hcd-ohci.c b/hw/usb/hcd-ohci.c
index 145ee21fd6..14e002e4b5 100644
--- a/hw/usb/hcd-ohci.c
+++ b/hw/usb/hcd-ohci.c
@@ -1795,7 +1795,6 @@ void usb_ohci_init(OHCIState *ohci, DeviceState *dev, uint32_t num_ports,
                    uint32_t firstport, AddressSpace *as,
                    void (*ohci_die_fn)(struct OHCIState *), Error **errp)
 {
-    Error *err = NULL;
     int i;
 
     ohci->as = as;
@@ -1831,9 +1830,8 @@ void usb_ohci_init(OHCIState *ohci, DeviceState *dev, uint32_t num_ports,
         usb_register_companion(masterbus, ports, num_ports,
                                firstport, ohci, &ohci_port_ops,
                                USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL,
-                               &err);
-        if (err) {
-            error_propagate(errp, err);
+                               errp);
+        if (*errp) {
             return;
         }
     } else {
@@ -1889,13 +1887,11 @@ static void ohci_realize_pxa(DeviceState *dev, Error **errp)
 {
     OHCISysBusState *s = SYSBUS_OHCI(dev);
     SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
-    Error *err = NULL;
 
     usb_ohci_init(&s->ohci, dev, s->num_ports, s->dma_offset,
                   s->masterbus, s->firstport,
-                  &address_space_memory, ohci_sysbus_die, &err);
-    if (err) {
-        error_propagate(errp, err);
+                  &address_space_memory, ohci_sysbus_die, errp);
+    if (*errp) {
         return;
     }
     sysbus_init_irq(sbd, &s->ohci.irq);
diff --git a/hw/usb/hcd-uhci.c b/hw/usb/hcd-uhci.c
index 23507ad3b5..6f6ee790fd 100644
--- a/hw/usb/hcd-uhci.c
+++ b/hw/usb/hcd-uhci.c
@@ -1213,7 +1213,6 @@ static USBBusOps uhci_bus_ops = {
 
 static void usb_uhci_common_realize(PCIDevice *dev, Error **errp)
 {
-    Error *err = NULL;
     PCIDeviceClass *pc = PCI_DEVICE_GET_CLASS(dev);
     UHCIPCIDeviceClass *u = container_of(pc, UHCIPCIDeviceClass, parent_class);
     UHCIState *s = UHCI(dev);
@@ -1234,9 +1233,8 @@ static void usb_uhci_common_realize(PCIDevice *dev, Error **errp)
         usb_register_companion(s->masterbus, ports, NB_PORTS,
                                s->firstport, s, &uhci_port_ops,
                                USB_SPEED_MASK_LOW | USB_SPEED_MASK_FULL,
-                               &err);
-        if (err) {
-            error_propagate(errp, err);
+                               errp);
+        if (*errp) {
             return;
         }
     } else {
diff --git a/hw/usb/hcd-xhci.c b/hw/usb/hcd-xhci.c
index 80988bb305..fb3fcbbd3d 100644
--- a/hw/usb/hcd-xhci.c
+++ b/hw/usb/hcd-xhci.c
@@ -3370,7 +3370,6 @@ static void usb_xhci_init(XHCIState *xhci)
 static void usb_xhci_realize(struct PCIDevice *dev, Error **errp)
 {
     int i, ret;
-    Error *err = NULL;
 
     XHCIState *xhci = XHCI(dev);
 
@@ -3404,20 +3403,19 @@ static void usb_xhci_realize(struct PCIDevice *dev, Error **errp)
     }
 
     if (xhci->msi != ON_OFF_AUTO_OFF) {
-        ret = msi_init(dev, 0x70, xhci->numintrs, true, false, &err);
+        ret = msi_init(dev, 0x70, xhci->numintrs, true, false, errp);
         /* Any error other than -ENOTSUP(board's MSI support is broken)
          * is a programming error */
         assert(!ret || ret == -ENOTSUP);
         if (ret && xhci->msi == ON_OFF_AUTO_ON) {
             /* Can't satisfy user's explicit msi=on request, fail */
-            error_append_hint(&err, "You have to use msi=auto (default) or "
-                    "msi=off with this machine type.\n");
-            error_propagate(errp, err);
+            error_append_hint(errp, "You have to use msi=auto (default) or "
+                              "msi=off with this machine type.\n");
             return;
         }
-        assert(!err || xhci->msi == ON_OFF_AUTO_AUTO);
+        assert(!*errp || xhci->msi == ON_OFF_AUTO_AUTO);
         /* With msi=auto, we fall back to MSI off silently */
-        error_free(err);
+        error_free_errp(errp);
     }
 
     usb_xhci_init(xhci);
diff --git a/hw/vfio/ap.c b/hw/vfio/ap.c
index da6a20669d..e072a08f1d 100644
--- a/hw/vfio/ap.c
+++ b/hw/vfio/ap.c
@@ -89,12 +89,11 @@ static void vfio_ap_realize(DeviceState *dev, Error **errp)
 {
     int ret;
     char *mdevid;
-    Error *local_err = NULL;
     VFIOGroup *vfio_group;
     APDevice *apdev = AP_DEVICE(dev);
     VFIOAPDevice *vapdev = VFIO_AP_DEVICE(apdev);
 
-    vfio_group = vfio_ap_get_group(vapdev, &local_err);
+    vfio_group = vfio_ap_get_group(vapdev, errp);
     if (!vfio_group) {
         goto out_err;
     }
@@ -113,7 +112,7 @@ static void vfio_ap_realize(DeviceState *dev, Error **errp)
      */
     vapdev->vdev.balloon_allowed = true;
 
-    ret = vfio_get_device(vfio_group, mdevid, &vapdev->vdev, &local_err);
+    ret = vfio_get_device(vfio_group, mdevid, &vapdev->vdev, errp);
     if (ret) {
         goto out_get_dev_err;
     }
@@ -124,7 +123,6 @@ out_get_dev_err:
     vfio_ap_put_device(vapdev);
     vfio_put_group(vfio_group);
 out_err:
-    error_propagate(errp, local_err);
 }
 
 static void vfio_ap_unrealize(DeviceState *dev, Error **errp)
diff --git a/hw/vfio/ccw.c b/hw/vfio/ccw.c
index 6863f6c69f..d2b526667e 100644
--- a/hw/vfio/ccw.c
+++ b/hw/vfio/ccw.c
@@ -481,33 +481,32 @@ static void vfio_ccw_realize(DeviceState *dev, Error **errp)
     S390CCWDevice *cdev = DO_UPCAST(S390CCWDevice, parent_obj, ccw_dev);
     VFIOCCWDevice *vcdev = DO_UPCAST(VFIOCCWDevice, cdev, cdev);
     S390CCWDeviceClass *cdc = S390_CCW_DEVICE_GET_CLASS(cdev);
-    Error *err = NULL;
 
     /* Call the class init function for subchannel. */
     if (cdc->realize) {
-        cdc->realize(cdev, vcdev->vdev.sysfsdev, &err);
-        if (err) {
+        cdc->realize(cdev, vcdev->vdev.sysfsdev, errp);
+        if (*errp) {
             goto out_err_propagate;
         }
     }
 
-    group = vfio_ccw_get_group(cdev, &err);
+    group = vfio_ccw_get_group(cdev, errp);
     if (!group) {
         goto out_group_err;
     }
 
-    vfio_ccw_get_device(group, vcdev, &err);
-    if (err) {
+    vfio_ccw_get_device(group, vcdev, errp);
+    if (*errp) {
         goto out_device_err;
     }
 
-    vfio_ccw_get_region(vcdev, &err);
-    if (err) {
+    vfio_ccw_get_region(vcdev, errp);
+    if (*errp) {
         goto out_region_err;
     }
 
-    vfio_ccw_register_io_notifier(vcdev, &err);
-    if (err) {
+    vfio_ccw_register_io_notifier(vcdev, errp);
+    if (*errp) {
         goto out_notifier_err;
     }
 
@@ -524,7 +523,6 @@ out_group_err:
         cdc->unrealize(cdev, NULL);
     }
 out_err_propagate:
-    error_propagate(errp, err);
 }
 
 static void vfio_ccw_unrealize(DeviceState *dev, Error **errp)
diff --git a/hw/vfio/pci-quirks.c b/hw/vfio/pci-quirks.c
index 136f3a9ad6..c7bc17ed8a 100644
--- a/hw/vfio/pci-quirks.c
+++ b/hw/vfio/pci-quirks.c
@@ -2109,16 +2109,14 @@ static void set_nv_gpudirect_clique_id(Object *obj, Visitor *v,
     DeviceState *dev = DEVICE(obj);
     Property *prop = opaque;
     uint8_t value, *ptr = qdev_get_prop_ptr(dev, prop);
-    Error *local_err = NULL;
 
     if (dev->realized) {
         qdev_prop_set_after_realize(dev, name, errp);
         return;
     }
 
-    visit_type_uint8(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_uint8(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/vfio/pci.c b/hw/vfio/pci.c
index dc3479c374..839dda3424 100644
--- a/hw/vfio/pci.c
+++ b/hw/vfio/pci.c
@@ -119,7 +119,6 @@ static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev, Error **errp)
         .gsi = vdev->intx.route.irq,
         .flags = KVM_IRQFD_FLAG_RESAMPLE,
     };
-    Error *err = NULL;
 
     if (vdev->no_kvm_intx || !kvm_irqfds_enabled() ||
         vdev->intx.route.mode != PCI_INTX_ENABLED ||
@@ -149,8 +148,7 @@ static void vfio_intx_enable_kvm(VFIOPCIDevice *vdev, Error **errp)
 
     if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0,
                                VFIO_IRQ_SET_ACTION_UNMASK,
-                               irqfd.resamplefd, &err)) {
-        error_propagate(errp, err);
+                               irqfd.resamplefd, errp)) {
         goto fail_vfio;
     }
 
@@ -254,7 +252,6 @@ static void vfio_intx_update(PCIDevice *pdev)
 static int vfio_intx_enable(VFIOPCIDevice *vdev, Error **errp)
 {
     uint8_t pin = vfio_pci_read_config(&vdev->pdev, PCI_INTERRUPT_PIN, 1);
-    Error *err = NULL;
     int32_t fd;
     int ret;
 
@@ -288,16 +285,15 @@ static int vfio_intx_enable(VFIOPCIDevice *vdev, Error **errp)
     qemu_set_fd_handler(fd, vfio_intx_interrupt, NULL, vdev);
 
     if (vfio_set_irq_signaling(&vdev->vbasedev, VFIO_PCI_INTX_IRQ_INDEX, 0,
-                               VFIO_IRQ_SET_ACTION_TRIGGER, fd, &err)) {
-        error_propagate(errp, err);
+                               VFIO_IRQ_SET_ACTION_TRIGGER, fd, errp)) {
         qemu_set_fd_handler(fd, NULL, NULL, vdev);
         event_notifier_cleanup(&vdev->intx.interrupt);
         return -errno;
     }
 
-    vfio_intx_enable_kvm(vdev, &err);
-    if (err) {
-        warn_reportf_err(err, VFIO_MSG_PREFIX, vdev->vbasedev.name);
+    vfio_intx_enable_kvm(vdev, errp);
+    if (*errp) {
+        warn_reportf_err(*errp, VFIO_MSG_PREFIX, vdev->vbasedev.name);
     }
 
     vdev->interrupt = VFIO_INT_INTx;
@@ -1221,7 +1217,6 @@ static int vfio_msi_setup(VFIOPCIDevice *vdev, int pos, Error **errp)
     uint16_t ctrl;
     bool msi_64bit, msi_maskbit;
     int ret, entries;
-    Error *err = NULL;
 
     if (pread(vdev->vbasedev.fd, &ctrl, sizeof(ctrl),
               vdev->config_offset + pos + PCI_CAP_FLAGS) != sizeof(ctrl)) {
@@ -1236,12 +1231,12 @@ static int vfio_msi_setup(VFIOPCIDevice *vdev, int pos, Error **errp)
 
     trace_vfio_msi_setup(vdev->vbasedev.name, pos);
 
-    ret = msi_init(&vdev->pdev, pos, entries, msi_64bit, msi_maskbit, &err);
+    ret = msi_init(&vdev->pdev, pos, entries, msi_64bit, msi_maskbit, errp);
     if (ret < 0) {
         if (ret == -ENOTSUP) {
             return 0;
         }
-        error_propagate_prepend(errp, err, "msi_init failed: ");
+        error_propagate_prepend(errp, *errp, "msi_init failed: ");
         return ret;
     }
     vdev->msi_cap_size = 0xa + (msi_maskbit ? 0xa : 0) + (msi_64bit ? 0x4 : 0);
@@ -1503,7 +1498,6 @@ static void vfio_msix_early_setup(VFIOPCIDevice *vdev, Error **errp)
 static int vfio_msix_setup(VFIOPCIDevice *vdev, int pos, Error **errp)
 {
     int ret;
-    Error *err = NULL;
 
     vdev->msix->pending = g_malloc0(BITS_TO_LONGS(vdev->msix->entries) *
                                     sizeof(unsigned long));
@@ -1512,14 +1506,13 @@ static int vfio_msix_setup(VFIOPCIDevice *vdev, int pos, Error **errp)
                     vdev->msix->table_bar, vdev->msix->table_offset,
                     vdev->bars[vdev->msix->pba_bar].mr,
                     vdev->msix->pba_bar, vdev->msix->pba_offset, pos,
-                    &err);
+                    errp);
     if (ret < 0) {
         if (ret == -ENOTSUP) {
-            warn_report_err(err);
+            warn_report_errp(errp);
             return 0;
         }
 
-        error_propagate(errp, err);
         return ret;
     }
 
@@ -2704,7 +2697,6 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
     VFIODevice *vbasedev_iter;
     VFIOGroup *group;
     char *tmp, *subsys, group_path[PATH_MAX], *group_name;
-    Error *err = NULL;
     ssize_t len;
     struct stat st;
     int groupid;
@@ -2796,9 +2788,8 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
         goto error;
     }
 
-    vfio_populate_device(vdev, &err);
-    if (err) {
-        error_propagate(errp, err);
+    vfio_populate_device(vdev, errp);
+    if (*errp) {
         goto error;
     }
 
@@ -2891,9 +2882,8 @@ static void vfio_realize(PCIDevice *pdev, Error **errp)
 
     vfio_bars_prepare(vdev);
 
-    vfio_msix_early_setup(vdev, &err);
-    if (err) {
-        error_propagate(errp, err);
+    vfio_msix_early_setup(vdev, errp);
+    if (*errp) {
         goto error;
     }
 
diff --git a/hw/virtio/virtio-balloon.c b/hw/virtio/virtio-balloon.c
index 40b04f5180..afe6448c7b 100644
--- a/hw/virtio/virtio-balloon.c
+++ b/hw/virtio/virtio-balloon.c
@@ -229,40 +229,37 @@ static void balloon_stats_poll_cb(void *opaque)
 static void balloon_stats_get_all(Object *obj, Visitor *v, const char *name,
                                   void *opaque, Error **errp)
 {
-    Error *err = NULL;
     VirtIOBalloon *s = opaque;
     int i;
 
-    visit_start_struct(v, name, NULL, 0, &err);
-    if (err) {
-        goto out;
+    visit_start_struct(v, name, NULL, 0, errp);
+    if (*errp) {
+        return;
     }
-    visit_type_int(v, "last-update", &s->stats_last_update, &err);
-    if (err) {
+    visit_type_int(v, "last-update", &s->stats_last_update, errp);
+    if (*errp) {
         goto out_end;
     }
 
-    visit_start_struct(v, "stats", NULL, 0, &err);
-    if (err) {
+    visit_start_struct(v, "stats", NULL, 0, errp);
+    if (*errp) {
         goto out_end;
     }
     for (i = 0; i < VIRTIO_BALLOON_S_NR; i++) {
-        visit_type_uint64(v, balloon_stat_names[i], &s->stats[i], &err);
-        if (err) {
+        visit_type_uint64(v, balloon_stat_names[i], &s->stats[i], errp);
+        if (*errp) {
             goto out_nested;
         }
     }
-    visit_check_struct(v, &err);
+    visit_check_struct(v, errp);
 out_nested:
     visit_end_struct(v, NULL);
 
-    if (!err) {
-        visit_check_struct(v, &err);
+    if (!*errp) {
+        visit_check_struct(v, errp);
     }
 out_end:
     visit_end_struct(v, NULL);
-out:
-    error_propagate(errp, err);
 }
 
 static void balloon_stats_get_poll_interval(Object *obj, Visitor *v,
@@ -278,12 +275,10 @@ static void balloon_stats_set_poll_interval(Object *obj, Visitor *v,
                                             Error **errp)
 {
     VirtIOBalloon *s = opaque;
-    Error *local_err = NULL;
     int64_t value;
 
-    visit_type_int(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_int(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/virtio/virtio-bus.c b/hw/virtio/virtio-bus.c
index b2c804292e..5c54cead72 100644
--- a/hw/virtio/virtio-bus.c
+++ b/hw/virtio/virtio-bus.c
@@ -48,14 +48,12 @@ void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
     VirtioBusClass *klass = VIRTIO_BUS_GET_CLASS(bus);
     VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(vdev);
     bool has_iommu = virtio_host_has_feature(vdev, VIRTIO_F_IOMMU_PLATFORM);
-    Error *local_err = NULL;
 
     DPRINTF("%s: plug device.\n", qbus->name);
 
     if (klass->pre_plugged != NULL) {
-        klass->pre_plugged(qbus->parent, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        klass->pre_plugged(qbus->parent, errp);
+        if (*errp) {
             return;
         }
     }
@@ -63,17 +61,15 @@ void virtio_bus_device_plugged(VirtIODevice *vdev, Error **errp)
     /* Get the features of the plugged device. */
     assert(vdc->get_features != NULL);
     vdev->host_features = vdc->get_features(vdev, vdev->host_features,
-                                            &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                                            errp);
+    if (*errp) {
         return;
     }
 
     if (klass->device_plugged != NULL) {
-        klass->device_plugged(qbus->parent, &local_err);
+        klass->device_plugged(qbus->parent, errp);
     }
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/virtio/virtio-rng-pci.c b/hw/virtio/virtio-rng-pci.c
index 8aaf54b781..8978c0bbe1 100644
--- a/hw/virtio/virtio-rng-pci.c
+++ b/hw/virtio/virtio-rng-pci.c
@@ -34,12 +34,10 @@ static void virtio_rng_pci_realize(VirtIOPCIProxy *vpci_dev, Error **errp)
 {
     VirtIORngPCI *vrng = VIRTIO_RNG_PCI(vpci_dev);
     DeviceState *vdev = DEVICE(&vrng->vdev);
-    Error *err = NULL;
 
     qdev_set_parent_bus(vdev, BUS(&vpci_dev->bus));
-    object_property_set_bool(OBJECT(vdev), true, "realized", &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_set_bool(OBJECT(vdev), true, "realized", errp);
+    if (*errp) {
         return;
     }
 
diff --git a/hw/virtio/virtio-rng.c b/hw/virtio/virtio-rng.c
index e93bed020f..aeb3aac1fa 100644
--- a/hw/virtio/virtio-rng.c
+++ b/hw/virtio/virtio-rng.c
@@ -176,7 +176,6 @@ static void virtio_rng_device_realize(DeviceState *dev, Error **errp)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
     VirtIORNG *vrng = VIRTIO_RNG(dev);
-    Error *local_err = NULL;
 
     if (vrng->conf.period_ms <= 0) {
         error_setg(errp, "'period' parameter expects a positive integer");
@@ -195,9 +194,8 @@ static void virtio_rng_device_realize(DeviceState *dev, Error **errp)
         Object *default_backend = object_new(TYPE_RNG_BUILTIN);
 
         user_creatable_complete(USER_CREATABLE(default_backend),
-                                &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+                                errp);
+        if (*errp) {
             object_unref(default_backend);
             return;
         }
diff --git a/hw/virtio/virtio.c b/hw/virtio/virtio.c
index 527df03bfd..75ad25b120 100644
--- a/hw/virtio/virtio.c
+++ b/hw/virtio/virtio.c
@@ -2608,22 +2608,19 @@ static void virtio_device_realize(DeviceState *dev, Error **errp)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
     VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(dev);
-    Error *err = NULL;
 
     /* Devices should either use vmsd or the load/save methods */
     assert(!vdc->vmsd || !vdc->load);
 
     if (vdc->realize != NULL) {
-        vdc->realize(dev, &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        vdc->realize(dev, errp);
+        if (*errp != NULL) {
             return;
         }
     }
 
-    virtio_bus_device_plugged(vdev, &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    virtio_bus_device_plugged(vdev, errp);
+    if (*errp != NULL) {
         vdc->unrealize(dev, NULL);
         return;
     }
@@ -2636,14 +2633,12 @@ static void virtio_device_unrealize(DeviceState *dev, Error **errp)
 {
     VirtIODevice *vdev = VIRTIO_DEVICE(dev);
     VirtioDeviceClass *vdc = VIRTIO_DEVICE_GET_CLASS(dev);
-    Error *err = NULL;
 
     virtio_bus_device_unplugged(vdev);
 
     if (vdc->unrealize != NULL) {
-        vdc->unrealize(dev, &err);
-        if (err != NULL) {
-            error_propagate(errp, err);
+        vdc->unrealize(dev, errp);
+        if (*errp != NULL) {
             return;
         }
     }
diff --git a/hw/watchdog/wdt_aspeed.c b/hw/watchdog/wdt_aspeed.c
index 9b93213417..43b262c3c0 100644
--- a/hw/watchdog/wdt_aspeed.c
+++ b/hw/watchdog/wdt_aspeed.c
@@ -245,12 +245,10 @@ static void aspeed_wdt_realize(DeviceState *dev, Error **errp)
 {
     SysBusDevice *sbd = SYS_BUS_DEVICE(dev);
     AspeedWDTState *s = ASPEED_WDT(dev);
-    Error *err = NULL;
     Object *obj;
 
-    obj = object_property_get_link(OBJECT(dev), "scu", &err);
+    obj = object_property_get_link(OBJECT(dev), "scu", errp);
     if (!obj) {
-        error_propagate(errp, err);
         error_prepend(errp, "required link 'scu' not found: ");
         return;
     }
diff --git a/hw/xen/xen-backend.c b/hw/xen/xen-backend.c
index da065f81b7..e55520f97c 100644
--- a/hw/xen/xen-backend.c
+++ b/hw/xen/xen-backend.c
@@ -100,7 +100,6 @@ void xen_backend_device_create(XenBus *xenbus, const char *type,
 {
     const XenBackendImpl *impl = xen_backend_table_lookup(type);
     XenBackendInstance *backend;
-    Error *local_error = NULL;
 
     if (!impl) {
         return;
@@ -110,9 +109,8 @@ void xen_backend_device_create(XenBus *xenbus, const char *type,
     backend->xenbus = xenbus;
     backend->name = g_strdup(name);
 
-    impl->create(backend, opts, &local_error);
-    if (local_error) {
-        error_propagate(errp, local_error);
+    impl->create(backend, opts, errp);
+    if (*errp) {
         g_free(backend->name);
         g_free(backend);
         return;
diff --git a/hw/xen/xen-bus.c b/hw/xen/xen-bus.c
index a04478ad4f..63604aa6fc 100644
--- a/hw/xen/xen-bus.c
+++ b/hw/xen/xen-bus.c
@@ -55,7 +55,6 @@ static void xen_device_unplug(XenDevice *xendev, Error **errp)
 {
     XenBus *xenbus = XEN_BUS(qdev_get_parent_bus(DEVICE(xendev)));
     const char *type = object_get_typename(OBJECT(xendev));
-    Error *local_err = NULL;
     xs_transaction_t tid;
 
     trace_xen_device_unplug(type, xendev->name);
@@ -69,14 +68,14 @@ again:
     }
 
     xs_node_printf(xenbus->xsh, tid, xendev->backend_path, "online",
-                   &local_err, "%u", 0);
-    if (local_err) {
+                   errp, "%u", 0);
+    if (*errp) {
         goto abort;
     }
 
     xs_node_printf(xenbus->xsh, tid, xendev->backend_path, "state",
-                   &local_err, "%u", XenbusStateClosing);
-    if (local_err) {
+                   errp, "%u", XenbusStateClosing);
+    if (*errp) {
         goto abort;
     }
 
@@ -96,7 +95,6 @@ abort:
      * from ending the transaction.
      */
     xs_transaction_end(xenbus->xsh, tid, true);
-    error_propagate(errp, local_err);
 }
 
 static void xen_bus_print_dev(Monitor *mon, DeviceState *dev, int indent)
@@ -162,16 +160,13 @@ static XenWatch *xen_bus_add_watch(XenBus *xenbus, const char *node,
                                    void *opaque, Error **errp)
 {
     XenWatch *watch = new_watch(node, key, handler, opaque);
-    Error *local_err = NULL;
 
     trace_xen_bus_add_watch(watch->node, watch->key, watch->token);
 
     notifier_list_add(&xenbus->watch_notifiers, &watch->notifier);
 
-    xs_node_watch(xenbus->xsh, node, key, watch->token, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
-
+    xs_node_watch(xenbus->xsh, node, key, watch->token, errp);
+    if (*errp) {
         notifier_remove(&watch->notifier);
         free_watch(watch);
 
@@ -201,7 +196,6 @@ static void xen_bus_backend_create(XenBus *xenbus, const char *type,
     char **key;
     QDict *opts;
     unsigned int i, n;
-    Error *local_err = NULL;
 
     trace_xen_bus_backend_create(type, path);
 
@@ -256,11 +250,11 @@ again:
         return;
     }
 
-    xen_backend_device_create(xenbus, type, name, opts, &local_err);
+    xen_backend_device_create(xenbus, type, name, opts, errp);
     qobject_unref(opts);
 
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "failed to create '%s' device '%s': ",
                                 type, name);
     }
@@ -373,7 +367,6 @@ static void xen_bus_realize(BusState *bus, Error **errp)
 {
     XenBus *xenbus = XEN_BUS(bus);
     unsigned int domid;
-    Error *local_err = NULL;
 
     trace_xen_bus_realize();
 
@@ -398,10 +391,10 @@ static void xen_bus_realize(BusState *bus, Error **errp)
 
     xenbus->backend_watch =
         xen_bus_add_watch(xenbus, "", /* domain root node */
-                          "backend", xen_bus_enumerate, xenbus, &local_err);
-    if (local_err) {
+                          "backend", xen_bus_enumerate, xenbus, errp);
+    if (*errp) {
         /* This need not be treated as a hard error so don't propagate */
-        error_reportf_err(local_err,
+        error_reportf_err(*errp,
                           "failed to set up enumeration watch: ");
     }
 
@@ -590,7 +583,6 @@ static void xen_device_backend_create(XenDevice *xendev, Error **errp)
 {
     XenBus *xenbus = XEN_BUS(qdev_get_parent_bus(DEVICE(xendev)));
     struct xs_permissions perms[2];
-    Error *local_err = NULL;
 
     xendev->backend_path = xen_device_get_backend_path(xendev);
 
@@ -602,9 +594,9 @@ static void xen_device_backend_create(XenDevice *xendev, Error **errp)
     g_assert(xenbus->xsh);
 
     xs_node_create(xenbus->xsh, XBT_NULL, xendev->backend_path, perms,
-                   ARRAY_SIZE(perms), &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+                   ARRAY_SIZE(perms), errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "failed to create backend: ");
         return;
     }
@@ -612,9 +604,9 @@ static void xen_device_backend_create(XenDevice *xendev, Error **errp)
     xendev->backend_state_watch =
         xen_bus_add_watch(xenbus, xendev->backend_path,
                           "state", xen_device_backend_changed,
-                          xendev, &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+                          xendev, errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "failed to watch backend state: ");
         return;
     }
@@ -622,9 +614,9 @@ static void xen_device_backend_create(XenDevice *xendev, Error **errp)
     xendev->backend_online_watch =
         xen_bus_add_watch(xenbus, xendev->backend_path,
                           "online", xen_device_backend_changed,
-                          xendev, &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+                          xendev, errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "failed to watch backend online: ");
         return;
     }
@@ -757,7 +749,6 @@ static void xen_device_frontend_create(XenDevice *xendev, Error **errp)
 {
     XenBus *xenbus = XEN_BUS(qdev_get_parent_bus(DEVICE(xendev)));
     struct xs_permissions perms[2];
-    Error *local_err = NULL;
 
     xendev->frontend_path = xen_device_get_frontend_path(xendev);
 
@@ -769,18 +760,18 @@ static void xen_device_frontend_create(XenDevice *xendev, Error **errp)
     g_assert(xenbus->xsh);
 
     xs_node_create(xenbus->xsh, XBT_NULL, xendev->frontend_path, perms,
-                   ARRAY_SIZE(perms), &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+                   ARRAY_SIZE(perms), errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "failed to create frontend: ");
         return;
     }
 
     xendev->frontend_state_watch =
         xen_bus_add_watch(xenbus, xendev->frontend_path, "state",
-                          xen_device_frontend_changed, xendev, &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+                          xen_device_frontend_changed, xendev, errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "failed to watch frontend state: ");
     }
 }
@@ -1104,7 +1095,6 @@ static void xen_device_realize(DeviceState *dev, Error **errp)
     XenDeviceClass *xendev_class = XEN_DEVICE_GET_CLASS(xendev);
     XenBus *xenbus = XEN_BUS(qdev_get_parent_bus(DEVICE(xendev)));
     const char *type = object_get_typename(OBJECT(xendev));
-    Error *local_err = NULL;
 
     if (xendev->frontend_id == DOMID_INVALID) {
         xendev->frontend_id = xen_domid;
@@ -1120,9 +1110,9 @@ static void xen_device_realize(DeviceState *dev, Error **errp)
         goto unrealize;
     }
 
-    xendev->name = xendev_class->get_name(xendev, &local_err);
-    if (local_err) {
-        error_propagate_prepend(errp, local_err,
+    xendev->name = xendev_class->get_name(xendev, errp);
+    if (*errp) {
+        error_propagate_prepend(errp, *errp,
                                 "failed to get device name: ");
         goto unrealize;
     }
@@ -1138,22 +1128,19 @@ static void xen_device_realize(DeviceState *dev, Error **errp)
     xendev->feature_grant_copy =
         (xengnttab_grant_copy(xendev->xgth, 0, NULL) == 0);
 
-    xen_device_backend_create(xendev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    xen_device_backend_create(xendev, errp);
+    if (*errp) {
         goto unrealize;
     }
 
-    xen_device_frontend_create(xendev, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    xen_device_frontend_create(xendev, errp);
+    if (*errp) {
         goto unrealize;
     }
 
     if (xendev_class->realize) {
-        xendev_class->realize(xendev, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        xendev_class->realize(xendev, errp);
+        if (*errp) {
             goto unrealize;
         }
     }
diff --git a/hw/xen/xen-host-pci-device.c b/hw/xen/xen-host-pci-device.c
index 1b44dcafaf..6bb65bf567 100644
--- a/hw/xen/xen-host-pci-device.c
+++ b/hw/xen/xen-host-pci-device.c
@@ -334,7 +334,6 @@ void xen_host_pci_device_get(XenHostPCIDevice *d, uint16_t domain,
                              Error **errp)
 {
     unsigned int v;
-    Error *err = NULL;
 
     d->config_fd = -1;
     d->domain = domain;
@@ -342,36 +341,36 @@ void xen_host_pci_device_get(XenHostPCIDevice *d, uint16_t domain,
     d->dev = dev;
     d->func = func;
 
-    xen_host_pci_config_open(d, &err);
-    if (err) {
+    xen_host_pci_config_open(d, errp);
+    if (*errp) {
         goto error;
     }
 
-    xen_host_pci_get_resource(d, &err);
-    if (err) {
+    xen_host_pci_get_resource(d, errp);
+    if (*errp) {
         goto error;
     }
 
-    xen_host_pci_get_hex_value(d, "vendor", &v, &err);
-    if (err) {
+    xen_host_pci_get_hex_value(d, "vendor", &v, errp);
+    if (*errp) {
         goto error;
     }
     d->vendor_id = v;
 
-    xen_host_pci_get_hex_value(d, "device", &v, &err);
-    if (err) {
+    xen_host_pci_get_hex_value(d, "device", &v, errp);
+    if (*errp) {
         goto error;
     }
     d->device_id = v;
 
-    xen_host_pci_get_dec_value(d, "irq", &v, &err);
-    if (err) {
+    xen_host_pci_get_dec_value(d, "irq", &v, errp);
+    if (*errp) {
         goto error;
     }
     d->irq = v;
 
-    xen_host_pci_get_hex_value(d, "class", &v, &err);
-    if (err) {
+    xen_host_pci_get_hex_value(d, "class", &v, errp);
+    if (*errp) {
         goto error;
     }
     d->class_code = v;
@@ -381,7 +380,6 @@ void xen_host_pci_device_get(XenHostPCIDevice *d, uint16_t domain,
     return;
 
 error:
-    error_propagate(errp, err);
 
     if (d->config_fd >= 0) {
         close(d->config_fd);
diff --git a/hw/xen/xen_pt.c b/hw/xen/xen_pt.c
index 8fbaf2eae9..8d4cf7291f 100644
--- a/hw/xen/xen_pt.c
+++ b/hw/xen/xen_pt.c
@@ -770,7 +770,6 @@ static void xen_pt_realize(PCIDevice *d, Error **errp)
     uint8_t machine_irq = 0, scratch;
     uint16_t cmd = 0;
     int pirq = XEN_PT_UNASSIGNED_PIRQ;
-    Error *err = NULL;
 
     /* register real device */
     XEN_PT_LOG(d, "Assigning real physical device %02x:%02x.%d"
@@ -781,10 +780,9 @@ static void xen_pt_realize(PCIDevice *d, Error **errp)
     xen_host_pci_device_get(&s->real_device,
                             s->hostaddr.domain, s->hostaddr.bus,
                             s->hostaddr.slot, s->hostaddr.function,
-                            &err);
-    if (err) {
-        error_append_hint(&err, "Failed to \"open\" the real pci device");
-        error_propagate(errp, err);
+                            errp);
+    if (*errp) {
+        error_append_hint(errp, "Failed to \"open\" the real pci device");
         return;
     }
 
@@ -811,11 +809,10 @@ static void xen_pt_realize(PCIDevice *d, Error **errp)
             return;
         }
 
-        xen_pt_setup_vga(s, &s->real_device, &err);
-        if (err) {
-            error_append_hint(&err, "Setup VGA BIOS of passthrough"
-                    " GFX failed");
-            error_propagate(errp, err);
+        xen_pt_setup_vga(s, &s->real_device, errp);
+        if (*errp) {
+            error_append_hint(errp, "Setup VGA BIOS of passthrough"
+                              " GFX failed");
             xen_host_pci_device_put(&s->real_device);
             return;
         }
@@ -828,10 +825,9 @@ static void xen_pt_realize(PCIDevice *d, Error **errp)
     xen_pt_register_regions(s, &cmd);
 
     /* reinitialize each config register to be emulated */
-    xen_pt_config_init(s, &err);
-    if (err) {
-        error_append_hint(&err, "PCI Config space initialisation failed");
-        error_propagate(errp, err);
+    xen_pt_config_init(s, errp);
+    if (*errp) {
+        error_append_hint(errp, "PCI Config space initialisation failed");
         rc = -1;
         goto err_out;
     }
diff --git a/hw/xen/xen_pt_config_init.c b/hw/xen/xen_pt_config_init.c
index 31ec5add1d..bc1feacc3c 100644
--- a/hw/xen/xen_pt_config_init.c
+++ b/hw/xen/xen_pt_config_init.c
@@ -2009,7 +2009,6 @@ static void xen_pt_config_reg_init(XenPCIPassthroughState *s,
 void xen_pt_config_init(XenPCIPassthroughState *s, Error **errp)
 {
     int i, rc;
-    Error *err = NULL;
 
     QLIST_INIT(&s->reg_grps);
 
@@ -2052,10 +2051,9 @@ void xen_pt_config_init(XenPCIPassthroughState *s, Error **errp)
                                                   reg_grp_offset,
                                                   &reg_grp_entry->size);
             if (rc < 0) {
-                error_setg(&err, "Failed to initialize %d/%zu, type = 0x%x,"
+                error_setg(errp, "Failed to initialize %d/%zu, type = 0x%x,"
                            " rc: %d", i, ARRAY_SIZE(xen_pt_emu_reg_grps),
                            xen_pt_emu_reg_grps[i].grp_type, rc);
-                error_propagate(errp, err);
                 xen_pt_config_delete(s);
                 return;
             }
@@ -2068,13 +2066,14 @@ void xen_pt_config_init(XenPCIPassthroughState *s, Error **errp)
 
                 /* initialize capability register */
                 for (j = 0; regs->size != 0; j++, regs++) {
-                    xen_pt_config_reg_init(s, reg_grp_entry, regs, &err);
-                    if (err) {
-                        error_append_hint(&err, "Failed to init register %d"
-                                " offsets 0x%x in grp_type = 0x%x (%d/%zu)", j,
-                                regs->offset, xen_pt_emu_reg_grps[i].grp_type,
-                                i, ARRAY_SIZE(xen_pt_emu_reg_grps));
-                        error_propagate(errp, err);
+                    xen_pt_config_reg_init(s, reg_grp_entry, regs, errp);
+                    if (*errp) {
+                        error_append_hint(errp, "Failed to init register %d"
+                                          " offsets 0x%x in grp_type = 0x%x (%d/%zu)",
+                                          j,
+                                          regs->offset,
+                                          xen_pt_emu_reg_grps[i].grp_type,
+                                          i, ARRAY_SIZE(xen_pt_emu_reg_grps));
                         xen_pt_config_delete(s);
                         return;
                     }
diff --git a/io/dns-resolver.c b/io/dns-resolver.c
index 6ebe2a5650..1aab5cfef2 100644
--- a/io/dns-resolver.c
+++ b/io/dns-resolver.c
@@ -58,7 +58,6 @@ static int qio_dns_resolver_lookup_sync_inet(QIODNSResolver *resolver,
     char uaddr[INET6_ADDRSTRLEN + 1];
     char uport[33];
     int rc;
-    Error *err = NULL;
     size_t i;
 
     *naddrs = 0;
@@ -69,11 +68,10 @@ static int qio_dns_resolver_lookup_sync_inet(QIODNSResolver *resolver,
     if (iaddr->has_numeric && iaddr->numeric) {
         ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;
     }
-    ai.ai_family = inet_ai_family_from_address(iaddr, &err);
+    ai.ai_family = inet_ai_family_from_address(iaddr, errp);
     ai.ai_socktype = SOCK_STREAM;
 
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         return -1;
     }
 
diff --git a/io/net-listener.c b/io/net-listener.c
index 5d8a226872..73a8a71449 100644
--- a/io/net-listener.c
+++ b/io/net-listener.c
@@ -69,7 +69,6 @@ int qio_net_listener_open_sync(QIONetListener *listener,
     SocketAddress **resaddrs;
     size_t nresaddrs;
     size_t i;
-    Error *err = NULL;
     bool success = false;
 
     if (qio_dns_resolver_lookup_sync(resolver,
@@ -84,7 +83,7 @@ int qio_net_listener_open_sync(QIONetListener *listener,
         QIOChannelSocket *sioc = qio_channel_socket_new();
 
         if (qio_channel_socket_listen_sync(sioc, resaddrs[i], num,
-                                           err ? NULL : &err) == 0) {
+                                           *errp ? NULL : errp) == 0) {
             success = true;
 
             qio_net_listener_add(listener, sioc);
@@ -96,10 +95,9 @@ int qio_net_listener_open_sync(QIONetListener *listener,
     g_free(resaddrs);
 
     if (success) {
-        error_free(err);
+        error_free_errp(errp);
         return 0;
     } else {
-        error_propagate(errp, err);
         return -1;
     }
 }
diff --git a/iothread.c b/iothread.c
index 7130be58e3..b977e5c1b0 100644
--- a/iothread.c
+++ b/iothread.c
@@ -163,15 +163,13 @@ static void iothread_init_gcontext(IOThread *iothread)
 
 static void iothread_complete(UserCreatable *obj, Error **errp)
 {
-    Error *local_error = NULL;
     IOThread *iothread = IOTHREAD(obj);
     char *name, *thread_name;
 
     iothread->stopping = false;
     iothread->running = true;
-    iothread->ctx = aio_context_new(&local_error);
+    iothread->ctx = aio_context_new(errp);
     if (!iothread->ctx) {
-        error_propagate(errp, local_error);
         return;
     }
 
@@ -185,9 +183,8 @@ static void iothread_complete(UserCreatable *obj, Error **errp)
                                 iothread->poll_max_ns,
                                 iothread->poll_grow,
                                 iothread->poll_shrink,
-                                &local_error);
-    if (local_error) {
-        error_propagate(errp, local_error);
+                                errp);
+    if (*errp) {
         aio_context_unref(iothread->ctx);
         iothread->ctx = NULL;
         return;
@@ -240,18 +237,17 @@ static void iothread_set_poll_param(Object *obj, Visitor *v,
     IOThread *iothread = IOTHREAD(obj);
     PollParamInfo *info = opaque;
     int64_t *field = (void *)iothread + info->offset;
-    Error *local_err = NULL;
     int64_t value;
 
-    visit_type_int64(v, name, &value, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_int64(v, name, &value, errp);
+    if (*errp) {
+        return;
     }
 
     if (value < 0) {
-        error_setg(&local_err, "%s value must be in range [0, %"PRId64"]",
+        error_setg(errp, "%s value must be in range [0, %"PRId64"]",
                    info->name, INT64_MAX);
-        goto out;
+        return;
     }
 
     *field = value;
@@ -261,11 +257,8 @@ static void iothread_set_poll_param(Object *obj, Visitor *v,
                                     iothread->poll_max_ns,
                                     iothread->poll_grow,
                                     iothread->poll_shrink,
-                                    &local_err);
+                                    errp);
     }
-
-out:
-    error_propagate(errp, local_err);
 }
 
 static void iothread_class_init(ObjectClass *klass, void *class_data)
diff --git a/job.c b/job.c
index 04409b40aa..b0adde1670 100644
--- a/job.c
+++ b/job.c
@@ -966,16 +966,14 @@ void job_complete(Job *job, Error **errp)
 
 int job_finish_sync(Job *job, void (*finish)(Job *, Error **errp), Error **errp)
 {
-    Error *local_err = NULL;
     int ret;
 
     job_ref(job);
 
     if (finish) {
-        finish(job, &local_err);
+        finish(job, errp);
     }
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         job_unref(job);
         return -EBUSY;
     }
diff --git a/memory.c b/memory.c
index b9dd6b94ca..168de8e516 100644
--- a/memory.c
+++ b/memory.c
@@ -1544,17 +1544,15 @@ void memory_region_init_ram_shared_nomigrate(MemoryRegion *mr,
                                              bool share,
                                              Error **errp)
 {
-    Error *err = NULL;
     memory_region_init(mr, owner, name, size);
     mr->ram = true;
     mr->terminates = true;
     mr->destructor = memory_region_destructor_ram;
-    mr->ram_block = qemu_ram_alloc(size, share, mr, &err);
+    mr->ram_block = qemu_ram_alloc(size, share, mr, errp);
     mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;
-    if (err) {
+    if (*errp) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
-        error_propagate(errp, err);
     }
 }
 
@@ -1568,18 +1566,16 @@ void memory_region_init_resizeable_ram(MemoryRegion *mr,
                                                        void *host),
                                        Error **errp)
 {
-    Error *err = NULL;
     memory_region_init(mr, owner, name, size);
     mr->ram = true;
     mr->terminates = true;
     mr->destructor = memory_region_destructor_ram;
     mr->ram_block = qemu_ram_alloc_resizeable(size, max_size, resized,
-                                              mr, &err);
+                                              mr, errp);
     mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;
-    if (err) {
+    if (*errp) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
-        error_propagate(errp, err);
     }
 }
 
@@ -1593,18 +1589,16 @@ void memory_region_init_ram_from_file(MemoryRegion *mr,
                                       const char *path,
                                       Error **errp)
 {
-    Error *err = NULL;
     memory_region_init(mr, owner, name, size);
     mr->ram = true;
     mr->terminates = true;
     mr->destructor = memory_region_destructor_ram;
     mr->align = align;
-    mr->ram_block = qemu_ram_alloc_from_file(size, mr, ram_flags, path, &err);
+    mr->ram_block = qemu_ram_alloc_from_file(size, mr, ram_flags, path, errp);
     mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;
-    if (err) {
+    if (*errp) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
-        error_propagate(errp, err);
     }
 }
 
@@ -1616,19 +1610,17 @@ void memory_region_init_ram_from_fd(MemoryRegion *mr,
                                     int fd,
                                     Error **errp)
 {
-    Error *err = NULL;
     memory_region_init(mr, owner, name, size);
     mr->ram = true;
     mr->terminates = true;
     mr->destructor = memory_region_destructor_ram;
     mr->ram_block = qemu_ram_alloc_from_fd(size, mr,
                                            share ? RAM_SHARED : 0,
-                                           fd, &err);
+                                           fd, errp);
     mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;
-    if (err) {
+    if (*errp) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
-        error_propagate(errp, err);
     }
 }
 #endif
@@ -1687,18 +1679,16 @@ void memory_region_init_rom_nomigrate(MemoryRegion *mr,
                                       uint64_t size,
                                       Error **errp)
 {
-    Error *err = NULL;
     memory_region_init(mr, owner, name, size);
     mr->ram = true;
     mr->readonly = true;
     mr->terminates = true;
     mr->destructor = memory_region_destructor_ram;
-    mr->ram_block = qemu_ram_alloc(size, false, mr, &err);
+    mr->ram_block = qemu_ram_alloc(size, false, mr, errp);
     mr->dirty_log_mask = tcg_enabled() ? (1 << DIRTY_MEMORY_CODE) : 0;
-    if (err) {
+    if (*errp) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
-        error_propagate(errp, err);
     }
 }
 
@@ -1710,7 +1700,6 @@ void memory_region_init_rom_device_nomigrate(MemoryRegion *mr,
                                              uint64_t size,
                                              Error **errp)
 {
-    Error *err = NULL;
     assert(ops);
     memory_region_init(mr, owner, name, size);
     mr->ops = ops;
@@ -1718,11 +1707,10 @@ void memory_region_init_rom_device_nomigrate(MemoryRegion *mr,
     mr->terminates = true;
     mr->rom_device = true;
     mr->destructor = memory_region_destructor_ram;
-    mr->ram_block = qemu_ram_alloc(size, false,  mr, &err);
-    if (err) {
+    mr->ram_block = qemu_ram_alloc(size, false,  mr, errp);
+    if (*errp) {
         mr->size = int128_zero();
         object_unparent(OBJECT(mr));
-        error_propagate(errp, err);
     }
 }
 
@@ -3174,11 +3162,9 @@ void memory_region_init_ram(MemoryRegion *mr,
                             Error **errp)
 {
     DeviceState *owner_dev;
-    Error *err = NULL;
 
-    memory_region_init_ram_nomigrate(mr, owner, name, size, &err);
-    if (err) {
-        error_propagate(errp, err);
+    memory_region_init_ram_nomigrate(mr, owner, name, size, errp);
+    if (*errp) {
         return;
     }
     /* This will assert if owner is neither NULL nor a DeviceState.
@@ -3198,11 +3184,9 @@ void memory_region_init_rom(MemoryRegion *mr,
                             Error **errp)
 {
     DeviceState *owner_dev;
-    Error *err = NULL;
 
-    memory_region_init_rom_nomigrate(mr, owner, name, size, &err);
-    if (err) {
-        error_propagate(errp, err);
+    memory_region_init_rom_nomigrate(mr, owner, name, size, errp);
+    if (*errp) {
         return;
     }
     /* This will assert if owner is neither NULL nor a DeviceState.
@@ -3224,12 +3208,10 @@ void memory_region_init_rom_device(MemoryRegion *mr,
                                    Error **errp)
 {
     DeviceState *owner_dev;
-    Error *err = NULL;
 
     memory_region_init_rom_device_nomigrate(mr, owner, ops, opaque,
-                                            name, size, &err);
-    if (err) {
-        error_propagate(errp, err);
+                                            name, size, errp);
+    if (*errp) {
         return;
     }
     /* This will assert if owner is neither NULL nor a DeviceState.
diff --git a/memory_mapping.c b/memory_mapping.c
index 18d0b8067c..33103c16d3 100644
--- a/memory_mapping.c
+++ b/memory_mapping.c
@@ -296,10 +296,8 @@ void qemu_get_guest_memory_mapping(MemoryMappingList *list,
     if (first_paging_enabled_cpu) {
         for (cpu = first_paging_enabled_cpu; cpu != NULL;
              cpu = CPU_NEXT(cpu)) {
-            Error *err = NULL;
-            cpu_get_memory_mapping(cpu, list, &err);
-            if (err) {
-                error_propagate(errp, err);
+            cpu_get_memory_mapping(cpu, list, errp);
+            if (*errp) {
                 return;
             }
         }
diff --git a/migration/colo.c b/migration/colo.c
index 2c88aa57a2..31dac8c0bd 100644
--- a/migration/colo.c
+++ b/migration/colo.c
@@ -243,19 +243,18 @@ void qmp_xen_set_replication(bool enable, bool primary,
 
 ReplicationStatus *qmp_query_xen_replication_status(Error **errp)
 {
-    Error *err = NULL;
     ReplicationStatus *s = g_new0(ReplicationStatus, 1);
 
-    replication_get_error_all(&err);
-    if (err) {
+    replication_get_error_all(errp);
+    if (*errp) {
         s->error = true;
         s->has_desc = true;
-        s->desc = g_strdup(error_get_pretty(err));
+        s->desc = g_strdup(error_get_pretty(*errp));
     } else {
         s->error = false;
     }
 
-    error_free(err);
+    error_free_errp(errp);
     return s;
 }
 
@@ -314,12 +313,10 @@ static void colo_send_message(QEMUFile *f, COLOMessage msg,
 static void colo_send_message_value(QEMUFile *f, COLOMessage msg,
                                     uint64_t value, Error **errp)
 {
-    Error *local_err = NULL;
     int ret;
 
-    colo_send_message(f, msg, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    colo_send_message(f, msg, errp);
+    if (*errp) {
         return;
     }
     qemu_put_be64(f, value);
@@ -355,11 +352,9 @@ static void colo_receive_check_message(QEMUFile *f, COLOMessage expect_msg,
                                        Error **errp)
 {
     COLOMessage msg;
-    Error *local_err = NULL;
 
-    msg = colo_receive_message(f, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    msg = colo_receive_message(f, errp);
+    if (*errp) {
         return;
     }
     if (msg != expect_msg) {
@@ -371,13 +366,11 @@ static void colo_receive_check_message(QEMUFile *f, COLOMessage expect_msg,
 static uint64_t colo_receive_message_value(QEMUFile *f, uint32_t expect_msg,
                                            Error **errp)
 {
-    Error *local_err = NULL;
     uint64_t value;
     int ret;
 
-    colo_receive_check_message(f, expect_msg, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    colo_receive_check_message(f, expect_msg, errp);
+    if (*errp) {
         return 0;
     }
 
@@ -668,11 +661,9 @@ static void colo_wait_handle_message(QEMUFile *f, int *checkpoint_request,
                                      Error **errp)
 {
     COLOMessage msg;
-    Error *local_err = NULL;
 
-    msg = colo_receive_message(f, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    msg = colo_receive_message(f, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/migration/migration.c b/migration/migration.c
index 01863a95f5..9309008555 100644
--- a/migration/migration.c
+++ b/migration/migration.c
@@ -603,12 +603,10 @@ void migration_ioc_process_incoming(QIOChannel *ioc, Error **errp)
          */
         start_migration = !migrate_use_multifd();
     } else {
-        Error *local_err = NULL;
         /* Multiple connections */
         assert(migrate_use_multifd());
-        start_migration = multifd_recv_new_channel(ioc, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        start_migration = multifd_recv_new_channel(ioc, errp);
+        if (*errp) {
             return;
         }
     }
@@ -1757,7 +1755,6 @@ void migrate_del_blocker(Error *reason)
 
 void qmp_migrate_incoming(const char *uri, Error **errp)
 {
-    Error *local_err = NULL;
     static bool once = true;
 
     if (!deferred_incoming) {
@@ -1768,10 +1765,9 @@ void qmp_migrate_incoming(const char *uri, Error **errp)
         error_setg(errp, "The incoming migration has already been started");
     }
 
-    qemu_start_incoming_migration(uri, &local_err);
+    qemu_start_incoming_migration(uri, errp);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return;
     }
 
@@ -1849,8 +1845,6 @@ bool migration_is_blocked(Error **errp)
 static bool migrate_prepare(MigrationState *s, bool blk, bool blk_inc,
                             bool resume, Error **errp)
 {
-    Error *local_err = NULL;
-
     if (resume) {
         if (s->state != MIGRATION_STATUS_POSTCOPY_PAUSED) {
             error_setg(errp, "Cannot resume if there is no "
@@ -1902,9 +1896,8 @@ static bool migrate_prepare(MigrationState *s, bool blk, bool blk_inc,
                        "current migration capabilities");
             return false;
         }
-        migrate_set_block_enabled(true, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        migrate_set_block_enabled(true, errp);
+        if (*errp) {
             return false;
         }
         s->must_remove_block_options = true;
@@ -1928,7 +1921,6 @@ void qmp_migrate(const char *uri, bool has_blk, bool blk,
                  bool has_inc, bool inc, bool has_detach, bool detach,
                  bool has_resume, bool resume, Error **errp)
 {
-    Error *local_err = NULL;
     MigrationState *s = migrate_get_current();
     const char *p;
 
@@ -1939,17 +1931,17 @@ void qmp_migrate(const char *uri, bool has_blk, bool blk,
     }
 
     if (strstart(uri, "tcp:", &p)) {
-        tcp_start_outgoing_migration(s, p, &local_err);
+        tcp_start_outgoing_migration(s, p, errp);
 #ifdef CONFIG_RDMA
     } else if (strstart(uri, "rdma:", &p)) {
-        rdma_start_outgoing_migration(s, p, &local_err);
+        rdma_start_outgoing_migration(s, p, errp);
 #endif
     } else if (strstart(uri, "exec:", &p)) {
-        exec_start_outgoing_migration(s, p, &local_err);
+        exec_start_outgoing_migration(s, p, errp);
     } else if (strstart(uri, "unix:", &p)) {
-        unix_start_outgoing_migration(s, p, &local_err);
+        unix_start_outgoing_migration(s, p, errp);
     } else if (strstart(uri, "fd:", &p)) {
-        fd_start_outgoing_migration(s, p, &local_err);
+        fd_start_outgoing_migration(s, p, errp);
     } else {
         error_setg(errp, QERR_INVALID_PARAMETER_VALUE, "uri",
                    "a valid migration protocol");
@@ -1959,9 +1951,8 @@ void qmp_migrate(const char *uri, bool has_blk, bool blk,
         return;
     }
 
-    if (local_err) {
-        migrate_fd_error(s, local_err);
-        error_propagate(errp, local_err);
+    if (*errp) {
+        migrate_fd_error(s, *errp);
         return;
     }
 }
diff --git a/migration/ram.c b/migration/ram.c
index 01df326767..6935afe2ea 100644
--- a/migration/ram.c
+++ b/migration/ram.c
@@ -1475,13 +1475,12 @@ bool multifd_recv_all_channels_created(void)
 bool multifd_recv_new_channel(QIOChannel *ioc, Error **errp)
 {
     MultiFDRecvParams *p;
-    Error *local_err = NULL;
     int id;
 
-    id = multifd_recv_initial_packet(ioc, &local_err);
+    id = multifd_recv_initial_packet(ioc, errp);
     if (id < 0) {
-        multifd_recv_terminate_threads(local_err);
-        error_propagate_prepend(errp, local_err,
+        multifd_recv_terminate_threads(*errp);
+        error_propagate_prepend(errp, *errp,
                                 "failed to receive packet"
                                 " via multifd channel %d: ",
                                 atomic_read(&multifd_recv_state->count));
@@ -1491,10 +1490,9 @@ bool multifd_recv_new_channel(QIOChannel *ioc, Error **errp)
 
     p = &multifd_recv_state->params[id];
     if (p->c != NULL) {
-        error_setg(&local_err, "multifd: received id '%d' already setup'",
+        error_setg(errp, "multifd: received id '%d' already setup'",
                    id);
-        multifd_recv_terminate_threads(local_err);
-        error_propagate(errp, local_err);
+        multifd_recv_terminate_threads(*errp);
         return false;
     }
     p->c = ioc;
diff --git a/migration/rdma.c b/migration/rdma.c
index 78e6b72bac..2b40157240 100644
--- a/migration/rdma.c
+++ b/migration/rdma.c
@@ -2397,7 +2397,7 @@ static void qemu_rdma_cleanup(RDMAContext *rdma)
 static int qemu_rdma_source_init(RDMAContext *rdma, bool pin_all, Error **errp)
 {
     int ret, idx;
-    Error *local_err = NULL, **temp = &local_err;
+    Error **temp = errp;
 
     /*
      * Will be validated against destination's actual capabilities
@@ -2450,7 +2450,6 @@ static int qemu_rdma_source_init(RDMAContext *rdma, bool pin_all, Error **errp)
     return 0;
 
 err_rdma_source_init:
-    error_propagate(errp, local_err);
     qemu_rdma_cleanup(rdma);
     return -1;
 }
@@ -4027,16 +4026,15 @@ void rdma_start_incoming_migration(const char *host_port, Error **errp)
 {
     int ret;
     RDMAContext *rdma, *rdma_return_path = NULL;
-    Error *local_err = NULL;
 
     trace_rdma_start_incoming_migration();
-    rdma = qemu_rdma_data_init(host_port, &local_err);
+    rdma = qemu_rdma_data_init(host_port, errp);
 
     if (rdma == NULL) {
         goto err;
     }
 
-    ret = qemu_rdma_dest_init(rdma, &local_err);
+    ret = qemu_rdma_dest_init(rdma, errp);
 
     if (ret) {
         goto err;
@@ -4055,7 +4053,7 @@ void rdma_start_incoming_migration(const char *host_port, Error **errp)
 
     /* initialize the RDMAContext for return path */
     if (migrate_postcopy()) {
-        rdma_return_path = qemu_rdma_data_init(host_port, &local_err);
+        rdma_return_path = qemu_rdma_data_init(host_port, errp);
 
         if (rdma_return_path == NULL) {
             goto err;
@@ -4068,7 +4066,6 @@ void rdma_start_incoming_migration(const char *host_port, Error **errp)
                         NULL, (void *)(intptr_t)rdma);
     return;
 err:
-    error_propagate(errp, local_err);
     g_free(rdma);
     g_free(rdma_return_path);
 }
diff --git a/migration/socket.c b/migration/socket.c
index 97c9efde59..ca4326e02c 100644
--- a/migration/socket.c
+++ b/migration/socket.c
@@ -139,12 +139,10 @@ void tcp_start_outgoing_migration(MigrationState *s,
                                   const char *host_port,
                                   Error **errp)
 {
-    Error *err = NULL;
-    SocketAddress *saddr = tcp_build_address(host_port, &err);
-    if (!err) {
-        socket_start_outgoing_migration(s, saddr, &err);
+    SocketAddress *saddr = tcp_build_address(host_port, errp);
+    if (!*errp) {
+        socket_start_outgoing_migration(s, saddr, errp);
     }
-    error_propagate(errp, err);
 }
 
 void unix_start_outgoing_migration(MigrationState *s,
@@ -209,13 +207,11 @@ static void socket_start_incoming_migration(SocketAddress *saddr,
 
 void tcp_start_incoming_migration(const char *host_port, Error **errp)
 {
-    Error *err = NULL;
-    SocketAddress *saddr = tcp_build_address(host_port, &err);
-    if (!err) {
-        socket_start_incoming_migration(saddr, &err);
+    SocketAddress *saddr = tcp_build_address(host_port, errp);
+    if (!*errp) {
+        socket_start_incoming_migration(saddr, errp);
     }
     qapi_free_SocketAddress(saddr);
-    error_propagate(errp, err);
 }
 
 void unix_start_incoming_migration(const char *path, Error **errp)
diff --git a/monitor/misc.c b/monitor/misc.c
index aef16f6cfb..feadf9780c 100644
--- a/monitor/misc.c
+++ b/monitor/misc.c
@@ -1776,19 +1776,17 @@ void monitor_fdset_dup_fd_remove(int dup_fd)
 int monitor_fd_param(Monitor *mon, const char *fdname, Error **errp)
 {
     int fd;
-    Error *local_err = NULL;
 
     if (!qemu_isdigit(fdname[0]) && mon) {
-        fd = monitor_get_fd(mon, fdname, &local_err);
+        fd = monitor_get_fd(mon, fdname, errp);
     } else {
         fd = qemu_parse_fd(fdname);
         if (fd == -1) {
-            error_setg(&local_err, "Invalid file descriptor number '%s'",
+            error_setg(errp, "Invalid file descriptor number '%s'",
                        fdname);
         }
     }
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         assert(fd == -1);
     } else {
         assert(fd != -1);
diff --git a/monitor/qmp-cmds.c b/monitor/qmp-cmds.c
index 0880341a2d..d85b6693e5 100644
--- a/monitor/qmp-cmds.c
+++ b/monitor/qmp-cmds.c
@@ -128,7 +128,6 @@ void qmp_cont(Error **errp)
 {
     BlockBackend *blk;
     BlockJob *job;
-    Error *local_err = NULL;
 
     /* if there is a dump in background, we should wait until the dump
      * finished */
@@ -161,9 +160,8 @@ void qmp_cont(Error **errp)
      * If there are no inactive block nodes (e.g. because the VM was just
      * paused rather than completing a migration), bdrv_inactivate_all() simply
      * doesn't do anything. */
-    bdrv_invalidate_cache_all(&local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    bdrv_invalidate_cache_all(errp);
+    if (*errp) {
         return;
     }
 
diff --git a/net/can/can_host.c b/net/can/can_host.c
index 1dfaf0ced0..e9b4ac9075 100644
--- a/net/can/can_host.c
+++ b/net/can/can_host.c
@@ -51,11 +51,9 @@ static void can_host_disconnect(CanHostState *ch)
 static void can_host_connect(CanHostState *ch, Error **errp)
 {
     CanHostClass *chc = CAN_HOST_GET_CLASS(ch);
-    Error *local_err = NULL;
 
-    chc->connect(ch, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    chc->connect(ch, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/net/dump.c b/net/dump.c
index 23b3628dde..ac6900e34f 100644
--- a/net/dump.c
+++ b/net/dump.c
@@ -192,22 +192,18 @@ static void filter_dump_set_maxlen(Object *obj, Visitor *v, const char *name,
                                    void *opaque, Error **errp)
 {
     NetFilterDumpState *nfds = FILTER_DUMP(obj);
-    Error *local_err = NULL;
     uint32_t value;
 
-    visit_type_uint32(v, name, &value, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_uint32(v, name, &value, errp);
+    if (*errp) {
+        return;
     }
     if (value == 0) {
-        error_setg(&local_err, "Property '%s.%s' doesn't take value '%u'",
+        error_setg(errp, "Property '%s.%s' doesn't take value '%u'",
                    object_get_typename(obj), name, value);
-        goto out;
+        return;
     }
     nfds->maxlen = value;
-
-out:
-    error_propagate(errp, local_err);
 }
 
 static char *file_dump_get_filename(Object *obj, Error **errp)
diff --git a/net/filter-buffer.c b/net/filter-buffer.c
index 88da78f821..69f37e273b 100644
--- a/net/filter-buffer.c
+++ b/net/filter-buffer.c
@@ -170,22 +170,18 @@ static void filter_buffer_set_interval(Object *obj, Visitor *v,
                                        Error **errp)
 {
     FilterBufferState *s = FILTER_BUFFER(obj);
-    Error *local_err = NULL;
     uint32_t value;
 
-    visit_type_uint32(v, name, &value, &local_err);
-    if (local_err) {
-        goto out;
+    visit_type_uint32(v, name, &value, errp);
+    if (*errp) {
+        return;
     }
     if (!value) {
-        error_setg(&local_err, "Property '%s.%s' requires a positive value",
+        error_setg(errp, "Property '%s.%s' requires a positive value",
                    object_get_typename(obj), name);
-        goto out;
+        return;
     }
     s->interval = value;
-
-out:
-    error_propagate(errp, local_err);
 }
 
 static void filter_buffer_init(Object *obj)
diff --git a/net/filter.c b/net/filter.c
index 4b932e79f9..114723a6db 100644
--- a/net/filter.c
+++ b/net/filter.c
@@ -195,7 +195,6 @@ static void netfilter_complete(UserCreatable *uc, Error **errp)
     NetClientState *ncs[MAX_QUEUE_NUM];
     NetFilterClass *nfc = NETFILTER_GET_CLASS(uc);
     int queues;
-    Error *local_err = NULL;
 
     if (!nf->netdev_id) {
         error_setg(errp, "Parameter 'netdev' is required");
@@ -222,9 +221,8 @@ static void netfilter_complete(UserCreatable *uc, Error **errp)
     nf->netdev = ncs[0];
 
     if (nfc->setup) {
-        nfc->setup(nf, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        nfc->setup(nf, errp);
+        if (*errp) {
             return;
         }
     }
diff --git a/net/net.c b/net/net.c
index 5fc72511c1..ea8975b219 100644
--- a/net/net.c
+++ b/net/net.c
@@ -1100,7 +1100,6 @@ static int net_client_init(QemuOpts *opts, bool is_netdev, Error **errp)
 {
     gchar **substrings = NULL;
     void *object = NULL;
-    Error *err = NULL;
     int ret = -1;
     Visitor *v = opts_visitor_new(opts);
 
@@ -1146,13 +1145,13 @@ static int net_client_init(QemuOpts *opts, bool is_netdev, Error **errp)
     }
 
     if (is_netdev) {
-        visit_type_Netdev(v, NULL, (Netdev **)&object, &err);
+        visit_type_Netdev(v, NULL, (Netdev **)&object, errp);
     } else {
-        visit_type_NetLegacy(v, NULL, (NetLegacy **)&object, &err);
+        visit_type_NetLegacy(v, NULL, (NetLegacy **)&object, errp);
     }
 
-    if (!err) {
-        ret = net_client_init1(object, is_netdev, &err);
+    if (!*errp) {
+        ret = net_client_init1(object, is_netdev, errp);
     }
 
     if (is_netdev) {
@@ -1162,7 +1161,6 @@ static int net_client_init(QemuOpts *opts, bool is_netdev, Error **errp)
     }
 
 out:
-    error_propagate(errp, err);
     g_strfreev(substrings);
     visit_free(v);
     return ret;
@@ -1175,28 +1173,24 @@ void netdev_add(QemuOpts *opts, Error **errp)
 
 void qmp_netdev_add(QDict *qdict, QObject **ret, Error **errp)
 {
-    Error *local_err = NULL;
     QemuOptsList *opts_list;
     QemuOpts *opts;
 
-    opts_list = qemu_find_opts_err("netdev", &local_err);
-    if (local_err) {
-        goto out;
+    opts_list = qemu_find_opts_err("netdev", errp);
+    if (*errp) {
+        return;
     }
 
-    opts = qemu_opts_from_qdict(opts_list, qdict, &local_err);
-    if (local_err) {
-        goto out;
+    opts = qemu_opts_from_qdict(opts_list, qdict, errp);
+    if (*errp) {
+        return;
     }
 
-    netdev_add(opts, &local_err);
-    if (local_err) {
+    netdev_add(opts, errp);
+    if (*errp) {
         qemu_opts_del(opts);
-        goto out;
+        return;
     }
-
-out:
-    error_propagate(errp, local_err);
 }
 
 void qmp_netdev_del(const char *id, Error **errp)
@@ -1354,14 +1348,12 @@ void colo_notify_filters_event(int event, Error **errp)
     NetClientState *nc;
     NetFilterState *nf;
     NetFilterClass *nfc = NULL;
-    Error *local_err = NULL;
 
     QTAILQ_FOREACH(nc, &net_clients, next) {
         QTAILQ_FOREACH(nf, &nc->filters, next) {
             nfc = NETFILTER_GET_CLASS(OBJECT(nf));
-            nfc->handle_event(nf, event, &local_err);
-            if (local_err) {
-                error_propagate(errp, local_err);
+            nfc->handle_event(nf, event, errp);
+            if (*errp) {
                 return;
             }
         }
diff --git a/net/netmap.c b/net/netmap.c
index 350f097f91..57c7dcdaed 100644
--- a/net/netmap.c
+++ b/net/netmap.c
@@ -409,12 +409,10 @@ int net_init_netmap(const Netdev *netdev,
     const NetdevNetmapOptions *netmap_opts = &netdev->u.netmap;
     struct nm_desc *nmd;
     NetClientState *nc;
-    Error *err = NULL;
     NetmapState *s;
 
-    nmd = netmap_open(netmap_opts, &err);
-    if (err) {
-        error_propagate(errp, err);
+    nmd = netmap_open(netmap_opts, errp);
+    if (*errp) {
         return -1;
     }
     /* Create the object. */
diff --git a/net/slirp.c b/net/slirp.c
index f42f496641..121bc8e6ab 100644
--- a/net/slirp.c
+++ b/net/slirp.c
@@ -979,7 +979,6 @@ static int slirp_guestfwd(SlirpState *s, const char *config_str, Error **errp)
             return -1;
         }
     } else {
-        Error *err = NULL;
         /*
          * FIXME: sure we want to support implicit
          * muxed monitors here?
@@ -993,9 +992,8 @@ static int slirp_guestfwd(SlirpState *s, const char *config_str, Error **errp)
         }
 
         fwd = g_new(struct GuestFwd, 1);
-        qemu_chr_fe_init(&fwd->hd, chr, &err);
-        if (err) {
-            error_propagate(errp, err);
+        qemu_chr_fe_init(&fwd->hd, chr, errp);
+        if (*errp) {
             object_unparent(OBJECT(chr));
             g_free(fwd);
             return -1;
diff --git a/net/tap-bsd.c b/net/tap-bsd.c
index a5c3707f80..0eb836a020 100644
--- a/net/tap-bsd.c
+++ b/net/tap-bsd.c
@@ -209,6 +209,7 @@ error:
 
 void tap_set_sndbuf(int fd, const NetdevTapOptions *tap, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 int tap_probe_vnet_hdr(int fd)
diff --git a/net/tap-solaris.c b/net/tap-solaris.c
index 4725d2314e..14f201fced 100644
--- a/net/tap-solaris.c
+++ b/net/tap-solaris.c
@@ -204,6 +204,7 @@ int tap_open(char *ifname, int ifname_size, int *vnet_hdr,
 
 void tap_set_sndbuf(int fd, const NetdevTapOptions *tap, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 int tap_probe_vnet_hdr(int fd)
diff --git a/net/tap-stub.c b/net/tap-stub.c
index a9ab8f8293..32abb54bc9 100644
--- a/net/tap-stub.c
+++ b/net/tap-stub.c
@@ -35,6 +35,7 @@ int tap_open(char *ifname, int ifname_size, int *vnet_hdr,
 
 void tap_set_sndbuf(int fd, const NetdevTapOptions *tap, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 int tap_probe_vnet_hdr(int fd)
diff --git a/net/tap.c b/net/tap.c
index 6207f61f84..cca87fe787 100644
--- a/net/tap.c
+++ b/net/tap.c
@@ -610,7 +610,6 @@ static int net_tap_init(const NetdevTapOptions *tap, int *vnet_hdr,
                         const char *setup_script, char *ifname,
                         size_t ifname_sz, int mq_required, Error **errp)
 {
-    Error *err = NULL;
     int fd, vnet_hdr_required;
 
     if (tap->has_vnet_hdr) {
@@ -630,9 +629,8 @@ static int net_tap_init(const NetdevTapOptions *tap, int *vnet_hdr,
     if (setup_script &&
         setup_script[0] != '\0' &&
         strcmp(setup_script, "no") != 0) {
-        launch_script(setup_script, ifname, fd, &err);
-        if (err) {
-            error_propagate(errp, err);
+        launch_script(setup_script, ifname, fd, errp);
+        if (*errp) {
             close(fd);
             return -1;
         }
@@ -649,13 +647,11 @@ static void net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,
                              const char *downscript, const char *vhostfdname,
                              int vnet_hdr, int fd, Error **errp)
 {
-    Error *err = NULL;
     TAPState *s = net_tap_fd_init(peer, model, name, fd, vnet_hdr);
     int vhostfd;
 
-    tap_set_sndbuf(s->fd, tap, &err);
-    if (err) {
-        error_propagate(errp, err);
+    tap_set_sndbuf(s->fd, tap, errp);
+    if (*errp) {
         return;
     }
 
@@ -689,12 +685,11 @@ static void net_init_tap_one(const NetdevTapOptions *tap, NetClientState *peer,
         }
 
         if (vhostfdname) {
-            vhostfd = monitor_fd_param(cur_mon, vhostfdname, &err);
+            vhostfd = monitor_fd_param(cur_mon, vhostfdname, errp);
             if (vhostfd == -1) {
                 if (tap->has_vhostforce && tap->vhostforce) {
-                    error_propagate(errp, err);
                 } else {
-                    warn_report_err(err);
+                    warn_report_errp(errp);
                 }
                 return;
             }
@@ -763,7 +758,6 @@ int net_init_tap(const Netdev *netdev, const char *name,
     /* for the no-fd, no-helper case */
     const char *script = NULL; /* suppress wrong "uninit'd use" gcc warning */
     const char *downscript = NULL;
-    Error *err = NULL;
     const char *vhostfdname;
     char ifname[128];
 
@@ -789,9 +783,8 @@ int net_init_tap(const Netdev *netdev, const char *name,
             return -1;
         }
 
-        fd = monitor_fd_param(cur_mon, tap->fd, &err);
+        fd = monitor_fd_param(cur_mon, tap->fd, errp);
         if (fd == -1) {
-            error_propagate(errp, err);
             return -1;
         }
 
@@ -801,9 +794,8 @@ int net_init_tap(const Netdev *netdev, const char *name,
 
         net_init_tap_one(tap, peer, "tap", name, NULL,
                          script, downscript,
-                         vhostfdname, vnet_hdr, fd, &err);
-        if (err) {
-            error_propagate(errp, err);
+                         vhostfdname, vnet_hdr, fd, errp);
+        if (*errp) {
             return -1;
         }
     } else if (tap->has_fds) {
@@ -836,9 +828,8 @@ int net_init_tap(const Netdev *netdev, const char *name,
         }
 
         for (i = 0; i < nfds; i++) {
-            fd = monitor_fd_param(cur_mon, fds[i], &err);
+            fd = monitor_fd_param(cur_mon, fds[i], errp);
             if (fd == -1) {
-                error_propagate(errp, err);
                 ret = -1;
                 goto free_fail;
             }
@@ -857,9 +848,8 @@ int net_init_tap(const Netdev *netdev, const char *name,
             net_init_tap_one(tap, peer, "tap", name, ifname,
                              script, downscript,
                              tap->has_vhostfds ? vhost_fds[i] : NULL,
-                             vnet_hdr, fd, &err);
-            if (err) {
-                error_propagate(errp, err);
+                             vnet_hdr, fd, errp);
+            if (*errp) {
                 ret = -1;
                 goto free_fail;
             }
@@ -896,9 +886,8 @@ free_fail:
 
         net_init_tap_one(tap, peer, "bridge", name, ifname,
                          script, downscript, vhostfdname,
-                         vnet_hdr, fd, &err);
-        if (err) {
-            error_propagate(errp, err);
+                         vnet_hdr, fd, errp);
+        if (*errp) {
             close(fd);
             return -1;
         }
@@ -935,9 +924,8 @@ free_fail:
             net_init_tap_one(tap, peer, "tap", name, ifname,
                              i >= 1 ? "no" : script,
                              i >= 1 ? "no" : downscript,
-                             vhostfdname, vnet_hdr, fd, &err);
-            if (err) {
-                error_propagate(errp, err);
+                             vhostfdname, vnet_hdr, fd, errp);
+            if (*errp) {
                 close(fd);
                 return -1;
             }
diff --git a/qapi/opts-visitor.c b/qapi/opts-visitor.c
index 324b197495..35c510c959 100644
--- a/qapi/opts-visitor.c
+++ b/qapi/opts-visitor.c
@@ -275,6 +275,7 @@ opts_next_list(Visitor *v, GenericList *tail, size_t size)
 static void
 opts_check_list(Visitor *v, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
     /*
      * Unvisited list elements will be reported later when checking
      * whether unvisited struct members remain.
diff --git a/qapi/qapi-dealloc-visitor.c b/qapi/qapi-dealloc-visitor.c
index d192724b13..3ee4c7a2e7 100644
--- a/qapi/qapi-dealloc-visitor.c
+++ b/qapi/qapi-dealloc-visitor.c
@@ -25,6 +25,7 @@ struct QapiDeallocVisitor
 static void qapi_dealloc_start_struct(Visitor *v, const char *name, void **obj,
                                       size_t unused, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static void qapi_dealloc_end_struct(Visitor *v, void **obj)
@@ -38,6 +39,7 @@ static void qapi_dealloc_start_alternate(Visitor *v, const char *name,
                                          GenericAlternate **obj, size_t size,
                                          Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static void qapi_dealloc_end_alternate(Visitor *v, void **obj)
@@ -51,6 +53,7 @@ static void qapi_dealloc_start_list(Visitor *v, const char *name,
                                     GenericList **list, size_t size,
                                     Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static GenericList *qapi_dealloc_next_list(Visitor *v, GenericList *tail,
@@ -76,21 +79,25 @@ static void qapi_dealloc_type_str(Visitor *v, const char *name, char **obj,
 static void qapi_dealloc_type_int64(Visitor *v, const char *name, int64_t *obj,
                                     Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static void qapi_dealloc_type_uint64(Visitor *v, const char *name,
                                      uint64_t *obj, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static void qapi_dealloc_type_bool(Visitor *v, const char *name, bool *obj,
                                    Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static void qapi_dealloc_type_number(Visitor *v, const char *name, double *obj,
                                      Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 static void qapi_dealloc_type_anything(Visitor *v, const char *name,
diff --git a/qapi/qapi-visit-core.c b/qapi/qapi-visit-core.c
index 5365561b07..64943ebeb7 100644
--- a/qapi/qapi-visit-core.c
+++ b/qapi/qapi-visit-core.c
@@ -39,18 +39,15 @@ void visit_free(Visitor *v)
 void visit_start_struct(Visitor *v, const char *name, void **obj,
                         size_t size, Error **errp)
 {
-    Error *err = NULL;
-
     trace_visit_start_struct(v, name, obj, size);
     if (obj) {
         assert(size);
         assert(!(v->type & VISITOR_OUTPUT) || *obj);
     }
-    v->start_struct(v, name, obj, size, &err);
+    v->start_struct(v, name, obj, size, errp);
     if (obj && (v->type & VISITOR_INPUT)) {
-        assert(!err != !*obj);
+        assert(!*errp != !*obj);
     }
-    error_propagate(errp, err);
 }
 
 void visit_check_struct(Visitor *v, Error **errp)
@@ -70,15 +67,12 @@ void visit_end_struct(Visitor *v, void **obj)
 void visit_start_list(Visitor *v, const char *name, GenericList **list,
                       size_t size, Error **errp)
 {
-    Error *err = NULL;
-
     assert(!list || size >= sizeof(GenericList));
     trace_visit_start_list(v, name, list, size);
-    v->start_list(v, name, list, size, &err);
+    v->start_list(v, name, list, size, errp);
     if (list && (v->type & VISITOR_INPUT)) {
-        assert(!(err && *list));
+        assert(!(*errp && *list));
     }
-    error_propagate(errp, err);
 }
 
 GenericList *visit_next_list(Visitor *v, GenericList *tail, size_t size)
@@ -106,18 +100,15 @@ void visit_start_alternate(Visitor *v, const char *name,
                            GenericAlternate **obj, size_t size,
                            Error **errp)
 {
-    Error *err = NULL;
-
     assert(obj && size >= sizeof(GenericAlternate));
     assert(!(v->type & VISITOR_OUTPUT) || *obj);
     trace_visit_start_alternate(v, name, obj, size);
     if (v->start_alternate) {
-        v->start_alternate(v, name, obj, size, &err);
+        v->start_alternate(v, name, obj, size, errp);
     }
     if (v->type & VISITOR_INPUT) {
-        assert(v->start_alternate && !err != !*obj);
+        assert(v->start_alternate && !*errp != !*obj);
     }
-    error_propagate(errp, err);
 }
 
 void visit_end_alternate(Visitor *v, void **obj)
@@ -152,12 +143,10 @@ void visit_type_int(Visitor *v, const char *name, int64_t *obj, Error **errp)
 static void visit_type_uintN(Visitor *v, uint64_t *obj, const char *name,
                              uint64_t max, const char *type, Error **errp)
 {
-    Error *err = NULL;
     uint64_t value = *obj;
 
-    v->type_uint64(v, name, &value, &err);
-    if (err) {
-        error_propagate(errp, err);
+    v->type_uint64(v, name, &value, errp);
+    if (*errp) {
     } else if (value > max) {
         error_setg(errp, QERR_INVALID_PARAMETER_VALUE,
                    name ? name : "null", type);
@@ -211,12 +200,10 @@ static void visit_type_intN(Visitor *v, int64_t *obj, const char *name,
                             int64_t min, int64_t max, const char *type,
                             Error **errp)
 {
-    Error *err = NULL;
     int64_t value = *obj;
 
-    v->type_int64(v, name, &value, &err);
-    if (err) {
-        error_propagate(errp, err);
+    v->type_int64(v, name, &value, errp);
+    if (*errp) {
     } else if (value < min || value > max) {
         error_setg(errp, QERR_INVALID_PARAMETER_VALUE,
                    name ? name : "null", type);
@@ -286,19 +273,16 @@ void visit_type_bool(Visitor *v, const char *name, bool *obj, Error **errp)
 
 void visit_type_str(Visitor *v, const char *name, char **obj, Error **errp)
 {
-    Error *err = NULL;
-
     assert(obj);
     /* TODO: Fix callers to not pass NULL when they mean "", so that we
      * can enable:
     assert(!(v->type & VISITOR_OUTPUT) || *obj);
      */
     trace_visit_type_str(v, name, obj);
-    v->type_str(v, name, obj, &err);
+    v->type_str(v, name, obj, errp);
     if (v->type & VISITOR_INPUT) {
-        assert(!err != !*obj);
+        assert(!*errp != !*obj);
     }
-    error_propagate(errp, err);
 }
 
 void visit_type_number(Visitor *v, const char *name, double *obj,
@@ -311,16 +295,13 @@ void visit_type_number(Visitor *v, const char *name, double *obj,
 
 void visit_type_any(Visitor *v, const char *name, QObject **obj, Error **errp)
 {
-    Error *err = NULL;
-
     assert(obj);
     assert(v->type != VISITOR_OUTPUT || *obj);
     trace_visit_type_any(v, name, obj);
-    v->type_any(v, name, obj, &err);
+    v->type_any(v, name, obj, errp);
     if (v->type == VISITOR_INPUT) {
-        assert(!err != !*obj);
+        assert(!*errp != !*obj);
     }
-    error_propagate(errp, err);
 }
 
 void visit_type_null(Visitor *v, const char *name, QNull **obj,
@@ -352,13 +333,11 @@ static void output_type_enum(Visitor *v, const char *name, int *obj,
 static void input_type_enum(Visitor *v, const char *name, int *obj,
                             const QEnumLookup *lookup, Error **errp)
 {
-    Error *local_err = NULL;
     int64_t value;
     char *enum_str;
 
-    visit_type_str(v, name, &enum_str, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &enum_str, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/qapi/qmp-dispatch.c b/qapi/qmp-dispatch.c
index 3037d353a4..5c75322a7d 100644
--- a/qapi/qmp-dispatch.c
+++ b/qapi/qmp-dispatch.c
@@ -78,7 +78,6 @@ static QDict *qmp_dispatch_check_obj(const QObject *request, bool allow_oob,
 static QObject *do_qmp_dispatch(QmpCommandList *cmds, QObject *request,
                                 bool allow_oob, Error **errp)
 {
-    Error *local_err = NULL;
     bool oob;
     const char *command;
     QDict *args, *dict;
@@ -128,9 +127,8 @@ static QObject *do_qmp_dispatch(QmpCommandList *cmds, QObject *request,
         qobject_ref(args);
     }
 
-    cmd->fn(args, &ret, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    cmd->fn(args, &ret, errp);
+    if (*errp) {
     } else if (cmd->options & QCO_NO_SUCCESS_RESP) {
         g_assert(!ret);
     } else if (!ret) {
diff --git a/qapi/string-input-visitor.c b/qapi/string-input-visitor.c
index 9be418b6d6..302c5ddadf 100644
--- a/qapi/string-input-visitor.c
+++ b/qapi/string-input-visitor.c
@@ -314,13 +314,11 @@ static void parse_type_size(Visitor *v, const char *name, uint64_t *obj,
                             Error **errp)
 {
     StringInputVisitor *siv = to_siv(v);
-    Error *err = NULL;
     uint64_t val;
 
     assert(siv->lm == LM_NONE);
-    parse_option_size(name, siv->string, &val, &err);
-    if (err) {
-        error_propagate(errp, err);
+    parse_option_size(name, siv->string, &val, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/qdev-monitor.c b/qdev-monitor.c
index 148df9cacf..dd17ad4967 100644
--- a/qdev-monitor.c
+++ b/qdev-monitor.c
@@ -171,16 +171,14 @@ static int set_property(void *opaque, const char *name, const char *value,
                         Error **errp)
 {
     Object *obj = opaque;
-    Error *err = NULL;
 
     if (strcmp(name, "driver") == 0)
         return 0;
     if (strcmp(name, "bus") == 0)
         return 0;
 
-    object_property_parse(obj, value, name, &err);
-    if (err != NULL) {
-        error_propagate(errp, err);
+    object_property_parse(obj, value, name, errp);
+    if (*errp != NULL) {
         return -1;
     }
     return 0;
@@ -568,7 +566,6 @@ DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
     const char *driver, *path;
     DeviceState *dev;
     BusState *bus = NULL;
-    Error *err = NULL;
 
     driver = qemu_opt_get(opts, "driver");
     if (!driver) {
@@ -616,9 +613,9 @@ DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
     dev = DEVICE(object_new(driver));
 
     /* Check whether the hotplug is allowed by the machine */
-    if (qdev_hotplug && !qdev_hotplug_allowed(dev, &err)) {
+    if (qdev_hotplug && !qdev_hotplug_allowed(dev, errp)) {
         /* Error must be set in the machine hook */
-        assert(err);
+        assert(*errp);
         goto err_del_dev;
     }
 
@@ -626,7 +623,7 @@ DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
         qdev_set_parent_bus(dev, bus);
     } else if (qdev_hotplug && !qdev_get_machine_hotplug_handler(dev)) {
         /* No bus, no machine hotplug handler --> device is not hotpluggable */
-        error_setg(&err, "Device '%s' can not be hotplugged on this machine",
+        error_setg(errp, "Device '%s' can not be hotplugged on this machine",
                    driver);
         goto err_del_dev;
     }
@@ -634,20 +631,19 @@ DeviceState *qdev_device_add(QemuOpts *opts, Error **errp)
     qdev_set_id(dev, qemu_opts_id(opts));
 
     /* set properties */
-    if (qemu_opt_foreach(opts, set_property, dev, &err)) {
+    if (qemu_opt_foreach(opts, set_property, dev, errp)) {
         goto err_del_dev;
     }
 
     dev->opts = opts;
-    object_property_set_bool(OBJECT(dev), true, "realized", &err);
-    if (err != NULL) {
+    object_property_set_bool(OBJECT(dev), true, "realized", errp);
+    if (*errp != NULL) {
         dev->opts = NULL;
         goto err_del_dev;
     }
     return dev;
 
 err_del_dev:
-    error_propagate(errp, err);
     object_unparent(OBJECT(dev));
     object_unref(OBJECT(dev));
     return NULL;
@@ -749,22 +745,19 @@ void hmp_info_qdm(Monitor *mon, const QDict *qdict)
 
 void qmp_device_add(QDict *qdict, QObject **ret_data, Error **errp)
 {
-    Error *local_err = NULL;
     QemuOpts *opts;
     DeviceState *dev;
 
-    opts = qemu_opts_from_qdict(qemu_find_opts("device"), qdict, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    opts = qemu_opts_from_qdict(qemu_find_opts("device"), qdict, errp);
+    if (*errp) {
         return;
     }
     if (!monitor_cur_is_qmp() && qdev_device_help(opts)) {
         qemu_opts_del(opts);
         return;
     }
-    dev = qdev_device_add(opts, &local_err);
+    dev = qdev_device_add(opts, errp);
     if (!dev) {
-        error_propagate(errp, local_err);
         qemu_opts_del(opts);
         return;
     }
@@ -805,7 +798,6 @@ void qdev_unplug(DeviceState *dev, Error **errp)
     DeviceClass *dc = DEVICE_GET_CLASS(dev);
     HotplugHandler *hotplug_ctrl;
     HotplugHandlerClass *hdc;
-    Error *local_err = NULL;
 
     if (dev->parent_bus && !qbus_is_hotpluggable(dev->parent_bus)) {
         error_setg(errp, QERR_BUS_NO_HOTPLUG, dev->parent_bus->name);
@@ -834,14 +826,13 @@ void qdev_unplug(DeviceState *dev, Error **errp)
      * otherwise just remove it synchronously */
     hdc = HOTPLUG_HANDLER_GET_CLASS(hotplug_ctrl);
     if (hdc->unplug_request) {
-        hotplug_handler_unplug_request(hotplug_ctrl, dev, &local_err);
+        hotplug_handler_unplug_request(hotplug_ctrl, dev, errp);
     } else {
-        hotplug_handler_unplug(hotplug_ctrl, dev, &local_err);
-        if (!local_err) {
+        hotplug_handler_unplug(hotplug_ctrl, dev, errp);
+        if (!*errp) {
             object_unparent(OBJECT(dev));
         }
     }
-    error_propagate(errp, local_err);
 }
 
 void qmp_device_del(const char *id, Error **errp)
diff --git a/qga/commands-posix.c b/qga/commands-posix.c
index dfc05f5b8a..a2874e272e 100644
--- a/qga/commands-posix.c
+++ b/qga/commands-posix.c
@@ -83,7 +83,6 @@ static void ga_wait_child(pid_t pid, int *status, Error **errp)
 void qmp_guest_shutdown(bool has_mode, const char *mode, Error **errp)
 {
     const char *shutdown_flag;
-    Error *local_err = NULL;
     pid_t pid;
     int status;
 
@@ -116,9 +115,8 @@ void qmp_guest_shutdown(bool has_mode, const char *mode, Error **errp)
         return;
     }
 
-    ga_wait_child(pid, &status, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ga_wait_child(pid, &status, errp);
+    if (*errp) {
         return;
     }
 
@@ -154,7 +152,6 @@ void qmp_guest_set_time(bool has_time, int64_t time_ns, Error **errp)
     int ret;
     int status;
     pid_t pid;
-    Error *local_err = NULL;
     struct timeval tv;
 
     /* If user has passed a time, validate and set it. */
@@ -203,9 +200,8 @@ void qmp_guest_set_time(bool has_time, int64_t time_ns, Error **errp)
         return;
     }
 
-    ga_wait_child(pid, &status, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ga_wait_child(pid, &status, errp);
+    if (*errp) {
         return;
     }
 
@@ -328,11 +324,10 @@ find_open_flag(const char *mode_str, Error **errp)
 static FILE *
 safe_open_or_create(const char *path, const char *mode, Error **errp)
 {
-    Error *local_err = NULL;
     int oflag;
 
-    oflag = find_open_flag(mode, &local_err);
-    if (local_err == NULL) {
+    oflag = find_open_flag(mode, errp);
+    if (*errp == NULL) {
         int fd;
 
         /* If the caller wants / allows creation of a new file, we implement it
@@ -364,13 +359,13 @@ safe_open_or_create(const char *path, const char *mode, Error **errp)
         }
 
         if (fd == -1) {
-            error_setg_errno(&local_err, errno, "failed to open file '%s' "
+            error_setg_errno(errp, errno, "failed to open file '%s' "
                              "(mode: '%s')", path, mode);
         } else {
             qemu_set_cloexec(fd);
 
             if ((oflag & O_CREAT) && fchmod(fd, DEFAULT_NEW_FILE_MODE) == -1) {
-                error_setg_errno(&local_err, errno, "failed to set permission "
+                error_setg_errno(errp, errno, "failed to set permission "
                                  "0%03o on new file '%s' (mode: '%s')",
                                  (unsigned)DEFAULT_NEW_FILE_MODE, path, mode);
             } else {
@@ -378,7 +373,7 @@ safe_open_or_create(const char *path, const char *mode, Error **errp)
 
                 f = fdopen(fd, mode);
                 if (f == NULL) {
-                    error_setg_errno(&local_err, errno, "failed to associate "
+                    error_setg_errno(errp, errno, "failed to associate "
                                      "stdio stream with file descriptor %d, "
                                      "file '%s' (mode: '%s')", fd, path, mode);
                 } else {
@@ -393,7 +388,6 @@ safe_open_or_create(const char *path, const char *mode, Error **errp)
         }
     }
 
-    error_propagate(errp, local_err);
     return NULL;
 }
 
@@ -401,16 +395,14 @@ int64_t qmp_guest_file_open(const char *path, bool has_mode, const char *mode,
                             Error **errp)
 {
     FILE *fh;
-    Error *local_err = NULL;
     int64_t handle;
 
     if (!has_mode) {
         mode = "r";
     }
     slog("guest-file-open called, filepath: %s, mode: %s", path, mode);
-    fh = safe_open_or_create(path, mode, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    fh = safe_open_or_create(path, mode, errp);
+    if (*errp != NULL) {
         return -1;
     }
 
@@ -568,16 +560,14 @@ struct GuestFileSeek *qmp_guest_file_seek(int64_t handle, int64_t offset,
     FILE *fh;
     int ret;
     int whence;
-    Error *err = NULL;
 
     if (!gfh) {
         return NULL;
     }
 
     /* We stupidly exposed 'whence':'int' in our qapi */
-    whence = ga_parse_whence(whence_code, &err);
-    if (err) {
-        error_propagate(errp, err);
+    whence = ga_parse_whence(whence_code, errp);
+    if (*errp) {
         return NULL;
     }
 
@@ -1153,12 +1143,10 @@ GuestFilesystemInfoList *qmp_guest_get_fsinfo(Error **errp)
     FsMountList mounts;
     struct FsMount *mount;
     GuestFilesystemInfoList *new, *ret = NULL;
-    Error *local_err = NULL;
 
     QTAILQ_INIT(&mounts);
-    build_fs_mount_list(&mounts, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    build_fs_mount_list(&mounts, errp);
+    if (*errp) {
         return NULL;
     }
 
@@ -1166,11 +1154,10 @@ GuestFilesystemInfoList *qmp_guest_get_fsinfo(Error **errp)
         g_debug("Building guest fsinfo for '%s'", mount->dirname);
 
         new = g_malloc0(sizeof(*ret));
-        new->value = build_guest_fsinfo(mount, &local_err);
+        new->value = build_guest_fsinfo(mount, errp);
         new->next = ret;
         ret = new;
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             qapi_free_GuestFilesystemInfoList(ret);
             ret = NULL;
             break;
@@ -1198,7 +1185,6 @@ static void execute_fsfreeze_hook(FsfreezeHookArg arg, Error **errp)
     pid_t pid;
     const char *hook;
     const char *arg_str = fsfreeze_hook_arg_string[arg];
-    Error *local_err = NULL;
 
     hook = ga_fsfreeze_hook(ga_state);
     if (!hook) {
@@ -1224,9 +1210,8 @@ static void execute_fsfreeze_hook(FsfreezeHookArg arg, Error **errp)
         return;
     }
 
-    ga_wait_child(pid, &status, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ga_wait_child(pid, &status, errp);
+    if (*errp) {
         return;
     }
 
@@ -1271,21 +1256,18 @@ int64_t qmp_guest_fsfreeze_freeze_list(bool has_mountpoints,
     strList *list;
     FsMountList mounts;
     struct FsMount *mount;
-    Error *local_err = NULL;
     int fd;
 
     slog("guest-fsfreeze called");
 
-    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    execute_fsfreeze_hook(FSFREEZE_HOOK_FREEZE, errp);
+    if (*errp) {
         return -1;
     }
 
     QTAILQ_INIT(&mounts);
-    build_fs_mount_list(&mounts, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    build_fs_mount_list(&mounts, errp);
+    if (*errp) {
         return -1;
     }
 
@@ -1362,12 +1344,10 @@ int64_t qmp_guest_fsfreeze_thaw(Error **errp)
     FsMountList mounts;
     FsMount *mount;
     int fd, i = 0, logged;
-    Error *local_err = NULL;
 
     QTAILQ_INIT(&mounts);
-    build_fs_mount_list(&mounts, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    build_fs_mount_list(&mounts, errp);
+    if (*errp) {
         return 0;
     }
 
@@ -1440,15 +1420,13 @@ qmp_guest_fstrim(bool has_minimum, int64_t minimum, Error **errp)
     FsMountList mounts;
     struct FsMount *mount;
     int fd;
-    Error *local_err = NULL;
     struct fstrim_range r;
 
     slog("guest-fstrim called");
 
     QTAILQ_INIT(&mounts);
-    build_fs_mount_list(&mounts, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    build_fs_mount_list(&mounts, errp);
+    if (*errp) {
         return NULL;
     }
 
@@ -1554,13 +1532,12 @@ static int run_process_child(const char *command[], Error **errp)
 
 static bool systemd_supports_mode(SuspendMode mode, Error **errp)
 {
-    Error *local_err = NULL;
     const char *systemctl_args[3] = {"systemd-hibernate", "systemd-suspend",
                                      "systemd-hybrid-sleep"};
     const char *cmd[4] = {"systemctl", "status", systemctl_args[mode], NULL};
     int status;
 
-    status = run_process_child(cmd, &local_err);
+    status = run_process_child(cmd, errp);
 
     /*
      * systemctl status uses LSB return codes so we can expect
@@ -1574,31 +1551,28 @@ static bool systemd_supports_mode(SuspendMode mode, Error **errp)
         return true;
     }
 
-    error_propagate(errp, local_err);
     return false;
 }
 
 static void systemd_suspend(SuspendMode mode, Error **errp)
 {
-    Error *local_err = NULL;
     const char *systemctl_args[3] = {"hibernate", "suspend", "hybrid-sleep"};
     const char *cmd[3] = {"systemctl", systemctl_args[mode], NULL};
     int status;
 
-    status = run_process_child(cmd, &local_err);
+    status = run_process_child(cmd, errp);
 
     if (status == 0) {
         return;
     }
 
-    if ((status == -1) && !local_err) {
+    if ((status == -1) && !*errp) {
         error_setg(errp, "the helper program 'systemctl %s' was not found",
                    systemctl_args[mode]);
         return;
     }
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
     } else {
         error_setg(errp, "the helper program 'systemctl %s' returned an "
                    "unexpected exit status code (%d)",
@@ -1608,24 +1582,22 @@ static void systemd_suspend(SuspendMode mode, Error **errp)
 
 static bool pmutils_supports_mode(SuspendMode mode, Error **errp)
 {
-    Error *local_err = NULL;
     const char *pmutils_args[3] = {"--hibernate", "--suspend",
                                    "--suspend-hybrid"};
     const char *cmd[3] = {"pm-is-supported", pmutils_args[mode], NULL};
     int status;
 
-    status = run_process_child(cmd, &local_err);
+    status = run_process_child(cmd, errp);
 
     if (status == SUSPEND_SUPPORTED) {
         return true;
     }
 
-    if ((status == -1) && !local_err) {
+    if ((status == -1) && !*errp) {
         return false;
     }
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
     } else {
         error_setg(errp,
                    "the helper program '%s' returned an unexpected exit"
@@ -1637,26 +1609,24 @@ static bool pmutils_supports_mode(SuspendMode mode, Error **errp)
 
 static void pmutils_suspend(SuspendMode mode, Error **errp)
 {
-    Error *local_err = NULL;
     const char *pmutils_binaries[3] = {"pm-hibernate", "pm-suspend",
                                        "pm-suspend-hybrid"};
     const char *cmd[2] = {pmutils_binaries[mode], NULL};
     int status;
 
-    status = run_process_child(cmd, &local_err);
+    status = run_process_child(cmd, errp);
 
     if (status == 0) {
         return;
     }
 
-    if ((status == -1) && !local_err) {
+    if ((status == -1) && !*errp) {
         error_setg(errp, "the helper program '%s' was not found",
                    pmutils_binaries[mode]);
         return;
     }
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
     } else {
         error_setg(errp,
                    "the helper program '%s' returned an unexpected exit"
@@ -1697,7 +1667,6 @@ static bool linux_sys_state_supports_mode(SuspendMode mode, Error **errp)
 
 static void linux_sys_state_suspend(SuspendMode mode, Error **errp)
 {
-    Error *local_err = NULL;
     const char *sysfile_strs[3] = {"disk", "mem", NULL};
     const char *sysfile_str = sysfile_strs[mode];
     pid_t pid;
@@ -1733,9 +1702,8 @@ static void linux_sys_state_suspend(SuspendMode mode, Error **errp)
         return;
     }
 
-    ga_wait_child(pid, &status, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ga_wait_child(pid, &status, errp);
+    if (*errp) {
         return;
     }
 
@@ -1747,41 +1715,39 @@ static void linux_sys_state_suspend(SuspendMode mode, Error **errp)
 
 static void guest_suspend(SuspendMode mode, Error **errp)
 {
-    Error *local_err = NULL;
     bool mode_supported = false;
 
-    if (systemd_supports_mode(mode, &local_err)) {
+    if (systemd_supports_mode(mode, errp)) {
         mode_supported = true;
-        systemd_suspend(mode, &local_err);
+        systemd_suspend(mode, errp);
     }
 
-    if (!local_err) {
+    if (!*errp) {
         return;
     }
 
-    error_free(local_err);
+    error_free_errp(errp);
 
-    if (pmutils_supports_mode(mode, &local_err)) {
+    if (pmutils_supports_mode(mode, errp)) {
         mode_supported = true;
-        pmutils_suspend(mode, &local_err);
+        pmutils_suspend(mode, errp);
     }
 
-    if (!local_err) {
+    if (!*errp) {
         return;
     }
 
-    error_free(local_err);
+    error_free_errp(errp);
 
-    if (linux_sys_state_supports_mode(mode, &local_err)) {
+    if (linux_sys_state_supports_mode(mode, errp)) {
         mode_supported = true;
-        linux_sys_state_suspend(mode, &local_err);
+        linux_sys_state_suspend(mode, errp);
     }
 
     if (!mode_supported) {
         error_setg(errp,
                    "the requested suspend mode is not supported by the guest");
     } else {
-        error_propagate(errp, local_err);
     }
 }
 
@@ -2123,14 +2089,13 @@ GuestLogicalProcessorList *qmp_guest_get_vcpus(Error **errp)
     int64_t current;
     GuestLogicalProcessorList *head, **link;
     long sc_max;
-    Error *local_err = NULL;
 
     current = 0;
     head = NULL;
     link = &head;
-    sc_max = SYSCONF_EXACT(_SC_NPROCESSORS_CONF, &local_err);
+    sc_max = SYSCONF_EXACT(_SC_NPROCESSORS_CONF, errp);
 
-    while (local_err == NULL && current < sc_max) {
+    while (*errp == NULL && current < sc_max) {
         GuestLogicalProcessor *vcpu;
         GuestLogicalProcessorList *entry;
         int64_t id = current++;
@@ -2141,7 +2106,7 @@ GuestLogicalProcessorList *qmp_guest_get_vcpus(Error **errp)
             vcpu = g_malloc0(sizeof *vcpu);
             vcpu->logical_id = id;
             vcpu->has_can_offline = true; /* lolspeak ftw */
-            transfer_vcpu(vcpu, true, path, &local_err);
+            transfer_vcpu(vcpu, true, path, errp);
             entry = g_malloc0(sizeof *entry);
             entry->value = vcpu;
             *link = entry;
@@ -2150,41 +2115,38 @@ GuestLogicalProcessorList *qmp_guest_get_vcpus(Error **errp)
         g_free(path);
     }
 
-    if (local_err == NULL) {
+    if (*errp == NULL) {
         /* there's no guest with zero VCPUs */
         g_assert(head != NULL);
         return head;
     }
 
     qapi_free_GuestLogicalProcessorList(head);
-    error_propagate(errp, local_err);
     return NULL;
 }
 
 int64_t qmp_guest_set_vcpus(GuestLogicalProcessorList *vcpus, Error **errp)
 {
     int64_t processed;
-    Error *local_err = NULL;
 
     processed = 0;
     while (vcpus != NULL) {
         char *path = g_strdup_printf("/sys/devices/system/cpu/cpu%" PRId64 "/",
                                      vcpus->value->logical_id);
 
-        transfer_vcpu(vcpus->value, false, path, &local_err);
+        transfer_vcpu(vcpus->value, false, path, errp);
         g_free(path);
-        if (local_err != NULL) {
+        if (*errp != NULL) {
             break;
         }
         ++processed;
         vcpus = vcpus->next;
     }
 
-    if (local_err != NULL) {
+    if (*errp != NULL) {
         if (processed == 0) {
-            error_propagate(errp, local_err);
         } else {
-            error_free(local_err);
+            error_free_errp(errp);
         }
     }
 
@@ -2196,7 +2158,6 @@ void qmp_guest_set_user_password(const char *username,
                                  bool crypted,
                                  Error **errp)
 {
-    Error *local_err = NULL;
     char *passwd_path = NULL;
     pid_t pid;
     int status;
@@ -2268,9 +2229,8 @@ void qmp_guest_set_user_password(const char *username,
     close(datafd[1]);
     datafd[1] = -1;
 
-    ga_wait_child(pid, &status, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ga_wait_child(pid, &status, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -2359,7 +2319,6 @@ static void transfer_memory_block(GuestMemoryBlock *mem_blk, bool sys2memblk,
     char *dirpath;
     int dirfd;
     char *status;
-    Error *local_err = NULL;
 
     if (!sys2memblk) {
         DIR *dp;
@@ -2404,11 +2363,11 @@ static void transfer_memory_block(GuestMemoryBlock *mem_blk, bool sys2memblk,
     g_free(dirpath);
 
     status = g_malloc0(10);
-    ga_read_sysfs_file(dirfd, "state", status, 10, &local_err);
-    if (local_err) {
+    ga_read_sysfs_file(dirfd, "state", status, 10, errp);
+    if (*errp) {
         /* treat with sysfs file that not exist in old kernel */
         if (errno == ENOENT) {
-            error_free(local_err);
+            error_free_errp(errp);
             if (sys2memblk) {
                 mem_blk->online = true;
                 mem_blk->can_offline = false;
@@ -2418,7 +2377,6 @@ static void transfer_memory_block(GuestMemoryBlock *mem_blk, bool sys2memblk,
             }
         } else {
             if (sys2memblk) {
-                error_propagate(errp, local_err);
             } else {
                 result->response =
                     GUEST_MEMORY_BLOCK_RESPONSE_TYPE_OPERATION_FAILED;
@@ -2432,14 +2390,13 @@ static void transfer_memory_block(GuestMemoryBlock *mem_blk, bool sys2memblk,
 
         mem_blk->online = (strncmp(status, "online", 6) == 0);
 
-        ga_read_sysfs_file(dirfd, "removable", &removable, 1, &local_err);
-        if (local_err) {
+        ga_read_sysfs_file(dirfd, "removable", &removable, 1, errp);
+        if (*errp) {
             /* if no 'removable' file, it doesn't support offline mem blk */
             if (errno == ENOENT) {
-                error_free(local_err);
+                error_free_errp(errp);
                 mem_blk->can_offline = false;
             } else {
-                error_propagate(errp, local_err);
             }
         } else {
             mem_blk->can_offline = (removable != '0');
@@ -2449,9 +2406,9 @@ static void transfer_memory_block(GuestMemoryBlock *mem_blk, bool sys2memblk,
             const char *new_state = mem_blk->online ? "online" : "offline";
 
             ga_write_sysfs_file(dirfd, "state", new_state, strlen(new_state),
-                                &local_err);
-            if (local_err) {
-                error_free(local_err);
+                                errp);
+            if (*errp) {
+                error_free_errp(errp);
                 result->response =
                     GUEST_MEMORY_BLOCK_RESPONSE_TYPE_OPERATION_FAILED;
                 goto out2;
@@ -2478,7 +2435,6 @@ out1:
 GuestMemoryBlockList *qmp_guest_get_memory_blocks(Error **errp)
 {
     GuestMemoryBlockList *head, **link;
-    Error *local_err = NULL;
     struct dirent *de;
     DIR *dp;
 
@@ -2516,7 +2472,7 @@ GuestMemoryBlockList *qmp_guest_get_memory_blocks(Error **errp)
         /* The d_name is "memoryXXX",  phys_index is block id, same as XXX */
         mem_blk->phys_index = strtoul(&de->d_name[6], NULL, 10);
         mem_blk->has_can_offline = true; /* lolspeak ftw */
-        transfer_memory_block(mem_blk, true, NULL, &local_err);
+        transfer_memory_block(mem_blk, true, NULL, errp);
 
         entry = g_malloc0(sizeof *entry);
         entry->value = mem_blk;
@@ -2526,7 +2482,7 @@ GuestMemoryBlockList *qmp_guest_get_memory_blocks(Error **errp)
     }
 
     closedir(dp);
-    if (local_err == NULL) {
+    if (*errp == NULL) {
         /* there's no guest with zero memory blocks */
         if (head == NULL) {
             error_setg(errp, "guest reported zero memory blocks!");
@@ -2535,7 +2491,6 @@ GuestMemoryBlockList *qmp_guest_get_memory_blocks(Error **errp)
     }
 
     qapi_free_GuestMemoryBlockList(head);
-    error_propagate(errp, local_err);
     return NULL;
 }
 
@@ -2543,7 +2498,6 @@ GuestMemoryBlockResponseList *
 qmp_guest_set_memory_blocks(GuestMemoryBlockList *mem_blks, Error **errp)
 {
     GuestMemoryBlockResponseList *head, **link;
-    Error *local_err = NULL;
 
     head = NULL;
     link = &head;
@@ -2555,8 +2509,8 @@ qmp_guest_set_memory_blocks(GuestMemoryBlockList *mem_blks, Error **errp)
 
         result = g_malloc0(sizeof(*result));
         result->phys_index = current_mem_blk->phys_index;
-        transfer_memory_block(current_mem_blk, false, result, &local_err);
-        if (local_err) { /* should never happen */
+        transfer_memory_block(current_mem_blk, false, result, errp);
+        if (*errp) { /* should never happen */
             goto err;
         }
         entry = g_malloc0(sizeof *entry);
@@ -2570,13 +2524,11 @@ qmp_guest_set_memory_blocks(GuestMemoryBlockList *mem_blks, Error **errp)
     return head;
 err:
     qapi_free_GuestMemoryBlockResponseList(head);
-    error_propagate(errp, local_err);
     return NULL;
 }
 
 GuestMemoryBlockInfo *qmp_guest_get_memory_block_info(Error **errp)
 {
-    Error *local_err = NULL;
     char *dirpath;
     int dirfd;
     char *buf;
@@ -2592,11 +2544,10 @@ GuestMemoryBlockInfo *qmp_guest_get_memory_block_info(Error **errp)
     g_free(dirpath);
 
     buf = g_malloc0(20);
-    ga_read_sysfs_file(dirfd, "block_size_bytes", buf, 20, &local_err);
+    ga_read_sysfs_file(dirfd, "block_size_bytes", buf, 20, errp);
     close(dirfd);
-    if (local_err) {
+    if (*errp) {
         g_free(buf);
-        error_propagate(errp, local_err);
         return NULL;
     }
 
diff --git a/qga/commands-win32.c b/qga/commands-win32.c
index 6b67f16faf..0e9c171085 100644
--- a/qga/commands-win32.c
+++ b/qga/commands-win32.c
@@ -242,13 +242,12 @@ static void acquire_privilege(const char *name, Error **errp)
 {
     HANDLE token = NULL;
     TOKEN_PRIVILEGES priv;
-    Error *local_err = NULL;
 
     if (OpenProcessToken(GetCurrentProcess(),
         TOKEN_ADJUST_PRIVILEGES|TOKEN_QUERY, &token))
     {
         if (!LookupPrivilegeValue(NULL, name, &priv.Privileges[0].Luid)) {
-            error_setg(&local_err, QERR_QGA_COMMAND_FAILED,
+            error_setg(errp, QERR_QGA_COMMAND_FAILED,
                        "no luid for requested privilege");
             goto out;
         }
@@ -257,13 +256,13 @@ static void acquire_privilege(const char *name, Error **errp)
         priv.Privileges[0].Attributes = SE_PRIVILEGE_ENABLED;
 
         if (!AdjustTokenPrivileges(token, FALSE, &priv, 0, NULL, 0)) {
-            error_setg(&local_err, QERR_QGA_COMMAND_FAILED,
+            error_setg(errp, QERR_QGA_COMMAND_FAILED,
                        "unable to acquire requested privilege");
             goto out;
         }
 
     } else {
-        error_setg(&local_err, QERR_QGA_COMMAND_FAILED,
+        error_setg(errp, QERR_QGA_COMMAND_FAILED,
                    "failed to open privilege token");
     }
 
@@ -271,25 +270,20 @@ out:
     if (token) {
         CloseHandle(token);
     }
-    error_propagate(errp, local_err);
 }
 
 static void execute_async(DWORD WINAPI (*func)(LPVOID), LPVOID opaque,
                           Error **errp)
 {
-    Error *local_err = NULL;
-
     HANDLE thread = CreateThread(NULL, 0, func, opaque, 0, NULL);
     if (!thread) {
-        error_setg(&local_err, QERR_QGA_COMMAND_FAILED,
+        error_setg(errp, QERR_QGA_COMMAND_FAILED,
                    "failed to dispatch asynchronous command");
-        error_propagate(errp, local_err);
     }
 }
 
 void qmp_guest_shutdown(bool has_mode, const char *mode, Error **errp)
 {
-    Error *local_err = NULL;
     UINT shutdown_flag = EWX_FORCE;
 
     slog("guest-shutdown called, mode: %s", mode);
@@ -308,9 +302,8 @@ void qmp_guest_shutdown(bool has_mode, const char *mode, Error **errp)
 
     /* Request a shutdown privilege, but try to shut down the system
        anyway. */
-    acquire_privilege(SE_SHUTDOWN_NAME, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    acquire_privilege(SE_SHUTDOWN_NAME, errp);
+    if (*errp) {
         return;
     }
 
@@ -416,7 +409,6 @@ GuestFileSeek *qmp_guest_file_seek(int64_t handle, int64_t offset,
     off_pos.QuadPart = offset;
     BOOL res;
     int whence;
-    Error *err = NULL;
 
     gfh = guest_file_handle_find(handle, errp);
     if (!gfh) {
@@ -424,9 +416,8 @@ GuestFileSeek *qmp_guest_file_seek(int64_t handle, int64_t offset,
     }
 
     /* We stupidly exposed 'whence':'int' in our qapi */
-    whence = ga_parse_whence(whence_code, &err);
-    if (err) {
-        error_propagate(errp, err);
+    whence = ga_parse_whence(whence_code, errp);
+    if (*errp) {
         return NULL;
     }
 
@@ -795,7 +786,6 @@ static void get_single_disk_info(int disk_number,
     SCSI_ADDRESS addr, *scsi_ad;
     DWORD len;
     HANDLE disk_h;
-    Error *local_err = NULL;
 
     scsi_ad = &addr;
 
@@ -807,9 +797,8 @@ static void get_single_disk_info(int disk_number,
         return;
     }
 
-    get_disk_properties(disk_h, disk, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    get_disk_properties(disk_h, disk, errp);
+    if (*errp) {
         goto err_close;
     }
 
@@ -819,9 +808,8 @@ static void get_single_disk_info(int disk_number,
      * if that doesn't hold since that suggests some other unexpected
      * breakage
      */
-    disk->pci_controller = get_pci_info(disk_number, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    disk->pci_controller = get_pci_info(disk_number, errp);
+    if (*errp) {
         goto err_close;
     }
     if (disk->bus_type == GUEST_DISK_BUS_TYPE_SCSI
@@ -854,7 +842,6 @@ err_close:
  * volume is returned for the spanned disk group (LVM) */
 static GuestDiskAddressList *build_guest_disk_info(char *guid, Error **errp)
 {
-    Error *local_err = NULL;
     GuestDiskAddressList *list = NULL, *cur_item = NULL;
     GuestDiskAddress *disk = NULL;
     int i;
@@ -900,11 +887,11 @@ static GuestDiskAddressList *build_guest_disk_info(char *guid, Error **errp)
             disk = g_malloc0(sizeof(GuestDiskAddress));
             disk->has_dev = true;
             disk->dev = g_strdup(name);
-            get_single_disk_info(0xffffffff, disk, &local_err);
-            if (local_err) {
+            get_single_disk_info(0xffffffff, disk, errp);
+            if (*errp) {
                 g_debug("failed to get disk info, ignoring error: %s",
-                    error_get_pretty(local_err));
-                error_free(local_err);
+                    error_get_pretty(*errp));
+                error_free_errp(errp);
                 goto out;
             }
             list = g_malloc0(sizeof(*list));
@@ -936,9 +923,8 @@ static GuestDiskAddressList *build_guest_disk_info(char *guid, Error **errp)
         disk->dev = g_strdup_printf("\\\\.\\PhysicalDrive%lu",
                                     extents->Extents[i].DiskNumber);
 
-        get_single_disk_info(extents->Extents[i].DiskNumber, disk, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        get_single_disk_info(extents->Extents[i].DiskNumber, disk, errp);
+        if (*errp) {
             goto out;
         }
         cur_item = g_malloc0(sizeof(*list));
@@ -1091,7 +1077,6 @@ int64_t qmp_guest_fsfreeze_freeze_list(bool has_mountpoints,
                                        Error **errp)
 {
     int i;
-    Error *local_err = NULL;
 
     if (!vss_initialized()) {
         error_setg(errp, QERR_UNSUPPORTED);
@@ -1103,20 +1088,19 @@ int64_t qmp_guest_fsfreeze_freeze_list(bool has_mountpoints,
     /* cannot risk guest agent blocking itself on a write in this state */
     ga_set_frozen(ga_state);
 
-    qga_vss_fsfreeze(&i, true, mountpoints, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qga_vss_fsfreeze(&i, true, mountpoints, errp);
+    if (*errp) {
         goto error;
     }
 
     return i;
 
 error:
-    local_err = NULL;
-    qmp_guest_fsfreeze_thaw(&local_err);
-    if (local_err) {
-        g_debug("cleanup thaw: %s", error_get_pretty(local_err));
-        error_free(local_err);
+    *errp = NULL;
+    qmp_guest_fsfreeze_thaw(errp);
+    if (*errp) {
+        g_debug("cleanup thaw: %s", error_get_pretty(*errp));
+        error_free_errp(errp);
     }
     return 0;
 }
@@ -1282,35 +1266,31 @@ typedef enum {
 static void check_suspend_mode(GuestSuspendMode mode, Error **errp)
 {
     SYSTEM_POWER_CAPABILITIES sys_pwr_caps;
-    Error *local_err = NULL;
 
     ZeroMemory(&sys_pwr_caps, sizeof(sys_pwr_caps));
     if (!GetPwrCapabilities(&sys_pwr_caps)) {
-        error_setg(&local_err, QERR_QGA_COMMAND_FAILED,
+        error_setg(errp, QERR_QGA_COMMAND_FAILED,
                    "failed to determine guest suspend capabilities");
-        goto out;
+        return;
     }
 
     switch (mode) {
     case GUEST_SUSPEND_MODE_DISK:
         if (!sys_pwr_caps.SystemS4) {
-            error_setg(&local_err, QERR_QGA_COMMAND_FAILED,
+            error_setg(errp, QERR_QGA_COMMAND_FAILED,
                        "suspend-to-disk not supported by OS");
         }
         break;
     case GUEST_SUSPEND_MODE_RAM:
         if (!sys_pwr_caps.SystemS3) {
-            error_setg(&local_err, QERR_QGA_COMMAND_FAILED,
+            error_setg(errp, QERR_QGA_COMMAND_FAILED,
                        "suspend-to-ram not supported by OS");
         }
         break;
     default:
-        error_setg(&local_err, QERR_INVALID_PARAMETER_VALUE, "mode",
+        error_setg(errp, QERR_INVALID_PARAMETER_VALUE, "mode",
                    "GuestSuspendMode");
     }
-
-out:
-    error_propagate(errp, local_err);
 }
 
 static DWORD WINAPI do_suspend(LPVOID opaque)
@@ -1328,32 +1308,28 @@ static DWORD WINAPI do_suspend(LPVOID opaque)
 
 void qmp_guest_suspend_disk(Error **errp)
 {
-    Error *local_err = NULL;
     GuestSuspendMode *mode = g_new(GuestSuspendMode, 1);
 
     *mode = GUEST_SUSPEND_MODE_DISK;
-    check_suspend_mode(*mode, &local_err);
-    acquire_privilege(SE_SHUTDOWN_NAME, &local_err);
-    execute_async(do_suspend, mode, &local_err);
+    check_suspend_mode(*mode, errp);
+    acquire_privilege(SE_SHUTDOWN_NAME, errp);
+    execute_async(do_suspend, mode, errp);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         g_free(mode);
     }
 }
 
 void qmp_guest_suspend_ram(Error **errp)
 {
-    Error *local_err = NULL;
     GuestSuspendMode *mode = g_new(GuestSuspendMode, 1);
 
     *mode = GUEST_SUSPEND_MODE_RAM;
-    check_suspend_mode(*mode, &local_err);
-    acquire_privilege(SE_SHUTDOWN_NAME, &local_err);
-    execute_async(do_suspend, mode, &local_err);
+    check_suspend_mode(*mode, errp);
+    acquire_privilege(SE_SHUTDOWN_NAME, errp);
+    execute_async(do_suspend, mode, errp);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         g_free(mode);
     }
 }
@@ -1616,7 +1592,6 @@ int64_t qmp_guest_get_time(Error **errp)
 
 void qmp_guest_set_time(bool has_time, int64_t time_ns, Error **errp)
 {
-    Error *local_err = NULL;
     SYSTEMTIME ts;
     FILETIME tf;
     LONGLONG time;
@@ -1681,9 +1656,8 @@ void qmp_guest_set_time(bool has_time, int64_t time_ns, Error **errp)
         return;
     }
 
-    acquire_privilege(SE_SYSTEMTIME_NAME, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    acquire_privilege(SE_SYSTEMTIME_NAME, errp);
+    if (*errp) {
         return;
     }
 
@@ -1698,7 +1672,6 @@ GuestLogicalProcessorList *qmp_guest_get_vcpus(Error **errp)
     PSYSTEM_LOGICAL_PROCESSOR_INFORMATION pslpi, ptr;
     DWORD length;
     GuestLogicalProcessorList *head, **link;
-    Error *local_err = NULL;
     int64_t current;
 
     ptr = pslpi = NULL;
@@ -1712,16 +1685,16 @@ GuestLogicalProcessorList *qmp_guest_get_vcpus(Error **errp)
         (length > sizeof(SYSTEM_LOGICAL_PROCESSOR_INFORMATION))) {
         ptr = pslpi = g_malloc0(length);
         if (GetLogicalProcessorInformation(pslpi, &length) == FALSE) {
-            error_setg(&local_err, "Failed to get processor information: %d",
+            error_setg(errp, "Failed to get processor information: %d",
                        (int)GetLastError());
         }
     } else {
-        error_setg(&local_err,
+        error_setg(errp,
                    "Failed to get processor information buffer length: %d",
                    (int)GetLastError());
     }
 
-    while ((local_err == NULL) && (length > 0)) {
+    while ((*errp == NULL) && (length > 0)) {
         if (pslpi->Relationship == RelationProcessorCore) {
             ULONG_PTR cpu_bits = pslpi->ProcessorMask;
 
@@ -1750,16 +1723,15 @@ GuestLogicalProcessorList *qmp_guest_get_vcpus(Error **errp)
 
     g_free(ptr);
 
-    if (local_err == NULL) {
+    if (*errp == NULL) {
         if (head != NULL) {
             return head;
         }
         /* there's no guest with zero VCPUs */
-        error_setg(&local_err, "Guest reported zero VCPUs");
+        error_setg(errp, "Guest reported zero VCPUs");
     }
 
     qapi_free_GuestLogicalProcessorList(head);
-    error_propagate(errp, local_err);
     return NULL;
 }
 
@@ -2186,22 +2158,19 @@ static char *ga_get_current_arch(void)
 
 GuestOSInfo *qmp_guest_get_osinfo(Error **errp)
 {
-    Error *local_err = NULL;
     OSVERSIONINFOEXW os_version = {0};
     bool server;
     char *product_name;
     GuestOSInfo *info;
 
-    ga_get_win_version(&os_version, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    ga_get_win_version(&os_version, errp);
+    if (*errp) {
         return NULL;
     }
 
     server = os_version.wProductType != VER_NT_WORKSTATION;
-    product_name = ga_get_win_product_name(&local_err);
+    product_name = ga_get_win_product_name(errp);
     if (product_name == NULL) {
-        error_propagate(errp, local_err);
         return NULL;
     }
 
diff --git a/qom/object.c b/qom/object.c
index 6fa9c619fa..67f6b6ac9d 100644
--- a/qom/object.c
+++ b/qom/object.c
@@ -382,7 +382,6 @@ void object_apply_global_props(Object *obj, const GPtrArray *props, Error **errp
 
     for (i = 0; i < props->len; i++) {
         GlobalProperty *p = g_ptr_array_index(props, i);
-        Error *err = NULL;
 
         if (object_dynamic_cast(obj, p->driver) == NULL) {
             continue;
@@ -391,9 +390,9 @@ void object_apply_global_props(Object *obj, const GPtrArray *props, Error **errp
             continue;
         }
         p->used = true;
-        object_property_parse(obj, p->value, p->property, &err);
-        if (err != NULL) {
-            error_prepend(&err, "can't apply global %s.%s=%s: ",
+        object_property_parse(obj, p->value, p->property, errp);
+        if (*errp != NULL) {
+            error_prepend(errp, "can't apply global %s.%s=%s: ",
                           p->driver, p->property, p->value);
             /*
              * If errp != NULL, propagate error and return.
@@ -401,10 +400,9 @@ void object_apply_global_props(Object *obj, const GPtrArray *props, Error **errp
              * with the remaining globals.
              */
             if (errp) {
-                error_propagate(errp, err);
                 return;
             } else {
-                warn_report_err(err);
+                warn_report_errp(errp);
             }
         }
     }
@@ -1430,7 +1428,6 @@ typedef struct EnumProperty {
 int object_property_get_enum(Object *obj, const char *name,
                              const char *typename, Error **errp)
 {
-    Error *err = NULL;
     Visitor *v;
     char *str;
     int ret;
@@ -1451,9 +1448,8 @@ int object_property_get_enum(Object *obj, const char *name,
     enumprop = prop->opaque;
 
     v = string_output_visitor_new(false, &str);
-    object_property_get(obj, v, name, &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_get(obj, v, name, errp);
+    if (*errp) {
         visit_free(v);
         return 0;
     }
@@ -1471,14 +1467,12 @@ int object_property_get_enum(Object *obj, const char *name,
 void object_property_get_uint16List(Object *obj, const char *name,
                                     uint16List **list, Error **errp)
 {
-    Error *err = NULL;
     Visitor *v;
     char *str;
 
     v = string_output_visitor_new(false, &str);
-    object_property_get(obj, v, name, &err);
-    if (err) {
-        error_propagate(errp, err);
+    object_property_get(obj, v, name, errp);
+    if (*errp) {
         goto out;
     }
     visit_complete(v, &str);
@@ -1504,12 +1498,10 @@ char *object_property_print(Object *obj, const char *name, bool human,
 {
     Visitor *v;
     char *string = NULL;
-    Error *local_err = NULL;
 
     v = string_output_visitor_new(human, &string);
-    object_property_get(obj, v, name, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    object_property_get(obj, v, name, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -1589,7 +1581,6 @@ static void object_finalize_child_property(Object *obj, const char *name,
 void object_property_add_child(Object *obj, const char *name,
                                Object *child, Error **errp)
 {
-    Error *local_err = NULL;
     gchar *type;
     ObjectProperty *op;
 
@@ -1601,9 +1592,8 @@ void object_property_add_child(Object *obj, const char *name,
     type = g_strdup_printf("child<%s>", object_get_typename(OBJECT(child)));
 
     op = object_property_add(obj, name, type, object_get_child_property, NULL,
-                             object_finalize_child_property, child, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                             object_finalize_child_property, child, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -1618,6 +1608,7 @@ out:
 void object_property_allow_set_link(const Object *obj, const char *name,
                                     Object *val, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
     /* Allow the link to be set, always */
 }
 
@@ -1689,28 +1680,25 @@ static void object_set_link_property(Object *obj, Visitor *v,
                                      const char *name, void *opaque,
                                      Error **errp)
 {
-    Error *local_err = NULL;
     LinkProperty *prop = opaque;
     Object **child = prop->child;
     Object *old_target = *child;
     Object *new_target = NULL;
     char *path = NULL;
 
-    visit_type_str(v, name, &path, &local_err);
+    visit_type_str(v, name, &path, errp);
 
-    if (!local_err && strcmp(path, "") != 0) {
-        new_target = object_resolve_link(obj, name, path, &local_err);
+    if (!*errp && strcmp(path, "") != 0) {
+        new_target = object_resolve_link(obj, name, path, errp);
     }
 
     g_free(path);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return;
     }
 
-    prop->check(obj, name, new_target, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    prop->check(obj, name, new_target, errp);
+    if (*errp) {
         return;
     }
 
@@ -1746,7 +1734,6 @@ void object_property_add_link(Object *obj, const char *name,
                               ObjectPropertyLinkFlags flags,
                               Error **errp)
 {
-    Error *local_err = NULL;
     LinkProperty *prop = g_malloc(sizeof(*prop));
     gchar *full_type;
     ObjectProperty *op;
@@ -1762,9 +1749,8 @@ void object_property_add_link(Object *obj, const char *name,
                              check ? object_set_link_property : NULL,
                              object_release_link_property,
                              prop,
-                             &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                             errp);
+    if (*errp) {
         g_free(prop);
         goto out;
     }
@@ -1961,11 +1947,9 @@ static void property_get_str(Object *obj, Visitor *v, const char *name,
 {
     StringProperty *prop = opaque;
     char *value;
-    Error *err = NULL;
 
-    value = prop->get(obj, &err);
-    if (err) {
-        error_propagate(errp, err);
+    value = prop->get(obj, errp);
+    if (*errp) {
         return;
     }
 
@@ -1978,11 +1962,9 @@ static void property_set_str(Object *obj, Visitor *v, const char *name,
 {
     StringProperty *prop = opaque;
     char *value;
-    Error *local_err = NULL;
 
-    visit_type_str(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
@@ -2002,7 +1984,6 @@ void object_property_add_str(Object *obj, const char *name,
                            void (*set)(Object *, const char *, Error **),
                            Error **errp)
 {
-    Error *local_err = NULL;
     StringProperty *prop = g_malloc0(sizeof(*prop));
 
     prop->get = get;
@@ -2012,9 +1993,8 @@ void object_property_add_str(Object *obj, const char *name,
                         get ? property_get_str : NULL,
                         set ? property_set_str : NULL,
                         property_release_str,
-                        prop, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                        prop, errp);
+    if (*errp) {
         g_free(prop);
     }
 }
@@ -2025,7 +2005,6 @@ void object_class_property_add_str(ObjectClass *klass, const char *name,
                                                Error **),
                                    Error **errp)
 {
-    Error *local_err = NULL;
     StringProperty *prop = g_malloc0(sizeof(*prop));
 
     prop->get = get;
@@ -2035,9 +2014,8 @@ void object_class_property_add_str(ObjectClass *klass, const char *name,
                               get ? property_get_str : NULL,
                               set ? property_set_str : NULL,
                               property_release_str,
-                              prop, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                              prop, errp);
+    if (*errp) {
         g_free(prop);
     }
 }
@@ -2053,11 +2031,9 @@ static void property_get_bool(Object *obj, Visitor *v, const char *name,
 {
     BoolProperty *prop = opaque;
     bool value;
-    Error *err = NULL;
 
-    value = prop->get(obj, &err);
-    if (err) {
-        error_propagate(errp, err);
+    value = prop->get(obj, errp);
+    if (*errp) {
         return;
     }
 
@@ -2069,11 +2045,9 @@ static void property_set_bool(Object *obj, Visitor *v, const char *name,
 {
     BoolProperty *prop = opaque;
     bool value;
-    Error *local_err = NULL;
 
-    visit_type_bool(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_bool(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
@@ -2092,7 +2066,6 @@ void object_property_add_bool(Object *obj, const char *name,
                               void (*set)(Object *, bool, Error **),
                               Error **errp)
 {
-    Error *local_err = NULL;
     BoolProperty *prop = g_malloc0(sizeof(*prop));
 
     prop->get = get;
@@ -2102,9 +2075,8 @@ void object_property_add_bool(Object *obj, const char *name,
                         get ? property_get_bool : NULL,
                         set ? property_set_bool : NULL,
                         property_release_bool,
-                        prop, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                        prop, errp);
+    if (*errp) {
         g_free(prop);
     }
 }
@@ -2114,7 +2086,6 @@ void object_class_property_add_bool(ObjectClass *klass, const char *name,
                                     void (*set)(Object *, bool, Error **),
                                     Error **errp)
 {
-    Error *local_err = NULL;
     BoolProperty *prop = g_malloc0(sizeof(*prop));
 
     prop->get = get;
@@ -2124,9 +2095,8 @@ void object_class_property_add_bool(ObjectClass *klass, const char *name,
                               get ? property_get_bool : NULL,
                               set ? property_set_bool : NULL,
                               property_release_bool,
-                              prop, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                              prop, errp);
+    if (*errp) {
         g_free(prop);
     }
 }
@@ -2136,11 +2106,9 @@ static void property_get_enum(Object *obj, Visitor *v, const char *name,
 {
     EnumProperty *prop = opaque;
     int value;
-    Error *err = NULL;
 
-    value = prop->get(obj, &err);
-    if (err) {
-        error_propagate(errp, err);
+    value = prop->get(obj, errp);
+    if (*errp) {
         return;
     }
 
@@ -2152,11 +2120,9 @@ static void property_set_enum(Object *obj, Visitor *v, const char *name,
 {
     EnumProperty *prop = opaque;
     int value;
-    Error *err = NULL;
 
-    visit_type_enum(v, name, &value, prop->lookup, &err);
-    if (err) {
-        error_propagate(errp, err);
+    visit_type_enum(v, name, &value, prop->lookup, errp);
+    if (*errp) {
         return;
     }
     prop->set(obj, value, errp);
@@ -2176,7 +2142,6 @@ void object_property_add_enum(Object *obj, const char *name,
                               void (*set)(Object *, int, Error **),
                               Error **errp)
 {
-    Error *local_err = NULL;
     EnumProperty *prop = g_malloc(sizeof(*prop));
 
     prop->lookup = lookup;
@@ -2187,9 +2152,8 @@ void object_property_add_enum(Object *obj, const char *name,
                         get ? property_get_enum : NULL,
                         set ? property_set_enum : NULL,
                         property_release_enum,
-                        prop, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                        prop, errp);
+    if (*errp) {
         g_free(prop);
     }
 }
@@ -2201,7 +2165,6 @@ void object_class_property_add_enum(ObjectClass *klass, const char *name,
                                     void (*set)(Object *, int, Error **),
                                     Error **errp)
 {
-    Error *local_err = NULL;
     EnumProperty *prop = g_malloc(sizeof(*prop));
 
     prop->lookup = lookup;
@@ -2212,9 +2175,8 @@ void object_class_property_add_enum(ObjectClass *klass, const char *name,
                               get ? property_get_enum : NULL,
                               set ? property_set_enum : NULL,
                               property_release_enum,
-                              prop, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                              prop, errp);
+    if (*errp) {
         g_free(prop);
     }
 }
@@ -2227,47 +2189,44 @@ static void property_get_tm(Object *obj, Visitor *v, const char *name,
                             void *opaque, Error **errp)
 {
     TMProperty *prop = opaque;
-    Error *err = NULL;
     struct tm value;
 
-    prop->get(obj, &value, &err);
-    if (err) {
-        goto out;
+    prop->get(obj, &value, errp);
+    if (*errp) {
+        return;
     }
 
-    visit_start_struct(v, name, NULL, 0, &err);
-    if (err) {
-        goto out;
+    visit_start_struct(v, name, NULL, 0, errp);
+    if (*errp) {
+        return;
     }
-    visit_type_int32(v, "tm_year", &value.tm_year, &err);
-    if (err) {
+    visit_type_int32(v, "tm_year", &value.tm_year, errp);
+    if (*errp) {
         goto out_end;
     }
-    visit_type_int32(v, "tm_mon", &value.tm_mon, &err);
-    if (err) {
+    visit_type_int32(v, "tm_mon", &value.tm_mon, errp);
+    if (*errp) {
         goto out_end;
     }
-    visit_type_int32(v, "tm_mday", &value.tm_mday, &err);
-    if (err) {
+    visit_type_int32(v, "tm_mday", &value.tm_mday, errp);
+    if (*errp) {
         goto out_end;
     }
-    visit_type_int32(v, "tm_hour", &value.tm_hour, &err);
-    if (err) {
+    visit_type_int32(v, "tm_hour", &value.tm_hour, errp);
+    if (*errp) {
         goto out_end;
     }
-    visit_type_int32(v, "tm_min", &value.tm_min, &err);
-    if (err) {
+    visit_type_int32(v, "tm_min", &value.tm_min, errp);
+    if (*errp) {
         goto out_end;
     }
-    visit_type_int32(v, "tm_sec", &value.tm_sec, &err);
-    if (err) {
+    visit_type_int32(v, "tm_sec", &value.tm_sec, errp);
+    if (*errp) {
         goto out_end;
     }
-    visit_check_struct(v, &err);
+    visit_check_struct(v, errp);
 out_end:
     visit_end_struct(v, NULL);
-out:
-    error_propagate(errp, err);
 
 }
 
@@ -2282,7 +2241,6 @@ void object_property_add_tm(Object *obj, const char *name,
                             void (*get)(Object *, struct tm *, Error **),
                             Error **errp)
 {
-    Error *local_err = NULL;
     TMProperty *prop = g_malloc0(sizeof(*prop));
 
     prop->get = get;
@@ -2290,9 +2248,8 @@ void object_property_add_tm(Object *obj, const char *name,
     object_property_add(obj, name, "struct tm",
                         get ? property_get_tm : NULL, NULL,
                         property_release_tm,
-                        prop, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                        prop, errp);
+    if (*errp) {
         g_free(prop);
     }
 }
@@ -2301,7 +2258,6 @@ void object_class_property_add_tm(ObjectClass *klass, const char *name,
                                   void (*get)(Object *, struct tm *, Error **),
                                   Error **errp)
 {
-    Error *local_err = NULL;
     TMProperty *prop = g_malloc0(sizeof(*prop));
 
     prop->get = get;
@@ -2309,9 +2265,8 @@ void object_class_property_add_tm(ObjectClass *klass, const char *name,
     object_class_property_add(klass, name, "struct tm",
                               get ? property_get_tm : NULL, NULL,
                               property_release_tm,
-                              prop, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                              prop, errp);
+    if (*errp) {
         g_free(prop);
     }
 }
@@ -2450,7 +2405,6 @@ void object_property_add_alias(Object *obj, const char *name,
     ObjectProperty *op;
     ObjectProperty *target_prop;
     gchar *prop_type;
-    Error *local_err = NULL;
 
     target_prop = object_property_find(target_obj, target_name, errp);
     if (!target_prop) {
@@ -2472,9 +2426,8 @@ void object_property_add_alias(Object *obj, const char *name,
                              property_get_alias,
                              property_set_alias,
                              property_release_alias,
-                             prop, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                             prop, errp);
+    if (*errp) {
         g_free(prop);
         goto out;
     }
diff --git a/qom/object_interfaces.c b/qom/object_interfaces.c
index cb5809934a..58bb78e4e9 100644
--- a/qom/object_interfaces.c
+++ b/qom/object_interfaces.c
@@ -36,7 +36,6 @@ Object *user_creatable_add_type(const char *type, const char *id,
     Object *obj;
     ObjectClass *klass;
     const QDictEntry *e;
-    Error *local_err = NULL;
 
     klass = object_class_by_name(type);
     if (!klass) {
@@ -57,34 +56,34 @@ Object *user_creatable_add_type(const char *type, const char *id,
 
     assert(qdict);
     obj = object_new(type);
-    visit_start_struct(v, NULL, NULL, 0, &local_err);
-    if (local_err) {
+    visit_start_struct(v, NULL, NULL, 0, errp);
+    if (*errp) {
         goto out;
     }
     for (e = qdict_first(qdict); e; e = qdict_next(qdict, e)) {
-        object_property_set(obj, v, e->key, &local_err);
-        if (local_err) {
+        object_property_set(obj, v, e->key, errp);
+        if (*errp) {
             break;
         }
     }
-    if (!local_err) {
-        visit_check_struct(v, &local_err);
+    if (!*errp) {
+        visit_check_struct(v, errp);
     }
     visit_end_struct(v, NULL);
-    if (local_err) {
+    if (*errp) {
         goto out;
     }
 
     if (id != NULL) {
         object_property_add_child(object_get_objects_root(),
-                                  id, obj, &local_err);
-        if (local_err) {
+                                  id, obj, errp);
+        if (*errp) {
             goto out;
         }
     }
 
-    user_creatable_complete(USER_CREATABLE(obj), &local_err);
-    if (local_err) {
+    user_creatable_complete(USER_CREATABLE(obj), errp);
+    if (*errp) {
         if (id != NULL) {
             object_property_del(object_get_objects_root(),
                                 id, &error_abort);
@@ -92,8 +91,7 @@ Object *user_creatable_add_type(const char *type, const char *id,
         goto out;
     }
 out:
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         object_unref(obj);
         return NULL;
     }
diff --git a/qom/qom-qobject.c b/qom/qom-qobject.c
index c3b95aa354..6a76a3fc5a 100644
--- a/qom/qom-qobject.c
+++ b/qom/qom-qobject.c
@@ -31,15 +31,13 @@ QObject *object_property_get_qobject(Object *obj, const char *name,
                                      Error **errp)
 {
     QObject *ret = NULL;
-    Error *local_err = NULL;
     Visitor *v;
 
     v = qobject_output_visitor_new(&ret);
-    object_property_get(obj, v, name, &local_err);
-    if (!local_err) {
+    object_property_get(obj, v, name, errp);
+    if (!*errp) {
         visit_complete(v, &ret);
     }
-    error_propagate(errp, local_err);
     visit_free(v);
     return ret;
 }
diff --git a/replication.c b/replication.c
index be3a42f9c9..d98966934e 100644
--- a/replication.c
+++ b/replication.c
@@ -45,14 +45,12 @@ void replication_remove(ReplicationState *rs)
 void replication_start_all(ReplicationMode mode, Error **errp)
 {
     ReplicationState *rs, *next;
-    Error *local_err = NULL;
 
     QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {
         if (rs->ops && rs->ops->start) {
-            rs->ops->start(rs, mode, &local_err);
+            rs->ops->start(rs, mode, errp);
         }
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             return;
         }
     }
@@ -61,14 +59,12 @@ void replication_start_all(ReplicationMode mode, Error **errp)
 void replication_do_checkpoint_all(Error **errp)
 {
     ReplicationState *rs, *next;
-    Error *local_err = NULL;
 
     QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {
         if (rs->ops && rs->ops->checkpoint) {
-            rs->ops->checkpoint(rs, &local_err);
+            rs->ops->checkpoint(rs, errp);
         }
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             return;
         }
     }
@@ -77,14 +73,12 @@ void replication_do_checkpoint_all(Error **errp)
 void replication_get_error_all(Error **errp)
 {
     ReplicationState *rs, *next;
-    Error *local_err = NULL;
 
     QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {
         if (rs->ops && rs->ops->get_error) {
-            rs->ops->get_error(rs, &local_err);
+            rs->ops->get_error(rs, errp);
         }
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             return;
         }
     }
@@ -93,14 +87,12 @@ void replication_get_error_all(Error **errp)
 void replication_stop_all(bool failover, Error **errp)
 {
     ReplicationState *rs, *next;
-    Error *local_err = NULL;
 
     QLIST_FOREACH_SAFE(rs, &replication_states, node, next) {
         if (rs->ops && rs->ops->stop) {
-            rs->ops->stop(rs, failover, &local_err);
+            rs->ops->stop(rs, failover, errp);
         }
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             return;
         }
     }
diff --git a/scsi/pr-manager-helper.c b/scsi/pr-manager-helper.c
index ca27c93283..c39fc429f7 100644
--- a/scsi/pr-manager-helper.c
+++ b/scsi/pr-manager-helper.c
@@ -107,7 +107,6 @@ static int pr_manager_helper_initialize(PRManagerHelper *pr_mgr,
         .u.q_unix.path = path
     };
     QIOChannelSocket *sioc = qio_channel_socket_new();
-    Error *local_err = NULL;
 
     uint32_t flags;
     int r;
@@ -116,11 +115,10 @@ static int pr_manager_helper_initialize(PRManagerHelper *pr_mgr,
     qio_channel_set_name(QIO_CHANNEL(sioc), "pr-manager-helper");
     qio_channel_socket_connect_sync(sioc,
                                     &saddr,
-                                    &local_err);
+                                    errp);
     g_free(path);
-    if (local_err) {
+    if (*errp) {
         object_unref(OBJECT(sioc));
-        error_propagate(errp, local_err);
         return -ENOTCONN;
     }
 
diff --git a/stubs/xen-hvm.c b/stubs/xen-hvm.c
index b7d53b5e2f..840a2a0d09 100644
--- a/stubs/xen-hvm.c
+++ b/stubs/xen-hvm.c
@@ -38,6 +38,7 @@ int xen_is_pirq_msi(uint32_t msi_data)
 void xen_ram_alloc(ram_addr_t ram_addr, ram_addr_t size, MemoryRegion *mr,
                    Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 qemu_irq *xen_interrupt_controller_init(void)
@@ -59,4 +60,5 @@ void xen_hvm_init(PCMachineState *pcms, MemoryRegion **ram_memory)
 
 void qmp_xen_set_global_dirty_log(bool enable, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
diff --git a/target/alpha/cpu.c b/target/alpha/cpu.c
index b3fd6643e8..0e305cb1f6 100644
--- a/target/alpha/cpu.c
+++ b/target/alpha/cpu.c
@@ -58,11 +58,9 @@ static void alpha_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     AlphaCPUClass *acc = ALPHA_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/arm/cpu.c b/target/arm/cpu.c
index 2399c14471..110c28bdbe 100644
--- a/target/arm/cpu.c
+++ b/target/arm/cpu.c
@@ -1205,7 +1205,6 @@ static void arm_cpu_realizefn(DeviceState *dev, Error **errp)
     ARMCPUClass *acc = ARM_CPU_GET_CLASS(dev);
     CPUARMState *env = &cpu->env;
     int pagebits;
-    Error *local_err = NULL;
     bool no_aa32 = false;
 
     /* If we needed to query the host kernel for the CPU features
@@ -1248,9 +1247,8 @@ static void arm_cpu_realizefn(DeviceState *dev, Error **errp)
                                           arm_gt_stimer_cb, cpu);
 #endif
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/arm/cpu64.c b/target/arm/cpu64.c
index d7f5bf610a..5520c71863 100644
--- a/target/arm/cpu64.c
+++ b/target/arm/cpu64.c
@@ -267,16 +267,14 @@ static void cpu_max_set_sve_vq(Object *obj, Visitor *v, const char *name,
                                void *opaque, Error **errp)
 {
     ARMCPU *cpu = ARM_CPU(obj);
-    Error *err = NULL;
 
-    visit_type_uint32(v, name, &cpu->sve_max_vq, &err);
+    visit_type_uint32(v, name, &cpu->sve_max_vq, errp);
 
-    if (!err && (cpu->sve_max_vq == 0 || cpu->sve_max_vq > ARM_MAX_VQ)) {
-        error_setg(&err, "unsupported SVE vector length");
-        error_append_hint(&err, "Valid sve-max-vq in range [1-%d]\n",
+    if (!*errp && (cpu->sve_max_vq == 0 || cpu->sve_max_vq > ARM_MAX_VQ)) {
+        error_setg(errp, "unsupported SVE vector length");
+        error_append_hint(errp, "Valid sve-max-vq in range [1-%d]\n",
                           ARM_MAX_VQ);
     }
-    error_propagate(errp, err);
 }
 
 /* -cpu max: if KVM is enabled, like -cpu host (best possible with this host);
diff --git a/target/cris/cpu.c b/target/cris/cpu.c
index 7adfd6caf4..6f54341093 100644
--- a/target/cris/cpu.c
+++ b/target/cris/cpu.c
@@ -126,11 +126,9 @@ static void cris_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     CRISCPUClass *ccc = CRIS_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/hppa/cpu.c b/target/hppa/cpu.c
index 71b6aca45d..b98b26b521 100644
--- a/target/hppa/cpu.c
+++ b/target/hppa/cpu.c
@@ -91,11 +91,9 @@ static void hppa_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     HPPACPUClass *acc = HPPA_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/i386/cpu.c b/target/i386/cpu.c
index 9e0bac31e8..ac49cffd54 100644
--- a/target/i386/cpu.c
+++ b/target/i386/cpu.c
@@ -3138,12 +3138,10 @@ static void x86_cpuid_version_set_family(Object *obj, Visitor *v,
     CPUX86State *env = &cpu->env;
     const int64_t min = 0;
     const int64_t max = 0xff + 0xf;
-    Error *local_err = NULL;
     int64_t value;
 
-    visit_type_int(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_int(v, name, &value, errp);
+    if (*errp) {
         return;
     }
     if (value < min || value > max) {
@@ -3181,12 +3179,10 @@ static void x86_cpuid_version_set_model(Object *obj, Visitor *v,
     CPUX86State *env = &cpu->env;
     const int64_t min = 0;
     const int64_t max = 0xff;
-    Error *local_err = NULL;
     int64_t value;
 
-    visit_type_int(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_int(v, name, &value, errp);
+    if (*errp) {
         return;
     }
     if (value < min || value > max) {
@@ -3219,12 +3215,10 @@ static void x86_cpuid_version_set_stepping(Object *obj, Visitor *v,
     CPUX86State *env = &cpu->env;
     const int64_t min = 0;
     const int64_t max = 0xf;
-    Error *local_err = NULL;
     int64_t value;
 
-    visit_type_int(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_int(v, name, &value, errp);
+    if (*errp) {
         return;
     }
     if (value < min || value > max) {
@@ -3324,12 +3318,10 @@ static void x86_cpuid_set_tsc_freq(Object *obj, Visitor *v, const char *name,
     X86CPU *cpu = X86_CPU(obj);
     const int64_t min = 0;
     const int64_t max = INT64_MAX;
-    Error *local_err = NULL;
     int64_t value;
 
-    visit_type_int(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_int(v, name, &value, errp);
+    if (*errp) {
         return;
     }
     if (value < min || value > max) {
@@ -3997,17 +3989,14 @@ static void x86_cpu_to_dict_full(X86CPU *cpu, QDict *props)
 static void object_apply_props(Object *obj, QDict *props, Error **errp)
 {
     const QDictEntry *prop;
-    Error *err = NULL;
 
     for (prop = qdict_first(props); prop; prop = qdict_next(props, prop)) {
         object_property_set_qobject(obj, qdict_entry_value(prop),
-                                         qdict_entry_key(prop), &err);
-        if (err) {
+                                         qdict_entry_key(prop), errp);
+        if (*errp) {
             break;
         }
     }
-
-    error_propagate(errp, err);
 }
 
 /* Create X86CPU object according to model+props specification */
@@ -4015,30 +4004,28 @@ static X86CPU *x86_cpu_from_model(const char *model, QDict *props, Error **errp)
 {
     X86CPU *xc = NULL;
     X86CPUClass *xcc;
-    Error *err = NULL;
 
     xcc = X86_CPU_CLASS(cpu_class_by_name(TYPE_X86_CPU, model));
     if (xcc == NULL) {
-        error_setg(&err, "CPU model '%s' not found", model);
+        error_setg(errp, "CPU model '%s' not found", model);
         goto out;
     }
 
     xc = X86_CPU(object_new(object_class_get_name(OBJECT_CLASS(xcc))));
     if (props) {
-        object_apply_props(OBJECT(xc), props, &err);
-        if (err) {
+        object_apply_props(OBJECT(xc), props, errp);
+        if (*errp) {
             goto out;
         }
     }
 
-    x86_cpu_expand_features(xc, &err);
-    if (err) {
+    x86_cpu_expand_features(xc, errp);
+    if (*errp) {
         goto out;
     }
 
 out:
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         object_unref(OBJECT(xc));
         xc = NULL;
     }
@@ -4051,7 +4038,6 @@ qmp_query_cpu_model_expansion(CpuModelExpansionType type,
                                                       Error **errp)
 {
     X86CPU *xc = NULL;
-    Error *err = NULL;
     CpuModelExpansionInfo *ret = g_new0(CpuModelExpansionInfo, 1);
     QDict *props = NULL;
     const char *base_name;
@@ -4059,8 +4045,8 @@ qmp_query_cpu_model_expansion(CpuModelExpansionType type,
     xc = x86_cpu_from_model(model->name,
                             model->has_props ?
                                 qobject_to(QDict, model->props) :
-                                NULL, &err);
-    if (err) {
+                                NULL, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -4084,7 +4070,7 @@ qmp_query_cpu_model_expansion(CpuModelExpansionType type,
         x86_cpu_to_dict_full(xc, props);
     break;
     default:
-        error_setg(&err, "Unsupported expansion type");
+        error_setg(errp, "Unsupported expansion type");
         goto out;
     }
 
@@ -4094,8 +4080,7 @@ qmp_query_cpu_model_expansion(CpuModelExpansionType type,
 
 out:
     object_unref(OBJECT(xc));
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         qapi_free_CpuModelExpansionInfo(ret);
         ret = NULL;
     }
@@ -4914,6 +4899,7 @@ static void x86_cpu_machine_done(Notifier *n, void *unused)
 #else
 static void x86_cpu_apic_realize(X86CPU *cpu, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 #endif
 
@@ -5049,7 +5035,6 @@ static void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
     CPUX86State *env = &cpu->env;
     FeatureWord w;
     GList *l;
-    Error *local_err = NULL;
 
     /*TODO: Now cpu->max_features doesn't overwrite features
      * set using QOM properties, and we can convert
@@ -5070,16 +5055,16 @@ static void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
 
     for (l = plus_features; l; l = l->next) {
         const char *prop = l->data;
-        object_property_set_bool(OBJECT(cpu), true, prop, &local_err);
-        if (local_err) {
+        object_property_set_bool(OBJECT(cpu), true, prop, errp);
+        if (*errp) {
             goto out;
         }
     }
 
     for (l = minus_features; l; l = l->next) {
         const char *prop = l->data;
-        object_property_set_bool(OBJECT(cpu), false, prop, &local_err);
-        if (local_err) {
+        object_property_set_bool(OBJECT(cpu), false, prop, errp);
+        if (*errp) {
             goto out;
         }
     }
@@ -5143,8 +5128,7 @@ static void x86_cpu_expand_features(X86CPU *cpu, Error **errp)
     }
 
 out:
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    if (*errp != NULL) {
     }
 }
 
@@ -5212,13 +5196,12 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
     X86CPU *cpu = X86_CPU(dev);
     X86CPUClass *xcc = X86_CPU_GET_CLASS(dev);
     CPUX86State *env = &cpu->env;
-    Error *local_err = NULL;
     static bool ht_warned;
 
     if (xcc->host_cpuid_required) {
         if (!accel_uses_host_cpuid()) {
             char *name = x86_cpu_class_get_model_name(xcc);
-            error_setg(&local_err, "CPU model '%s' requires KVM", name);
+            error_setg(errp, "CPU model '%s' requires KVM", name);
             g_free(name);
             goto out;
         }
@@ -5239,8 +5222,8 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
         return;
     }
 
-    x86_cpu_expand_features(cpu, &local_err);
-    if (local_err) {
+    x86_cpu_expand_features(cpu, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -5248,7 +5231,7 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
         (cpu->check_cpuid || cpu->enforce_cpuid)) {
         x86_cpu_report_filtered_features(cpu);
         if (cpu->enforce_cpuid) {
-            error_setg(&local_err,
+            error_setg(errp,
                        accel_uses_host_cpuid() ?
                            "Host doesn't support requested features" :
                            "TCG doesn't support requested features");
@@ -5364,9 +5347,8 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
     }
 
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
@@ -5375,8 +5357,8 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
     qemu_register_reset(x86_cpu_machine_reset_cb, cpu);
 
     if (cpu->env.features[FEAT_1_EDX] & CPUID_APIC || ms->smp.cpus > 1) {
-        x86_cpu_apic_create(cpu, &local_err);
-        if (local_err != NULL) {
+        x86_cpu_apic_create(cpu, errp);
+        if (*errp != NULL) {
             goto out;
         }
     }
@@ -5433,17 +5415,16 @@ static void x86_cpu_realizefn(DeviceState *dev, Error **errp)
             ht_warned = true;
     }
 
-    x86_cpu_apic_realize(cpu, &local_err);
-    if (local_err != NULL) {
+    x86_cpu_apic_realize(cpu, errp);
+    if (*errp != NULL) {
         goto out;
     }
     cpu_reset(cs);
 
-    xcc->parent_realize(dev, &local_err);
+    xcc->parent_realize(dev, errp);
 
 out:
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    if (*errp != NULL) {
         return;
     }
 }
@@ -5452,7 +5433,6 @@ static void x86_cpu_unrealizefn(DeviceState *dev, Error **errp)
 {
     X86CPU *cpu = X86_CPU(dev);
     X86CPUClass *xcc = X86_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
 #ifndef CONFIG_USER_ONLY
     cpu_remove_sync(CPU(dev));
@@ -5464,9 +5444,8 @@ static void x86_cpu_unrealizefn(DeviceState *dev, Error **errp)
         cpu->apic_state = NULL;
     }
 
-    xcc->parent_unrealize(dev, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    xcc->parent_unrealize(dev, errp);
+    if (*errp != NULL) {
         return;
     }
 }
@@ -5492,7 +5471,6 @@ static void x86_cpu_set_bit_prop(Object *obj, Visitor *v, const char *name,
     DeviceState *dev = DEVICE(obj);
     X86CPU *cpu = X86_CPU(obj);
     BitProperty *fp = opaque;
-    Error *local_err = NULL;
     bool value;
 
     if (dev->realized) {
@@ -5500,9 +5478,8 @@ static void x86_cpu_set_bit_prop(Object *obj, Visitor *v, const char *name,
         return;
     }
 
-    visit_type_bool(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_bool(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/target/lm32/cpu.c b/target/lm32/cpu.c
index b35537de62..550e851fef 100644
--- a/target/lm32/cpu.c
+++ b/target/lm32/cpu.c
@@ -124,11 +124,9 @@ static void lm32_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     LM32CPUClass *lcc = LM32_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/m68k/cpu.c b/target/m68k/cpu.c
index e6596de29c..2c7af9df5f 100644
--- a/target/m68k/cpu.c
+++ b/target/m68k/cpu.c
@@ -219,13 +219,11 @@ static void m68k_cpu_realizefn(DeviceState *dev, Error **errp)
     CPUState *cs = CPU(dev);
     M68kCPU *cpu = M68K_CPU(dev);
     M68kCPUClass *mcc = M68K_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
     register_m68k_insns(&cpu->env);
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/microblaze/cpu.c b/target/microblaze/cpu.c
index 9cfd7445e7..b893b18675 100644
--- a/target/microblaze/cpu.c
+++ b/target/microblaze/cpu.c
@@ -147,11 +147,9 @@ static void mb_cpu_realizefn(DeviceState *dev, Error **errp)
     uint8_t version_code = 0;
     const char *version;
     int i = 0;
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/mips/cpu.c b/target/mips/cpu.c
index bbcf7ca463..4bc17ef036 100644
--- a/target/mips/cpu.c
+++ b/target/mips/cpu.c
@@ -139,11 +139,9 @@ static void mips_cpu_realizefn(DeviceState *dev, Error **errp)
     CPUState *cs = CPU(dev);
     MIPSCPU *cpu = MIPS_CPU(dev);
     MIPSCPUClass *mcc = MIPS_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/moxie/cpu.c b/target/moxie/cpu.c
index 48996d0554..49f7764619 100644
--- a/target/moxie/cpu.c
+++ b/target/moxie/cpu.c
@@ -57,11 +57,9 @@ static void moxie_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     MoxieCPUClass *mcc = MOXIE_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/nios2/cpu.c b/target/nios2/cpu.c
index ca9c7a6df5..8c617fd657 100644
--- a/target/nios2/cpu.c
+++ b/target/nios2/cpu.c
@@ -84,11 +84,9 @@ static void nios2_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     Nios2CPUClass *ncc = NIOS2_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/openrisc/cpu.c b/target/openrisc/cpu.c
index 506aec6bfb..cd8efc6d2d 100644
--- a/target/openrisc/cpu.c
+++ b/target/openrisc/cpu.c
@@ -69,11 +69,9 @@ static void openrisc_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     OpenRISCCPUClass *occ = OPENRISC_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/ppc/compat.c b/target/ppc/compat.c
index 7de4bf3122..a82d8d1056 100644
--- a/target/ppc/compat.c
+++ b/target/ppc/compat.c
@@ -251,13 +251,11 @@ static void ppc_compat_prop_get(Object *obj, Visitor *v, const char *name,
 static void ppc_compat_prop_set(Object *obj, Visitor *v, const char *name,
                                 void *opaque, Error **errp)
 {
-    Error *local_err = NULL;
     char *value;
     uint32_t compat_pvr;
 
-    visit_type_str(v, name, &value, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    visit_type_str(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
@@ -292,16 +290,15 @@ void ppc_compat_add_property(Object *obj, const char *name,
                              uint32_t *compat_pvr, const char *basedesc,
                              Error **errp)
 {
-    Error *local_err = NULL;
     gchar *namesv[ARRAY_SIZE(compat_table) + 1];
     gchar *names, *desc;
     int i;
 
     object_property_add(obj, name, "string",
                         ppc_compat_prop_get, ppc_compat_prop_set, NULL,
-                        compat_pvr, &local_err);
-    if (local_err) {
-        goto out;
+                        compat_pvr, errp);
+    if (*errp) {
+        return;
     }
 
     for (i = 0; i < ARRAY_SIZE(compat_table); i++) {
@@ -315,11 +312,8 @@ void ppc_compat_add_property(Object *obj, const char *name,
 
     names = g_strjoinv(", ", namesv);
     desc = g_strdup_printf("%s. Valid values are %s.", basedesc, names);
-    object_property_set_description(obj, name, desc, &local_err);
+    object_property_set_description(obj, name, desc, errp);
 
     g_free(names);
     g_free(desc);
-
-out:
-    error_propagate(errp, local_err);
 }
diff --git a/target/ppc/kvm.c b/target/ppc/kvm.c
index 8c5b1f25cc..bad73ff036 100644
--- a/target/ppc/kvm.c
+++ b/target/ppc/kvm.c
@@ -327,16 +327,14 @@ void kvm_check_mmu(PowerPCCPU *cpu, Error **errp)
 {
     struct kvm_ppc_smmu_info smmu_info;
     int iq, ik, jq, jk;
-    Error *local_err = NULL;
 
     /* For now, we only have anything to check on hash64 MMUs */
     if (!cpu->hash64_opts || !kvm_enabled()) {
         return;
     }
 
-    kvm_get_smmu_info(&smmu_info, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    kvm_get_smmu_info(&smmu_info, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/target/ppc/translate_init.inc.c b/target/ppc/translate_init.inc.c
index 0fb11c7ac6..8ec93169b3 100644
--- a/target/ppc/translate_init.inc.c
+++ b/target/ppc/translate_init.inc.c
@@ -9811,11 +9811,9 @@ static void ppc_cpu_realize(DeviceState *dev, Error **errp)
     CPUState *cs = CPU(dev);
     PowerPCCPU *cpu = POWERPC_CPU(dev);
     PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
     if (cpu->vcpu_id == UNASSIGNED_CPU_INDEX) {
@@ -9829,9 +9827,8 @@ static void ppc_cpu_realize(DeviceState *dev, Error **errp)
         }
     }
 
-    create_ppc_opcodes(cpu, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    create_ppc_opcodes(cpu, errp);
+    if (*errp != NULL) {
         goto unrealize;
     }
     init_ppc_proc(cpu);
@@ -10036,13 +10033,11 @@ static void ppc_cpu_unrealize(DeviceState *dev, Error **errp)
 {
     PowerPCCPU *cpu = POWERPC_CPU(dev);
     PowerPCCPUClass *pcc = POWERPC_CPU_GET_CLASS(cpu);
-    Error *local_err = NULL;
     opc_handler_t **table, **table_2;
     int i, j, k;
 
-    pcc->parent_unrealize(dev, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    pcc->parent_unrealize(dev, errp);
+    if (*errp != NULL) {
         return;
     }
 
@@ -10200,7 +10195,6 @@ static void ppc_cpu_parse_featurestr(const char *type, char *features,
         int i;
         char **inpieces;
         char *s = features;
-        Error *local_err = NULL;
         char *compat_str = NULL;
 
         /*
@@ -10228,11 +10222,10 @@ static void ppc_cpu_parse_featurestr(const char *type, char *features,
 
         if (compat_str) {
             char *v = compat_str + strlen("compat=");
-            object_property_set_str(machine, v, "max-cpu-compat", &local_err);
+            object_property_set_str(machine, v, "max-cpu-compat", errp);
         }
         g_strfreev(inpieces);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        if (*errp) {
             return;
         }
     }
diff --git a/target/riscv/cpu.c b/target/riscv/cpu.c
index f13e298a36..08aef7c77d 100644
--- a/target/riscv/cpu.c
+++ b/target/riscv/cpu.c
@@ -322,11 +322,9 @@ static void riscv_cpu_realize(DeviceState *dev, Error **errp)
     RISCVCPUClass *mcc = RISCV_CPU_GET_CLASS(dev);
     int priv_version = PRIV_VERSION_1_11_0;
     target_ulong target_misa = 0;
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/s390x/cpu.c b/target/s390x/cpu.c
index 3abe7e80fd..11ce0c2114 100644
--- a/target/s390x/cpu.c
+++ b/target/s390x/cpu.c
@@ -189,37 +189,36 @@ static void s390_cpu_realizefn(DeviceState *dev, Error **errp)
 #if !defined(CONFIG_USER_ONLY)
     S390CPU *cpu = S390_CPU(dev);
 #endif
-    Error *err = NULL;
 
     /* the model has to be realized before qemu_init_vcpu() due to kvm */
-    s390_realize_cpu_model(cs, &err);
-    if (err) {
-        goto out;
+    s390_realize_cpu_model(cs, errp);
+    if (*errp) {
+        return;
     }
 
 #if !defined(CONFIG_USER_ONLY)
     MachineState *ms = MACHINE(qdev_get_machine());
     unsigned int max_cpus = ms->smp.max_cpus;
     if (cpu->env.core_id >= max_cpus) {
-        error_setg(&err, "Unable to add CPU with core-id: %" PRIu32
+        error_setg(errp, "Unable to add CPU with core-id: %" PRIu32
                    ", maximum core-id: %d", cpu->env.core_id,
                    max_cpus - 1);
-        goto out;
+        return;
     }
 
     if (cpu_exists(cpu->env.core_id)) {
-        error_setg(&err, "Unable to add CPU with core-id: %" PRIu32
+        error_setg(errp, "Unable to add CPU with core-id: %" PRIu32
                    ", it already exists", cpu->env.core_id);
-        goto out;
+        return;
     }
 
     /* sync cs->cpu_index and env->core_id. The latter is needed for TCG. */
     cs->cpu_index = cpu->env.core_id;
 #endif
 
-    cpu_exec_realizefn(cs, &err);
-    if (err != NULL) {
-        goto out;
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
+        return;
     }
 
 #if !defined(CONFIG_USER_ONLY)
@@ -240,9 +239,7 @@ static void s390_cpu_realizefn(DeviceState *dev, Error **errp)
         cpu_reset(cs);
     }
 
-    scc->parent_realize(dev, &err);
-out:
-    error_propagate(errp, err);
+    scc->parent_realize(dev, errp);
 }
 
 static GuestPanicInformation *s390_cpu_get_crash_info(CPUState *cs)
diff --git a/target/s390x/kvm-stub.c b/target/s390x/kvm-stub.c
index 5152e2bdf1..2472ed6239 100644
--- a/target/s390x/kvm-stub.c
+++ b/target/s390x/kvm-stub.c
@@ -94,6 +94,7 @@ int kvm_s390_set_mem_limit(uint64_t new_limit, uint64_t *hw_limit)
 
 void kvm_s390_set_max_pagesize(uint64_t pagesize, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 void kvm_s390_crypto_reset(void)
diff --git a/target/sh4/cpu.c b/target/sh4/cpu.c
index d0a7707991..787bb53010 100644
--- a/target/sh4/cpu.c
+++ b/target/sh4/cpu.c
@@ -176,11 +176,9 @@ static void superh_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     SuperHCPUClass *scc = SUPERH_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/sparc/cpu.c b/target/sparc/cpu.c
index bc65929552..853b6277fc 100644
--- a/target/sparc/cpu.c
+++ b/target/sparc/cpu.c
@@ -738,7 +738,6 @@ static void sparc_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     SPARCCPUClass *scc = SPARC_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
     SPARCCPU *cpu = SPARC_CPU(dev);
     CPUSPARCState *env = &cpu->env;
 
@@ -762,9 +761,8 @@ static void sparc_cpu_realizefn(DeviceState *dev, Error **errp)
     env->version |= env->def.nwindows - 1;
 #endif
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
@@ -801,12 +799,10 @@ static void sparc_set_nwindows(Object *obj, Visitor *v, const char *name,
     const int64_t min = MIN_NWINDOWS;
     const int64_t max = MAX_NWINDOWS;
     SPARCCPU *cpu = SPARC_CPU(obj);
-    Error *err = NULL;
     int64_t value;
 
-    visit_type_int(v, name, &value, &err);
-    if (err) {
-        error_propagate(errp, err);
+    visit_type_int(v, name, &value, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/target/tilegx/cpu.c b/target/tilegx/cpu.c
index 2b2a7ccc31..4190974aaf 100644
--- a/target/tilegx/cpu.c
+++ b/target/tilegx/cpu.c
@@ -83,11 +83,9 @@ static void tilegx_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     TileGXCPUClass *tcc = TILEGX_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/tricore/cpu.c b/target/tricore/cpu.c
index df807c1d74..f7a19d309c 100644
--- a/target/tricore/cpu.c
+++ b/target/tricore/cpu.c
@@ -75,11 +75,9 @@ static void tricore_cpu_realizefn(DeviceState *dev, Error **errp)
     TriCoreCPU *cpu = TRICORE_CPU(dev);
     TriCoreCPUClass *tcc = TRICORE_CPU_GET_CLASS(dev);
     CPUTriCoreState *env = &cpu->env;
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/unicore32/cpu.c b/target/unicore32/cpu.c
index b27fb9689f..7bf74222f7 100644
--- a/target/unicore32/cpu.c
+++ b/target/unicore32/cpu.c
@@ -86,11 +86,9 @@ static void uc32_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     UniCore32CPUClass *ucc = UNICORE32_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/target/xtensa/cpu.c b/target/xtensa/cpu.c
index c65dcf9dd7..b2b9617f81 100644
--- a/target/xtensa/cpu.c
+++ b/target/xtensa/cpu.c
@@ -133,15 +133,13 @@ static void xtensa_cpu_realizefn(DeviceState *dev, Error **errp)
 {
     CPUState *cs = CPU(dev);
     XtensaCPUClass *xcc = XTENSA_CPU_GET_CLASS(dev);
-    Error *local_err = NULL;
 
 #ifndef CONFIG_USER_ONLY
     xtensa_irq_init(&XTENSA_CPU(dev)->env);
 #endif
 
-    cpu_exec_realizefn(cs, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    cpu_exec_realizefn(cs, errp);
+    if (*errp != NULL) {
         return;
     }
 
diff --git a/tests/test-image-locking.c b/tests/test-image-locking.c
index ba057bd66c..49c6c9ed7b 100644
--- a/tests/test-image-locking.c
+++ b/tests/test-image-locking.c
@@ -35,20 +35,18 @@ static BlockBackend *open_image(const char *path,
                                 uint64_t perm, uint64_t shared_perm,
                                 Error **errp)
 {
-    Error *local_err = NULL;
     BlockBackend *blk;
     QDict *options = qdict_new();
 
     qdict_put_str(options, "driver", "raw");
-    blk = blk_new_open(path, NULL, options, BDRV_O_RDWR, &local_err);
+    blk = blk_new_open(path, NULL, options, BDRV_O_RDWR, errp);
     if (blk) {
-        g_assert_null(local_err);
+        g_assert_null(*errp);
         if (blk_set_perm(blk, perm, shared_perm, errp)) {
             blk_unref(blk);
             blk = NULL;
         }
     } else {
-        error_propagate(errp, local_err);
     }
     return blk;
 }
diff --git a/tests/test-qmp-cmds.c b/tests/test-qmp-cmds.c
index ab389f42da..3cf918ab6e 100644
--- a/tests/test-qmp-cmds.c
+++ b/tests/test-qmp-cmds.c
@@ -24,14 +24,17 @@ UserDefThree *qmp_TestCmdReturnDefThree(Error **errp)
 
 void qmp_user_def_cmd(Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 void qmp_test_flags_command(Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 void qmp_cmd_success_response(Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 Empty2 *qmp_user_def_cmd0(Error **errp)
@@ -41,6 +44,7 @@ Empty2 *qmp_user_def_cmd0(Error **errp)
 
 void qmp_user_def_cmd1(UserDefOne * ud1, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 void qmp_test_features(FeatureStruct0 *fs0, FeatureStruct1 *fs1,
@@ -49,6 +53,7 @@ void qmp_test_features(FeatureStruct0 *fs0, FeatureStruct1 *fs1,
                        CondFeatureStruct2 *cfs2, CondFeatureStruct3 *cfs3,
                        Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 UserDefTwo *qmp_user_def_cmd2(UserDefOne *ud1a,
@@ -91,10 +96,12 @@ QObject *qmp_guest_sync(QObject *arg, Error **errp)
 
 void qmp_boxed_struct(UserDefZero *arg, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 void qmp_boxed_union(UserDefListUnion *arg, Error **errp)
 {
+	ERRP_FUNCTION_BEGIN();
 }
 
 __org_qemu_x_Union1 *qmp___org_qemu_x_command(__org_qemu_x_EnumList *a,
diff --git a/tpm.c b/tpm.c
index 9c9e20bbb7..a3a0eb76f0 100644
--- a/tpm.c
+++ b/tpm.c
@@ -85,7 +85,6 @@ static int tpm_init_tpmdev(void *dummy, QemuOpts *opts, Error **errp)
     const char *id;
     const TPMBackendClass *be;
     TPMBackend *drv;
-    Error *local_err = NULL;
     int i;
 
     if (!QLIST_EMPTY(&tpm_backends)) {
@@ -116,9 +115,8 @@ static int tpm_init_tpmdev(void *dummy, QemuOpts *opts, Error **errp)
     }
 
     /* validate backend specific opts */
-    qemu_opts_validate(opts, be->opts, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_validate(opts, be->opts, errp);
+    if (*errp) {
         return 1;
     }
 
diff --git a/trace/qmp.c b/trace/qmp.c
index 38246e1aa6..1fc19d2eb0 100644
--- a/trace/qmp.c
+++ b/trace/qmp.c
@@ -70,7 +70,6 @@ TraceEventInfoList *qmp_trace_event_get_state(const char *name,
                                               bool has_vcpu, int64_t vcpu,
                                               Error **errp)
 {
-    Error *err = NULL;
     TraceEventInfoList *events = NULL;
     TraceEventIter iter;
     TraceEvent *ev;
@@ -78,9 +77,8 @@ TraceEventInfoList *qmp_trace_event_get_state(const char *name,
     CPUState *cpu;
 
     /* Check provided vcpu */
-    cpu = get_cpu(has_vcpu, vcpu, &err);
-    if (err) {
-        error_propagate(errp, err);
+    cpu = get_cpu(has_vcpu, vcpu, errp);
+    if (*errp) {
         return NULL;
     }
 
@@ -135,16 +133,14 @@ void qmp_trace_event_set_state(const char *name, bool enable,
                                bool has_vcpu, int64_t vcpu,
                                Error **errp)
 {
-    Error *err = NULL;
     TraceEventIter iter;
     TraceEvent *ev;
     bool is_pattern = trace_event_is_pattern(name);
     CPUState *cpu;
 
     /* Check provided vcpu */
-    cpu = get_cpu(has_vcpu, vcpu, &err);
-    if (err) {
-        error_propagate(errp, err);
+    cpu = get_cpu(has_vcpu, vcpu, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/ui/input-barrier.c b/ui/input-barrier.c
index a2c961f285..84491744c5 100644
--- a/ui/input-barrier.c
+++ b/ui/input-barrier.c
@@ -493,7 +493,6 @@ static gboolean input_barrier_event(QIOChannel *ioc G_GNUC_UNUSED,
 static void input_barrier_complete(UserCreatable *uc, Error **errp)
 {
     InputBarrier *ib = INPUT_BARRIER(uc);
-    Error *local_err = NULL;
 
     if (!ib->name) {
         error_setg(errp, QERR_MISSING_PARAMETER, "name");
@@ -509,9 +508,8 @@ static void input_barrier_complete(UserCreatable *uc, Error **errp)
     ib->sioc = qio_channel_socket_new();
     qio_channel_set_name(QIO_CHANNEL(ib->sioc), "barrier-client");
 
-    qio_channel_socket_connect_sync(ib->sioc, &ib->saddr, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qio_channel_socket_connect_sync(ib->sioc, &ib->saddr, errp);
+    if (*errp) {
         return;
     }
 
diff --git a/ui/input.c b/ui/input.c
index 4791b089c7..276c34900e 100644
--- a/ui/input.c
+++ b/ui/input.c
@@ -88,11 +88,9 @@ void qemu_input_handler_bind(QemuInputHandlerState *s,
                              Error **errp)
 {
     QemuConsole *con;
-    Error *err = NULL;
 
-    con = qemu_console_lookup_by_device_name(device_id, head, &err);
-    if (err) {
-        error_propagate(errp, err);
+    con = qemu_console_lookup_by_device_name(device_id, head, errp);
+    if (*errp) {
         return;
     }
 
@@ -130,16 +128,14 @@ void qmp_input_send_event(bool has_device, const char *device,
 {
     InputEventList *e;
     QemuConsole *con;
-    Error *err = NULL;
 
     con = NULL;
     if (has_device) {
         if (!has_head) {
             head = 0;
         }
-        con = qemu_console_lookup_by_device_name(device, head, &err);
-        if (err) {
-            error_propagate(errp, err);
+        con = qemu_console_lookup_by_device_name(device, head, errp);
+        if (*errp) {
             return;
         }
     }
diff --git a/ui/vnc.c b/ui/vnc.c
index 9d6384d9b1..37721e971b 100644
--- a/ui/vnc.c
+++ b/ui/vnc.c
@@ -4014,11 +4014,9 @@ void vnc_display_open(const char *id, Error **errp)
     device_id = qemu_opt_get(opts, "display");
     if (device_id) {
         int head = qemu_opt_get_number(opts, "head", 0);
-        Error *err = NULL;
 
-        con = qemu_console_lookup_by_device_name(device_id, head, &err);
-        if (err) {
-            error_propagate(errp, err);
+        con = qemu_console_lookup_by_device_name(device_id, head, errp);
+        if (*errp) {
             goto fail;
         }
     } else {
@@ -4112,18 +4110,15 @@ QemuOpts *vnc_parse(const char *str, Error **errp)
 
 int vnc_init_func(void *opaque, QemuOpts *opts, Error **errp)
 {
-    Error *local_err = NULL;
     char *id = (char *)qemu_opts_id(opts);
 
     assert(id);
-    vnc_display_init(id, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    vnc_display_init(id, errp);
+    if (*errp) {
         return -1;
     }
-    vnc_display_open(id, &local_err);
-    if (local_err != NULL) {
-        error_propagate(errp, local_err);
+    vnc_display_open(id, errp);
+    if (*errp != NULL) {
         return -1;
     }
     return 0;
diff --git a/util/main-loop.c b/util/main-loop.c
index e3eaa55866..6f3492d943 100644
--- a/util/main-loop.c
+++ b/util/main-loop.c
@@ -147,7 +147,6 @@ int qemu_init_main_loop(Error **errp)
 {
     int ret;
     GSource *src;
-    Error *local_error = NULL;
 
     init_clocks(qemu_timer_notify_cb);
 
@@ -156,9 +155,8 @@ int qemu_init_main_loop(Error **errp)
         return ret;
     }
 
-    qemu_aio_context = aio_context_new(&local_error);
+    qemu_aio_context = aio_context_new(errp);
     if (!qemu_aio_context) {
-        error_propagate(errp, local_error);
         return -EMFILE;
     }
     qemu_notify_bh = qemu_bh_new(notify_event_cb, NULL);
diff --git a/util/oslib-posix.c b/util/oslib-posix.c
index f8693384fc..b1671f11e6 100644
--- a/util/oslib-posix.c
+++ b/util/oslib-posix.c
@@ -600,10 +600,9 @@ pid_t qemu_fork(Error **errp)
          * propagate that to children */
         sigemptyset(&newmask);
         if (pthread_sigmask(SIG_SETMASK, &newmask, NULL) != 0) {
-            Error *local_err = NULL;
-            error_setg_errno(&local_err, errno,
+            error_setg_errno(errp, errno,
                              "cannot unblock signals");
-            error_report_err(local_err);
+            error_report_errp(errp);
             _exit(1);
         }
     }
diff --git a/util/qemu-config.c b/util/qemu-config.c
index 772f5a219e..b0266f9954 100644
--- a/util/qemu-config.c
+++ b/util/qemu-config.c
@@ -481,7 +481,6 @@ static void config_parse_qdict_section(QDict *options, QemuOptsList *opts,
     QemuOpts *subopts;
     QDict *subqdict;
     QList *list = NULL;
-    Error *local_err = NULL;
     size_t orig_size, enum_size;
     char *prefix;
 
@@ -493,15 +492,13 @@ static void config_parse_qdict_section(QDict *options, QemuOptsList *opts,
         goto out;
     }
 
-    subopts = qemu_opts_create(opts, NULL, 0, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    subopts = qemu_opts_create(opts, NULL, 0, errp);
+    if (*errp) {
         goto out;
     }
 
-    qemu_opts_absorb_qdict(subopts, subqdict, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opts_absorb_qdict(subopts, subqdict, errp);
+    if (*errp) {
         goto out;
     }
 
@@ -538,16 +535,14 @@ static void config_parse_qdict_section(QDict *options, QemuOptsList *opts,
             }
 
             opt_name = g_strdup_printf("%s.%u", opts->name, i++);
-            subopts = qemu_opts_create(opts, opt_name, 1, &local_err);
+            subopts = qemu_opts_create(opts, opt_name, 1, errp);
             g_free(opt_name);
-            if (local_err) {
-                error_propagate(errp, local_err);
+            if (*errp) {
                 goto out;
             }
 
-            qemu_opts_absorb_qdict(subopts, section, &local_err);
-            if (local_err) {
-                error_propagate(errp, local_err);
+            qemu_opts_absorb_qdict(subopts, section, errp);
+            if (*errp) {
                 qemu_opts_del(subopts);
                 goto out;
             }
@@ -570,12 +565,10 @@ void qemu_config_parse_qdict(QDict *options, QemuOptsList **lists,
                              Error **errp)
 {
     int i;
-    Error *local_err = NULL;
 
     for (i = 0; lists[i]; i++) {
-        config_parse_qdict_section(options, lists[i], &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        config_parse_qdict_section(options, lists[i], errp);
+        if (*errp) {
             return;
         }
     }
diff --git a/util/qemu-option.c b/util/qemu-option.c
index 97172b5eaa..261b347e83 100644
--- a/util/qemu-option.c
+++ b/util/qemu-option.c
@@ -543,7 +543,6 @@ static void opt_set(QemuOpts *opts, const char *name, char *value,
 {
     QemuOpt *opt;
     const QemuOptDesc *desc;
-    Error *local_err = NULL;
 
     desc = find_desc_by_name(opts->list->desc, name);
     if (!desc && !opts_accepts_any(opts)) {
@@ -565,9 +564,8 @@ static void opt_set(QemuOpts *opts, const char *name, char *value,
     }
     opt->desc = desc;
     opt->str = value;
-    qemu_opt_parse(opt, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    qemu_opt_parse(opt, errp);
+    if (*errp) {
         qemu_opt_del(opt);
     }
 }
@@ -712,11 +710,9 @@ void qemu_opts_set(QemuOptsList *list, const char *id,
                    const char *name, const char *value, Error **errp)
 {
     QemuOpts *opts;
-    Error *local_err = NULL;
 
-    opts = qemu_opts_create(list, id, 1, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    opts = qemu_opts_create(list, id, 1, errp);
+    if (*errp) {
         return;
     }
     qemu_opt_set(opts, name, value, errp);
@@ -812,7 +808,6 @@ static void opts_do_parse(QemuOpts *opts, const char *params,
     char *option = NULL;
     char *value = NULL;
     const char *p,*pe,*pc;
-    Error *local_err = NULL;
 
     for (p = params; *p != '\0'; p++) {
         pe = strchr(p, '=');
@@ -842,10 +837,9 @@ static void opts_do_parse(QemuOpts *opts, const char *params,
         }
         if (strcmp(option, "id") != 0) {
             /* store and parse */
-            opt_set(opts, option, value, prepend, invalidp, &local_err);
+            opt_set(opts, option, value, prepend, invalidp, errp);
             value = NULL;
-            if (local_err) {
-                error_propagate(errp, local_err);
+            if (*errp) {
                 goto cleanup;
             }
         }
@@ -882,7 +876,6 @@ static QemuOpts *opts_parse(QemuOptsList *list, const char *params,
     char *id = NULL;
     const char *p;
     QemuOpts *opts;
-    Error *local_err = NULL;
 
     assert(!permit_abbrev || list->implied_opt_name);
     firstname = permit_abbrev ? list->implied_opt_name : NULL;
@@ -901,16 +894,14 @@ static QemuOpts *opts_parse(QemuOptsList *list, const char *params,
      * (if unlikely) future misuse:
      */
     assert(!defaults || list->merge_lists);
-    opts = qemu_opts_create(list, id, !defaults, &local_err);
+    opts = qemu_opts_create(list, id, !defaults, errp);
     g_free(id);
     if (opts == NULL) {
-        error_propagate(errp, local_err);
         return NULL;
     }
 
-    opts_do_parse(opts, params, firstname, defaults, invalidp, &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    opts_do_parse(opts, params, firstname, defaults, invalidp, errp);
+    if (*errp) {
         qemu_opts_del(opts);
         return NULL;
     }
@@ -1013,23 +1004,20 @@ QemuOpts *qemu_opts_from_qdict(QemuOptsList *list, const QDict *qdict,
                                Error **errp)
 {
     OptsFromQDictState state;
-    Error *local_err = NULL;
     QemuOpts *opts;
 
     opts = qemu_opts_create(list, qdict_get_try_str(qdict, "id"), 1,
-                            &local_err);
-    if (local_err) {
-        error_propagate(errp, local_err);
+                            errp);
+    if (*errp) {
         return NULL;
     }
 
     assert(opts != NULL);
 
-    state.errp = &local_err;
+    state.errp = errp;
     state.opts = opts;
     qdict_iter(qdict, qemu_opts_from_qdict_1, &state);
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         qemu_opts_del(opts);
         return NULL;
     }
@@ -1049,9 +1037,8 @@ void qemu_opts_absorb_qdict(QemuOpts *opts, QDict *qdict, Error **errp)
     entry = qdict_first(qdict);
 
     while (entry != NULL) {
-        Error *local_err = NULL;
         OptsFromQDictState state = {
-            .errp = &local_err,
+            .errp = errp,
             .opts = opts,
         };
 
@@ -1059,8 +1046,7 @@ void qemu_opts_absorb_qdict(QemuOpts *opts, QDict *qdict, Error **errp)
 
         if (find_desc_by_name(opts->list->desc, entry->key)) {
             qemu_opts_from_qdict_1(entry->key, entry->value, &state);
-            if (local_err) {
-                error_propagate(errp, local_err);
+            if (*errp) {
                 return;
             } else {
                 qdict_del(qdict, entry->key);
@@ -1131,7 +1117,6 @@ QDict *qemu_opts_to_qdict(QemuOpts *opts, QDict *qdict)
 void qemu_opts_validate(QemuOpts *opts, const QemuOptDesc *desc, Error **errp)
 {
     QemuOpt *opt;
-    Error *local_err = NULL;
 
     assert(opts_accepts_any(opts));
 
@@ -1142,9 +1127,8 @@ void qemu_opts_validate(QemuOpts *opts, const QemuOptDesc *desc, Error **errp)
             return;
         }
 
-        qemu_opt_parse(opt, &local_err);
-        if (local_err) {
-            error_propagate(errp, local_err);
+        qemu_opt_parse(opt, errp);
+        if (*errp) {
             return;
         }
     }
diff --git a/util/qemu-sockets.c b/util/qemu-sockets.c
index 98ff3a1cce..9832d8278d 100644
--- a/util/qemu-sockets.c
+++ b/util/qemu-sockets.c
@@ -219,7 +219,6 @@ static int inet_listen_saddr(InetSocketAddress *saddr,
     int slisten = -1;
     int saved_errno = 0;
     bool socket_created = false;
-    Error *err = NULL;
 
     if (saddr->keep_alive) {
         error_setg(errp, "keep-alive option is not supported for passive "
@@ -232,11 +231,10 @@ static int inet_listen_saddr(InetSocketAddress *saddr,
     if (saddr->has_numeric && saddr->numeric) {
         ai.ai_flags |= AI_NUMERICHOST | AI_NUMERICSERV;
     }
-    ai.ai_family = inet_ai_family_from_address(saddr, &err);
+    ai.ai_family = inet_ai_family_from_address(saddr, errp);
     ai.ai_socktype = SOCK_STREAM;
 
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         return -1;
     }
 
@@ -389,7 +387,6 @@ static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,
 {
     struct addrinfo ai, *res;
     int rc;
-    Error *err = NULL;
     static int useV4Mapped = 1;
 
     memset(&ai, 0, sizeof(ai));
@@ -398,11 +395,10 @@ static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,
     if (atomic_read(&useV4Mapped)) {
         ai.ai_flags |= AI_V4MAPPED;
     }
-    ai.ai_family = inet_ai_family_from_address(saddr, &err);
+    ai.ai_family = inet_ai_family_from_address(saddr, errp);
     ai.ai_socktype = SOCK_STREAM;
 
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         return NULL;
     }
 
@@ -443,7 +439,6 @@ static struct addrinfo *inet_parse_connect_saddr(InetSocketAddress *saddr,
  */
 int inet_connect_saddr(InetSocketAddress *saddr, Error **errp)
 {
-    Error *local_err = NULL;
     struct addrinfo *res, *e;
     int sock = -1;
 
@@ -453,16 +448,14 @@ int inet_connect_saddr(InetSocketAddress *saddr, Error **errp)
     }
 
     for (e = res; e != NULL; e = e->ai_next) {
-        error_free(local_err);
-        local_err = NULL;
-        sock = inet_connect_addr(e, &local_err);
+        error_free_errp(errp);
+        sock = inet_connect_addr(e, errp);
         if (sock >= 0) {
             break;
         }
     }
 
     if (sock < 0) {
-        error_propagate(errp, local_err);
     }
 
     freeaddrinfo(res);
@@ -490,16 +483,14 @@ static int inet_dgram_saddr(InetSocketAddress *sraddr,
     const char *addr;
     const char *port;
     int sock = -1, rc;
-    Error *err = NULL;
 
     /* lookup peer addr */
     memset(&ai,0, sizeof(ai));
     ai.ai_flags = AI_CANONNAME | AI_V4MAPPED | AI_ADDRCONFIG;
-    ai.ai_family = inet_ai_family_from_address(sraddr, &err);
+    ai.ai_family = inet_ai_family_from_address(sraddr, errp);
     ai.ai_socktype = SOCK_DGRAM;
 
-    if (err) {
-        error_propagate(errp, err);
+    if (*errp) {
         goto err;
     }
 
diff --git a/vl.c b/vl.c
index 630f5c5e9c..21f5679964 100644
--- a/vl.c
+++ b/vl.c
@@ -2213,11 +2213,8 @@ static int device_init_func(void *opaque, QemuOpts *opts, Error **errp)
 
 static int chardev_init_func(void *opaque, QemuOpts *opts, Error **errp)
 {
-    Error *local_err = NULL;
-
-    if (!qemu_chr_new_from_opts(opts, NULL, &local_err)) {
-        if (local_err) {
-            error_propagate(errp, local_err);
+    if (!qemu_chr_new_from_opts(opts, NULL, errp)) {
+        if (*errp) {
             return -1;
         }
         exit(0);
@@ -2614,7 +2611,6 @@ static int machine_set_property(void *opaque,
                                 Error **errp)
 {
     Object *obj = OBJECT(opaque);
-    Error *local_err = NULL;
     char *p, *qom_name;
 
     if (strcmp(name, "type") == 0) {
@@ -2628,11 +2624,10 @@ static int machine_set_property(void *opaque,
         }
     }
 
-    object_property_parse(obj, value, qom_name, &local_err);
+    object_property_parse(obj, value, qom_name, errp);
     g_free(qom_name);
 
-    if (local_err) {
-        error_propagate(errp, local_err);
+    if (*errp) {
         return -1;
     }
 
-- 
2.21.0


