Return-Path: <qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org>
X-Original-To: lists+qemu-devel@lfdr.de
Delivered-To: lists+qemu-devel@lfdr.de
Received: from lists.gnu.org (lists.gnu.org [209.51.188.17])
	by mail.lfdr.de (Postfix) with ESMTPS id 7CDCD120621
	for <lists+qemu-devel@lfdr.de>; Mon, 16 Dec 2019 13:46:46 +0100 (CET)
Received: from localhost ([::1]:52880 helo=lists1p.gnu.org)
	by lists.gnu.org with esmtp (Exim 4.90_1)
	(envelope-from <qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org>)
	id 1igplt-0000Kx-17
	for lists+qemu-devel@lfdr.de; Mon, 16 Dec 2019 07:46:45 -0500
Received: from eggs.gnu.org ([2001:470:142:3::10]:58784)
 by lists.gnu.org with esmtp (Exim 4.90_1)
 (envelope-from <aleksandar.markovic@rt-rk.com>) id 1igpjP-0006kI-Fi
 for qemu-devel@nongnu.org; Mon, 16 Dec 2019 07:44:13 -0500
Received: from Debian-exim by eggs.gnu.org with spam-scanned (Exim 4.71)
 (envelope-from <aleksandar.markovic@rt-rk.com>) id 1igpjL-0006v0-PM
 for qemu-devel@nongnu.org; Mon, 16 Dec 2019 07:44:10 -0500
Received: from mx2.rt-rk.com ([89.216.37.149]:42905 helo=mail.rt-rk.com)
 by eggs.gnu.org with esmtps (TLS1.0:DHE_RSA_AES_256_CBC_SHA1:32)
 (Exim 4.71) (envelope-from <aleksandar.markovic@rt-rk.com>)
 id 1igpjL-0005li-DF
 for qemu-devel@nongnu.org; Mon, 16 Dec 2019 07:44:07 -0500
Received: from localhost (localhost [127.0.0.1])
 by mail.rt-rk.com (Postfix) with ESMTP id A0B7F1A20A7;
 Mon, 16 Dec 2019 13:43:01 +0100 (CET)
X-Virus-Scanned: amavisd-new at rt-rk.com
Received: from rtrkw774-lin.domain.local (rtrkw774-lin.domain.local
 [10.10.14.106])
 by mail.rt-rk.com (Postfix) with ESMTPSA id 7B0221A2062;
 Mon, 16 Dec 2019 13:43:01 +0100 (CET)
From: Aleksandar Markovic <aleksandar.markovic@rt-rk.com>
To: qemu-devel@nongnu.org
Subject: [PULL 01/11] mips: jazz: Renovate coding style
Date: Mon, 16 Dec 2019 13:42:42 +0100
Message-Id: <1576500172-11264-2-git-send-email-aleksandar.markovic@rt-rk.com>
X-Mailer: git-send-email 2.7.4
In-Reply-To: <1576500172-11264-1-git-send-email-aleksandar.markovic@rt-rk.com>
References: <1576500172-11264-1-git-send-email-aleksandar.markovic@rt-rk.com>
X-detected-operating-system: by eggs.gnu.org: GNU/Linux 3.x [fuzzy]
X-Received-From: 89.216.37.149
X-BeenThere: qemu-devel@nongnu.org
X-Mailman-Version: 2.1.23
Precedence: list
List-Id: <qemu-devel.nongnu.org>
List-Unsubscribe: <https://lists.nongnu.org/mailman/options/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=unsubscribe>
List-Archive: <https://lists.nongnu.org/archive/html/qemu-devel>
List-Post: <mailto:qemu-devel@nongnu.org>
List-Help: <mailto:qemu-devel-request@nongnu.org?subject=help>
List-Subscribe: <https://lists.nongnu.org/mailman/listinfo/qemu-devel>,
 <mailto:qemu-devel-request@nongnu.org?subject=subscribe>
Cc: peter.maydell@linaro.org, amarkovic@wavecomp.com
Errors-To: qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org
Sender: "Qemu-devel" <qemu-devel-bounces+lists+qemu-devel=lfdr.de@nongnu.org>

From: Filip Bozuta <Filip.Bozuta@rt-rk.com>

The script checkpatch.pl located in scripts folder was
used to detect all errors and warrnings in files:
    hw/mips/mips_jazz.c
    hw/display/jazz_led.c
    hw/dma/rc4030.c

All these mips jazz machine files were edited and
all the errors and warrings generated by the checkpatch.pl
script were corrected and then the script was
ran again to make sure there are no more errors and warnings.

Signed-off-by: Filip Bozuta <Filip.Bozuta@rt-rk.com>
Signed-off-by: Aleksandar Markovic <amarkovic@wavecomp.com>
Reviewed-by: Aleksandar Markovic <amarkovic@wavecomp.com>
Message-Id: <1575640687-20744-2-git-send-email-Filip.Bozuta@rt-rk.com>
---
 hw/display/jazz_led.c | 123 +++++++++++++++++++++++++-------------------------
 hw/dma/rc4030.c       |  12 +++--
 hw/mips/mips_jazz.c   |  32 +++++++------
 3 files changed, 88 insertions(+), 79 deletions(-)

diff --git a/hw/display/jazz_led.c b/hw/display/jazz_led.c
index 3e0112b..1d84559 100644
--- a/hw/display/jazz_led.c
+++ b/hw/display/jazz_led.c
@@ -90,25 +90,25 @@ static void draw_horizontal_line(DisplaySurface *ds,
 
     bpp = (surface_bits_per_pixel(ds) + 7) >> 3;
     d = surface_data(ds) + surface_stride(ds) * posy + bpp * posx1;
-    switch(bpp) {
-        case 1:
-            for (x = posx1; x <= posx2; x++) {
-                *((uint8_t *)d) = color;
-                d++;
-            }
-            break;
-        case 2:
-            for (x = posx1; x <= posx2; x++) {
-                *((uint16_t *)d) = color;
-                d += 2;
-            }
-            break;
-        case 4:
-            for (x = posx1; x <= posx2; x++) {
-                *((uint32_t *)d) = color;
-                d += 4;
-            }
-            break;
+    switch (bpp) {
+    case 1:
+        for (x = posx1; x <= posx2; x++) {
+            *((uint8_t *)d) = color;
+            d++;
+        }
+        break;
+    case 2:
+        for (x = posx1; x <= posx2; x++) {
+            *((uint16_t *)d) = color;
+            d += 2;
+        }
+        break;
+    case 4:
+        for (x = posx1; x <= posx2; x++) {
+            *((uint32_t *)d) = color;
+            d += 4;
+        }
+        break;
     }
 }
 
@@ -121,25 +121,25 @@ static void draw_vertical_line(DisplaySurface *ds,
 
     bpp = (surface_bits_per_pixel(ds) + 7) >> 3;
     d = surface_data(ds) + surface_stride(ds) * posy1 + bpp * posx;
-    switch(bpp) {
-        case 1:
-            for (y = posy1; y <= posy2; y++) {
-                *((uint8_t *)d) = color;
-                d += surface_stride(ds);
-            }
-            break;
-        case 2:
-            for (y = posy1; y <= posy2; y++) {
-                *((uint16_t *)d) = color;
-                d += surface_stride(ds);
-            }
-            break;
-        case 4:
-            for (y = posy1; y <= posy2; y++) {
-                *((uint32_t *)d) = color;
-                d += surface_stride(ds);
-            }
-            break;
+    switch (bpp) {
+    case 1:
+        for (y = posy1; y <= posy2; y++) {
+            *((uint8_t *)d) = color;
+            d += surface_stride(ds);
+        }
+        break;
+    case 2:
+        for (y = posy1; y <= posy2; y++) {
+            *((uint16_t *)d) = color;
+            d += surface_stride(ds);
+        }
+        break;
+    case 4:
+        for (y = posy1; y <= posy2; y++) {
+            *((uint32_t *)d) = color;
+            d += surface_stride(ds);
+        }
+        break;
     }
 }
 
@@ -164,28 +164,28 @@ static void jazz_led_update_display(void *opaque)
     if (s->state & REDRAW_SEGMENTS) {
         /* set colors according to bpp */
         switch (surface_bits_per_pixel(surface)) {
-            case 8:
-                color_segment = rgb_to_pixel8(0xaa, 0xaa, 0xaa);
-                color_led = rgb_to_pixel8(0x00, 0xff, 0x00);
-                break;
-            case 15:
-                color_segment = rgb_to_pixel15(0xaa, 0xaa, 0xaa);
-                color_led = rgb_to_pixel15(0x00, 0xff, 0x00);
-                break;
-            case 16:
-                color_segment = rgb_to_pixel16(0xaa, 0xaa, 0xaa);
-                color_led = rgb_to_pixel16(0x00, 0xff, 0x00);
-                break;
-            case 24:
-                color_segment = rgb_to_pixel24(0xaa, 0xaa, 0xaa);
-                color_led = rgb_to_pixel24(0x00, 0xff, 0x00);
-                break;
-            case 32:
-                color_segment = rgb_to_pixel32(0xaa, 0xaa, 0xaa);
-                color_led = rgb_to_pixel32(0x00, 0xff, 0x00);
-                break;
-            default:
-                return;
+        case 8:
+            color_segment = rgb_to_pixel8(0xaa, 0xaa, 0xaa);
+            color_led = rgb_to_pixel8(0x00, 0xff, 0x00);
+            break;
+        case 15:
+            color_segment = rgb_to_pixel15(0xaa, 0xaa, 0xaa);
+            color_led = rgb_to_pixel15(0x00, 0xff, 0x00);
+            break;
+        case 16:
+            color_segment = rgb_to_pixel16(0xaa, 0xaa, 0xaa);
+            color_led = rgb_to_pixel16(0x00, 0xff, 0x00);
+            break;
+        case 24:
+            color_segment = rgb_to_pixel24(0xaa, 0xaa, 0xaa);
+            color_led = rgb_to_pixel24(0x00, 0xff, 0x00);
+            break;
+        case 32:
+            color_segment = rgb_to_pixel32(0xaa, 0xaa, 0xaa);
+            color_led = rgb_to_pixel32(0x00, 0xff, 0x00);
+            break;
+        default:
+            return;
         }
 
         /* display segments */
@@ -205,8 +205,9 @@ static void jazz_led_update_display(void *opaque)
                              (s->segments & 0x80) ? color_segment : 0);
 
         /* display led */
-        if (!(s->segments & 0x01))
+        if (!(s->segments & 0x01)) {
             color_led = 0; /* black */
+        }
         draw_horizontal_line(surface, 68, 50, 50, color_led);
         draw_horizontal_line(surface, 69, 49, 51, color_led);
         draw_horizontal_line(surface, 70, 48, 52, color_led);
diff --git a/hw/dma/rc4030.c b/hw/dma/rc4030.c
index d54e296..c4cf823 100644
--- a/hw/dma/rc4030.c
+++ b/hw/dma/rc4030.c
@@ -397,10 +397,11 @@ static void update_jazz_irq(rc4030State *s)
 
     pending = s->isr_jazz & s->imr_jazz;
 
-    if (pending != 0)
+    if (pending != 0) {
         qemu_irq_raise(s->jazz_bus_irq);
-    else
+    } else {
         qemu_irq_lower(s->jazz_bus_irq);
+    }
 }
 
 static void rc4030_irq_jazz_request(void *opaque, int irq, int level)
@@ -588,7 +589,8 @@ static const VMStateDescription vmstate_rc4030 = {
     }
 };
 
-static void rc4030_do_dma(void *opaque, int n, uint8_t *buf, int len, int is_write)
+static void rc4030_do_dma(void *opaque, int n, uint8_t *buf,
+                          int len, int is_write)
 {
     rc4030State *s = opaque;
     hwaddr dma_addr;
@@ -643,8 +645,8 @@ static rc4030_dma *rc4030_allocate_dmas(void *opaque, int n)
     struct rc4030DMAState *p;
     int i;
 
-    s = (rc4030_dma *)g_malloc0(sizeof(rc4030_dma) * n);
-    p = (struct rc4030DMAState *)g_malloc0(sizeof(struct rc4030DMAState) * n);
+    s = (rc4030_dma *)g_new0(rc4030_dma, n);
+    p = (struct rc4030DMAState *)g_new0(struct rc4030DMAState, n);
     for (i = 0; i < n; i++) {
         p->opaque = opaque;
         p->n = i;
diff --git a/hw/mips/mips_jazz.c b/hw/mips/mips_jazz.c
index d978bb6..ac4d7ac 100644
--- a/hw/mips/mips_jazz.c
+++ b/hw/mips/mips_jazz.c
@@ -52,8 +52,7 @@
 #include "qemu/error-report.h"
 #include "qemu/help_option.h"
 
-enum jazz_model_e
-{
+enum jazz_model_e {
     JAZZ_MAGNUM,
     JAZZ_PICA61,
 };
@@ -90,16 +89,20 @@ static const MemoryRegionOps rtc_ops = {
 static uint64_t dma_dummy_read(void *opaque, hwaddr addr,
                                unsigned size)
 {
-    /* Nothing to do. That is only to ensure that
-     * the current DMA acknowledge cycle is completed. */
+    /*
+     * Nothing to do. That is only to ensure that
+     * the current DMA acknowledge cycle is completed.
+     */
     return 0xff;
 }
 
 static void dma_dummy_write(void *opaque, hwaddr addr,
                             uint64_t val, unsigned size)
 {
-    /* Nothing to do. That is only to ensure that
-     * the current DMA acknowledge cycle is completed. */
+    /*
+     * Nothing to do. That is only to ensure that
+     * the current DMA acknowledge cycle is completed.
+     */
 }
 
 static const MemoryRegionOps dma_dummy_ops = {
@@ -109,8 +112,8 @@ static const MemoryRegionOps dma_dummy_ops = {
 };
 
 #define MAGNUM_BIOS_SIZE_MAX 0x7e000
-#define MAGNUM_BIOS_SIZE (BIOS_SIZE < MAGNUM_BIOS_SIZE_MAX ? BIOS_SIZE : MAGNUM_BIOS_SIZE_MAX)
-
+#define MAGNUM_BIOS_SIZE                                                       \
+        (BIOS_SIZE < MAGNUM_BIOS_SIZE_MAX ? BIOS_SIZE : MAGNUM_BIOS_SIZE_MAX)
 static void (*real_do_transaction_failed)(CPUState *cpu, hwaddr physaddr,
                                           vaddr addr, unsigned size,
                                           MMUAccessType access_type,
@@ -201,8 +204,9 @@ static void mips_jazz_init(MachineState *machine,
     memory_region_add_subregion(address_space, 0xfff00000LL, bios2);
 
     /* load the BIOS image. */
-    if (bios_name == NULL)
+    if (bios_name == NULL) {
         bios_name = BIOS_FILENAME;
+    }
     filename = qemu_find_file(QEMU_FILE_TYPE_BIOS, bios_name);
     if (filename) {
         bios_size = load_image_targphys(filename, 0xfff00000LL,
@@ -229,7 +233,8 @@ static void mips_jazz_init(MachineState *machine,
                                 sysbus_mmio_get_region(sysbus, 0));
     memory_region_add_subregion(address_space, 0xf0000000,
                                 sysbus_mmio_get_region(sysbus, 1));
-    memory_region_init_io(dma_dummy, NULL, &dma_dummy_ops, NULL, "dummy_dma", 0x1000);
+    memory_region_init_io(dma_dummy, NULL, &dma_dummy_ops,
+                          NULL, "dummy_dma", 0x1000);
     memory_region_add_subregion(address_space, 0x8000d000, dma_dummy);
 
     /* ISA bus: IO space at 0x90000000, mem space at 0x91000000 */
@@ -276,8 +281,9 @@ static void mips_jazz_init(MachineState *machine,
     /* Network controller */
     for (n = 0; n < nb_nics; n++) {
         nd = &nd_table[n];
-        if (!nd->model)
+        if (!nd->model) {
             nd->model = g_strdup("dp83932");
+        }
         if (strcmp(nd->model, "dp83932") == 0) {
             qemu_check_nic_model(nd, "dp83932");
 
@@ -338,12 +344,12 @@ static void mips_jazz_init(MachineState *machine,
     /* Serial ports */
     if (serial_hd(0)) {
         serial_mm_init(address_space, 0x80006000, 0,
-                       qdev_get_gpio_in(rc4030, 8), 8000000/16,
+                       qdev_get_gpio_in(rc4030, 8), 8000000 / 16,
                        serial_hd(0), DEVICE_NATIVE_ENDIAN);
     }
     if (serial_hd(1)) {
         serial_mm_init(address_space, 0x80007000, 0,
-                       qdev_get_gpio_in(rc4030, 9), 8000000/16,
+                       qdev_get_gpio_in(rc4030, 9), 8000000 / 16,
                        serial_hd(1), DEVICE_NATIVE_ENDIAN);
     }
 
-- 
2.7.4


